{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/images/基本框架.png","path":"images/基本框架.png","modified":0,"renderable":0},{"_id":"source/images/alipay.png","path":"images/alipay.png","modified":0,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":0},{"_id":"source/images/runtime.png","path":"images/runtime.png","modified":0,"renderable":0},{"_id":"source/images/bf.png","path":"images/bf.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"source/images/cache.png","path":"images/cache.png","modified":0,"renderable":0},{"_id":"source/images/userCache.png","path":"images/userCache.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"source/images/port.png","path":"images/port.png","modified":0,"renderable":0},{"_id":"source/images/xieyi.png","path":"images/xieyi.png","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/images/trangle.png","path":"images/trangle.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/images/dns.png","path":"images/dns.png","modified":1,"renderable":0},{"_id":"source/images/wechatpay.png","path":"images/wechatpay.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1488120894000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1488120894000},{"_id":"source/favicon.ico","hash":"913e92b87c4cc086086ac1bd0c99733e98cd41f4","modified":1488289128000},{"_id":"source/.DS_Store","hash":"c35b1c972e07820ae347465ccd7293f87ea434cd","modified":1493288846000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1488120894000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1488120894000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1488120894000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1488120894000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1488120894000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1488120894000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1488120894000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1488120894000},{"_id":"themes/next/_config.yml","hash":"3e04f5814296e3b06be64bc485665014a59302e9","modified":1489600451000},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1488120894000},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1488120894000},{"_id":"source/_posts/.DS_Store","hash":"06959e56c4c4fd765a85207bed917e0d05f5a87f","modified":1494671598000},{"_id":"source/categories/index.md","hash":"cc105c6a1ee5f2671437a33e0efc89a0bf27873b","modified":1488164352000},{"_id":"source/images/.DS_Store","hash":"a46d44a4bb3b22b56961a8331aa8eb42140697a9","modified":1493373147000},{"_id":"source/images/基本框架.png","hash":"2b70b797045ebbe513c3fac6b6951972c9ea1471","modified":1489288065000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1488120894000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1488120894000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1488119636000},{"_id":"themes/next/.git/index","hash":"2f4f67b3a8df748c8fd998d28c1ac804937b5d2b","modified":1500953815000},{"_id":"themes/next/.git/packed-refs","hash":"d05f26c3202fade741a32e36554b9b6cd4422234","modified":1488120894000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1488120894000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1488120894000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1488120894000},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1488120894000},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1488120894000},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1488120894000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1488120894000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1488120894000},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1488120894000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1488120894000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1488120894000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1488120894000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1488120894000},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1488120894000},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1488120894000},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1488120894000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1488120894000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1488120894000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1488120894000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1488120894000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1488120894000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1488120894000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1488120894000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1488120894000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1488120895000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1488120895000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1488120895000},{"_id":"source/images/alipay.png","hash":"6e3340446c90eda508a87a5b5f03081bd7940179","modified":1488338416000},{"_id":"source/images/avatar.png","hash":"c93a9c43644aa248ab44719e72b074fac468e9b1","modified":1488338247000},{"_id":"source/images/runtime.png","hash":"683b94dc31a2e8b64bf964870bd8a0ac0cee7a72","modified":1491556757000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"source/_posts/css/css之columns.md","hash":"7f7764ae9b8cd68bbe8cdf29f6d49e4aea047d01","modified":1488192555000},{"_id":"source/_posts/css/.DS_Store","hash":"be63be12ce0f39d5b27ec299b85766c4990826d1","modified":1490240898000},{"_id":"source/_posts/css/布局方案.md","hash":"79d97449f980b6e408283864b28955c05981b694","modified":1492160959000},{"_id":"source/_posts/css/移动端多行样式注意事项.md","hash":"a74b0bf5aafa7fca74a94ec619d761f9a18f238f","modified":1490241695000},{"_id":"source/_posts/database/数据库连接池原理.md","hash":"996c0725550eff008886a7b6748e4cd6484f082f","modified":1506414910000},{"_id":"source/_posts/internet/http基础.md","hash":"cda20029983da2084589a197040936facf8a9d1d","modified":1493289678000},{"_id":"source/_posts/internet/网络协议.md","hash":"32e9489c1d27b4792592d7b1687602a0e9e0f960","modified":1493289670000},{"_id":"source/_posts/js/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1494671593000},{"_id":"source/_posts/node/JWT.md","hash":"3fb2a0d2df56f88247ead3138b3922aa5ccc2ae5","modified":1506414910000},{"_id":"source/_posts/node/.DS_Store","hash":"e6c72fa3f107f0cfc3be2b5b57589f53156a76c3","modified":1488347212000},{"_id":"source/_posts/node/UMD规范.md","hash":"47106b3f4b2a55a4d51dcf20b3de752e0b2f9403","modified":1489572044000},{"_id":"source/_posts/node/buffer.md","hash":"df8721a8873651fcbcc5fd8d1f6942aa1604855c","modified":1505386439000},{"_id":"source/_posts/node/process.md","hash":"02d769537d45a2bcb0dcc0bd1ff89417e5e86697","modified":1488703519000},{"_id":"source/_posts/node/node做中间层的好处.md","hash":"4261842eee0374ffcd2be51ceef0d52e2c4a42a4","modified":1500953893000},{"_id":"source/_posts/node/promise、co、gennerator、async深入理解.md","hash":"80db5866b171d347985f0a5ea73664de9e36e925","modified":1491537412000},{"_id":"source/_posts/node/stream接口.md","hash":"ae79123bb11ed510b3b4ab8c47df4ebaadf039ce","modified":1488443716000},{"_id":"source/_posts/node/内存指标.md","hash":"0ca577a1c2e04f6a81254effa526ff202ca036cd","modified":1500950491000},{"_id":"source/_posts/node/内存控制.md","hash":"043bb5dd987e519fce4dc2af3837db344a9d548f","modified":1500950491000},{"_id":"source/_posts/node/内存泄漏.md","hash":"450578c7ba9e949eb163d5886ae7feef17a8180e","modified":1506414910000},{"_id":"source/_posts/node/异步:同步vs阻塞:非阻塞.md","hash":"5ed7872f200af942caed43dfa702147eaad231d9","modified":1500251771000},{"_id":"source/_posts/node/异步并发控制.md","hash":"155f7d71f9a7b725f8d4c2179fca4e3eaaec4ad3","modified":1500950491000},{"_id":"source/_posts/node/异步编程解决方案.md","hash":"282c5d11869767b3c3b60328efd1a975cef6a038","modified":1500950491000},{"_id":"source/_posts/node/构建web应用.md","hash":"b10d56fa4d71af7e5af06399d7b3396eb51209cb","modified":1505386439000},{"_id":"source/_posts/node/模块机制.md","hash":"78d3139edc137f68cbc7a5b2e39b3a55c47785b8","modified":1488601300000},{"_id":"source/_posts/node/网络编程.md","hash":"3ee0f6542778ae5cfd8426ffe0c7af4cef6b6d0f","modified":1505386439000},{"_id":"source/_posts/node/进程和线程的关系.md","hash":"5609cf5ce5f4d23674a10f6d66acc2ec7dd05a96","modified":1505388933000},{"_id":"source/_posts/node/进程.md","hash":"2bffebed7ae887b384582a0d813fddb5df14234f","modified":1505386439000},{"_id":"source/_posts/node/高效利用内存.md","hash":"d1e3e56978fc1307b2448aaf35227b8122c85fda","modified":1500950491000},{"_id":"source/_posts/structures/二叉树遍历.md","hash":"4a3db356ea005e75cdbbff6a9df9c65e47364cd7","modified":1488174885000},{"_id":"source/_posts/structures/常用排序算法的比较.md","hash":"3f112d7d6f9680b6a31288f785fa58f70579d28e","modified":1491493750000},{"_id":"source/_posts/structures/.DS_Store","hash":"cb56f00c41f48e1a4f4f33de4a75f042bb305cfd","modified":1488288909000},{"_id":"source/_posts/other/linux部署.md","hash":"344d9a7f2f7ddb41611c8449158a1e8d1675e04a","modified":1506414910000},{"_id":"source/_posts/utils/chrome-inspector.md","hash":"1b4e8cc208c7c9c08330a37453a75fa5d2251aee","modified":1488866050000},{"_id":"source/_posts/utils/redis.md","hash":"c596edc7af443d170b86ad7987d57713c12b7b11","modified":1506414879000},{"_id":"source/_posts/utils/git-rebase.md","hash":"7babc3f4ae837bcf6219e25eed7a03245849b03e","modified":1488336696000},{"_id":"source/_posts/utils/resume.md","hash":"6fe69ca5ec974f3b0e88cfee08bc0633e09d6eba","modified":1491012497000},{"_id":"source/_posts/utils/好用的npm包.md","hash":"e36f320b66551d8dd4a93bbad8c1bd5c86e23c9f","modified":1493606475000},{"_id":"source/_posts/utils/webpack2进阶.md","hash":"7cb796a593998d02021e62a03ae62f40277a185d","modified":1489648470000},{"_id":"source/_posts/utils/webpack2.md","hash":"c23c21dc867529bc6f070a834d905494aa996f5e","modified":1489641926000},{"_id":"source/images/bf.png","hash":"6ca042b6c6d64ac75dfa651e91349df566572122","modified":1491556736000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1488119636000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1488119636000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1488119636000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1488119636000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1488119636000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1488119636000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1488119636000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1488119636000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1488119636000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1488119636000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1488119636000},{"_id":"themes/next/.git/logs/HEAD","hash":"427a281cd80fbfbff82de1918424e22634c5d5d3","modified":1488120894000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1488120894000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1488120894000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1488120894000},{"_id":"themes/next/layout/_macro/post.swig","hash":"2c2efe44ea013030f3ce5da7bfdeddb74489eb6e","modified":1488120894000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1488120894000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1488120894000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1488120894000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1488120894000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1488120894000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1488120894000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1488120894000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1488120894000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1488120894000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1488120894000},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1488120894000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1488120894000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1488120894000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1488120894000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1488120894000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1488120894000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1488120894000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1488120894000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1488120894000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1488120894000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1488120894000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1488120894000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1488120894000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1488120894000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1488120894000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1488120894000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1488120894000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1488120894000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1488120894000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1488120894000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1488120894000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1488120894000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1488120894000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1488120894000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1488120894000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1488120894000},{"_id":"source/images/cache.png","hash":"8c34b09a870df8fc6d59fe87ec0ab510341e50fe","modified":1493174892000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1488120894000},{"_id":"source/_posts/js/es6/ES6之静态和私有.md","hash":"e51c3f9cce184131731cf0a4c3159aaa01305167","modified":1501468008000},{"_id":"source/_posts/js/es6/.DS_Store","hash":"fc87b1be71a43a45d0d771545bcd8d8c0942da5f","modified":1492945217000},{"_id":"source/_posts/js/es6/ES6的不应忽视的问题.md","hash":"8e39e834ed1416d35b3753d9cd36c7fbffb95ae4","modified":1492944691000},{"_id":"source/_posts/js/es6/Reflect.md","hash":"8d428c3deb1aefa5d3fa810af3a331020e102a9b","modified":1493275899000},{"_id":"source/_posts/js/es6/面试题.md","hash":"b72a14372cd2bc232616d436a492af5888ed2b1b","modified":1506939698000},{"_id":"source/_posts/js/es6/for..of.md","hash":"1f1ec9e5eb0ae1d2fa4075e457db2dcfe3634ae3","modified":1492944698000},{"_id":"source/_posts/js/designPattern/单一设计原则.md","hash":"0a457bdd81a2d7a6ed6616ec57958902606719e3","modified":1492945583000},{"_id":"source/_posts/js/es6/Symbol.md","hash":"46f52872951dab8d7d0f7ca687cc3b88af5f3344","modified":1492944707000},{"_id":"source/_posts/js/es6/promise.md","hash":"c02aec5c8f4696b2257fa96750811aa2538685ac","modified":1492574523000},{"_id":"source/_posts/js/designPattern/常用设计模式.md","hash":"f88f6d8697ba343e09e8a3adbed41147abdc8b64","modified":1492945578000},{"_id":"source/_posts/js/designPattern/.DS_Store","hash":"1da3fc7ccb4c7eeec23ce59ca89c4bdb4c275f5d","modified":1492945096000},{"_id":"source/_posts/js/designPattern/混合对象‘类’.md","hash":"4a288748c74bf83a23c58d2e15f3ae2a939c9976","modified":1492945573000},{"_id":"source/_posts/js/foundation/DOM事件机制.md","hash":"a74f45cc7154c4bd765e346073c6678d34165531","modified":1493190777000},{"_id":"source/_posts/js/foundation/JavaScript的函数队列.md","hash":"cb65c79191b9a0991449a1f0521630f55f6a79c0","modified":1492945819000},{"_id":"source/_posts/js/foundation/bind函数的深入实现.md","hash":"d72ad8725710d28e6fbb2512219686301b648a65","modified":1492945809000},{"_id":"source/_posts/js/foundation/Javascript动画实现原理.md","hash":"024c964139fd10381b67cfb71816147f6b89c9af","modified":1492945815000},{"_id":"source/_posts/js/foundation/.DS_Store","hash":"bf52a2de187efedad3c7480ca2e1e942fd0003e9","modified":1492995779000},{"_id":"source/_posts/js/foundation/js与浏览器.md","hash":"359edab23d34944dbb2154e2eafc20fff0c20f52","modified":1492945823000},{"_id":"source/_posts/js/foundation/js浮点数问题.md","hash":"5b62737e9702a5082e073621c85816544e4d70ef","modified":1492945826000},{"_id":"source/_posts/js/foundation/object变成类数组对象.md","hash":"349d78006093807fe9c378967a309f02dcd88928","modified":1492991254000},{"_id":"source/_posts/js/foundation/this隐式丢失.md","hash":"f7c4b5d4a7c795856b93aa672f45a7da9638b267","modified":1492945837000},{"_id":"source/_posts/js/foundation/代码优化之道.md","hash":"589d36805f23045b79abda702df44ac5b263c170","modified":1492945738000},{"_id":"source/_posts/js/foundation/传递引用非引用传递.md","hash":"a9152a9c597bb35f5185c4cb0880c72fc4ff11c3","modified":1492945745000},{"_id":"source/_posts/js/foundation/函数.md","hash":"efde33c9d2ef5d17222a2a16e5e0bdd66c60a9d7","modified":1492945752000},{"_id":"source/_posts/js/foundation/单页路由的实现.md","hash":"24332bf47ff5528b01cf278ec8995743e712080d","modified":1492945756000},{"_id":"source/_posts/js/foundation/如何写组件.md","hash":"261a648a2d5d0648e0327b08767d513daf96c6cf","modified":1494672385000},{"_id":"source/_posts/js/foundation/文档流.md","hash":"13a1f45c8f1544d0d304381997cf9df0c90be4ff","modified":1492945762000},{"_id":"source/_posts/js/foundation/柯里化.md","hash":"892d0fb784ef4f3bcf9125407745d45b7b84bdc7","modified":1492945764000},{"_id":"source/_posts/js/foundation/浏览器内核(渲染引擎，js引擎).md","hash":"9b370b50c0a48e1084dd8db9d1e3a1eb19be77d1","modified":1492945771000},{"_id":"source/_posts/js/foundation/浅析深浅拷贝.md","hash":"0bdfbad3384b118d8d9da8d10fec5554d4f40f0e","modified":1492945767000},{"_id":"source/_posts/js/foundation/浏览器的工作原理.md","hash":"16f1fc26d78e19158095677478883a133399ce3d","modified":1492945777000},{"_id":"source/_posts/js/foundation/深入JS原型.md","hash":"3ac653a629db9cb2f8f8ba74cfcee3818511a098","modified":1492945783000},{"_id":"source/_posts/js/foundation/深入理解数组去重.md","hash":"f921fd5fab7e4a0b6db59d35dca269dc4fd04334","modified":1492945780000},{"_id":"source/_posts/js/foundation/现代模块化机制.md","hash":"3bec10339a3057335b4185dfc6c349db2e5162ef","modified":1492945796000},{"_id":"source/_posts/js/foundation/自定义事件.md","hash":"dfe2f91534833b09b308a4669efcaf51224f3f7c","modified":1492945802000},{"_id":"source/_posts/js/foundation/跨域请求.md","hash":"368acbc13aa7f559fe339c84828b55d811362e86","modified":1492945806000},{"_id":"source/_posts/js/mobile/event.md","hash":"e41b47b41911a851a325c8d21de11171386797de","modified":1492987995000},{"_id":"source/_posts/js/mobile/h5坑总结.md","hash":"44a5906d14a0283ffd06389e1f92e2f3a208ab6d","modified":1492988000000},{"_id":"source/_posts/js/mobile/基本框架的搭建.md","hash":"a6515b1601b140a61522c64a0e1e8f4c3b9ad22c","modified":1492987985000},{"_id":"source/_posts/js/mobile/.DS_Store","hash":"9d799564533b2c7ac7e2985bc0dc4a7305989a11","modified":1492995807000},{"_id":"source/_posts/js/mobile/移动端适配方案.md","hash":"a0f85ea71208e52d37a2201625d9faddf4cc8130","modified":1506330071000},{"_id":"source/_posts/js/mobile/hybridApp踩坑之旅.md","hash":"85786e3e66001d87893e99bf32d31d0d53c0856d","modified":1502429233000},{"_id":"source/_posts/js/vue/vue初体验.md","hash":"8ff9c75021b7d21902d677ec6a81b8e17095f7ab","modified":1501468008000},{"_id":"source/_posts/js/vue/Vue之数据双向绑定浅析.md","hash":"a7044ece78d2f0d91386279278a47d7604a253be","modified":1493275755000},{"_id":"source/_posts/js/regExp/JS正则常用方法.md","hash":"92b10f8d7183412635c6a1b5f5553daea9634de6","modified":1492945316000},{"_id":"source/_posts/js/regExp/.DS_Store","hash":"86511849b92f07bdfe7b7ffb345cadc7c1016d2b","modified":1492945051000},{"_id":"source/_posts/js/vue/vue插件的写法.md","hash":"f254bae5a8e2ef5d428b1122eb6cd1e57c6a3d3e","modified":1492945497000},{"_id":"source/_posts/js/vue/vue组件的生命周期.md","hash":"213fad01e1adbd4db2388afc90d024c7903edbf9","modified":1492945503000},{"_id":"source/_posts/js/vue/.DS_Store","hash":"3e79fb0731d468c72ad46aa1d0d07e06ccd11963","modified":1492944995000},{"_id":"source/images/userCache.png","hash":"ece6652f6cd3d53360db81bddedc7cbd6f5e0742","modified":1493178143000},{"_id":"themes/next/.git/refs/heads/master","hash":"27a9366b738d13d91bd795b01f0db1df7e8ce5d7","modified":1488120894000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1488120894000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1488120894000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1488120894000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1488120894000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1488120894000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1488120894000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1488120894000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1488120894000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1488120894000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1488120894000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1488120894000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1488120894000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1488120894000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1488120894000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1488120894000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1488120894000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1488120894000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1488120894000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"3c8dcf93db666ac6f9f8955b5d36a9419430862a","modified":1488120894000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1488120894000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1488120894000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1488120894000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1488120894000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1488120894000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1488120894000},{"_id":"themes/next/source/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1488120894000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1488120894000},{"_id":"themes/next/source/js/src/post-details.js","hash":"661806a916fa46566accb3222da1fb790decb725","modified":1488120894000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1488120894000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1488120895000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1488120895000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1488120895000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1488120895000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1488120895000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1488120895000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1488120895000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1488120895000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1488120895000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1488120895000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1488120895000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1488120895000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1488120895000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1488120895000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1488120895000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1488120895000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1488120895000},{"_id":"source/images/port.png","hash":"2e8146fc17b70439d6fe68340c204172e9fb9afb","modified":1493288830000},{"_id":"source/images/xieyi.png","hash":"5bc32f2a05064b4d9689975496a79e8781a45944","modified":1493287979000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1488120895000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"427a281cd80fbfbff82de1918424e22634c5d5d3","modified":1488120894000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1488120894000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"7e18f08c2c82f71e83860f232d43d8b89865ac2e","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1488120894000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1488120894000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1488120894000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1488120894000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1488120894000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1488120894000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1488120894000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1488120894000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1488120895000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1488120895000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1488120895000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1488120895000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1488120895000},{"_id":"themes/next/.git/objects/pack/pack-441108cf8c03fb6bf31bbe7fa959d18f11aa6977.idx","hash":"34796711763f05745f3341e777e92ee0fac86dd7","modified":1488120894000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1488120895000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1488120895000},{"_id":"source/images/trangle.png","hash":"4d5f2cb8823ed7a83431dbec72163b057946abd6","modified":1493178320000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"427a281cd80fbfbff82de1918424e22634c5d5d3","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"72bb1c9c890a1dfeca7804d681b366fea0ac4421","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1488120894000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1488120894000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1488120894000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1488120895000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1488120895000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1488120895000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1488120895000},{"_id":"source/images/dns.png","hash":"439599b5f8b8013a3bab90f0e3967b3552bfd47e","modified":1493288764000},{"_id":"source/images/wechatpay.png","hash":"4376ec8a10070b486b3b052b6d57885973a04344","modified":1488276796000},{"_id":"themes/next/.git/objects/pack/pack-441108cf8c03fb6bf31bbe7fa959d18f11aa6977.pack","hash":"53ca490bb39d443cf6341e17072eb21eb96a3897","modified":1488120894000}],"Category":[{"name":"前端","_id":"cj8a11cbo0003kzy6s44adscv"},{"name":"数据库","_id":"cj8a11cci000dkzy6fgdqosi4"},{"name":"CSS","parent":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11ccm000gkzy68rumpzaq"},{"name":"Internet","_id":"cj8a11cco000kkzy6txzssh9c"},{"name":"后端","_id":"cj8a11ccv000xkzy6q8ci30w2"},{"name":"数据结构和算法","_id":"cj8a11cdv002ekzy65p165twt"},{"name":"其他","_id":"cj8a11cdw002ikzy6j55gkzcr"},{"name":"工具","_id":"cj8a11cdx002kkzy6xl8b737c"},{"name":"JS","parent":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cgs0032kzy6djrqjyd1"},{"name":"ES6","parent":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cgz003bkzy6tt5yyhv5"},{"name":"设计模式","parent":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cha003nkzy6k3836k56"},{"name":"基本概念","parent":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11ci0004mkzy6ftz84wnk"},{"name":"H5","parent":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11ciy006lkzy6q92ynr3e"},{"name":"Vue","parent":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj30070kzy6mju0ia4s"},{"name":"regExp","parent":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj40074kzy6xk26v4nb"}],"Data":[],"Page":[{"title":"分类","date":"2017-02-26T17:10:07.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-02-27 01:10:07\ntype: \"categories\"\n---\n","updated":"2017-02-27T02:59:12.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj8a11c8x0000kzy690nd86hv","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"columns","type":"categories","_content":"\n#### column-width 列的宽度\n### column-count 列的栏数\n### column-gap 列的间距\n### column-rule 列间距（宽度，样式，颜色)\n### column-span: none || all 元素跨所有列\n\n### 总结： 做出上三，中一，下三的效果","source":"_posts/css/css之columns.md","raw":"\n---\ntitle: columns\ntype: \"categories\"\ncategories: [前端, CSS]\n---\n\n#### column-width 列的宽度\n### column-count 列的栏数\n### column-gap 列的间距\n### column-rule 列间距（宽度，样式，颜色)\n### column-span: none || all 元素跨所有列\n\n### 总结： 做出上三，中一，下三的效果","slug":"css-css之columns","published":1,"date":"2017-02-27T10:49:15.000Z","updated":"2017-02-27T10:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cbc0001kzy6bxso4rik","content":"<h4 id=\"column-width-列的宽度\"><a href=\"#column-width-列的宽度\" class=\"headerlink\" title=\"column-width 列的宽度\"></a>column-width 列的宽度</h4><h3 id=\"column-count-列的栏数\"><a href=\"#column-count-列的栏数\" class=\"headerlink\" title=\"column-count 列的栏数\"></a>column-count 列的栏数</h3><h3 id=\"column-gap-列的间距\"><a href=\"#column-gap-列的间距\" class=\"headerlink\" title=\"column-gap 列的间距\"></a>column-gap 列的间距</h3><h3 id=\"column-rule-列间距（宽度，样式，颜色\"><a href=\"#column-rule-列间距（宽度，样式，颜色\" class=\"headerlink\" title=\"column-rule 列间距（宽度，样式，颜色)\"></a>column-rule 列间距（宽度，样式，颜色)</h3><h3 id=\"column-span-none-all-元素跨所有列\"><a href=\"#column-span-none-all-元素跨所有列\" class=\"headerlink\" title=\"column-span: none || all 元素跨所有列\"></a>column-span: none || all 元素跨所有列</h3><h3 id=\"总结：-做出上三，中一，下三的效果\"><a href=\"#总结：-做出上三，中一，下三的效果\" class=\"headerlink\" title=\"总结： 做出上三，中一，下三的效果\"></a>总结： 做出上三，中一，下三的效果</h3>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"column-width-列的宽度\"><a href=\"#column-width-列的宽度\" class=\"headerlink\" title=\"column-width 列的宽度\"></a>column-width 列的宽度</h4><h3 id=\"column-count-列的栏数\"><a href=\"#column-count-列的栏数\" class=\"headerlink\" title=\"column-count 列的栏数\"></a>column-count 列的栏数</h3><h3 id=\"column-gap-列的间距\"><a href=\"#column-gap-列的间距\" class=\"headerlink\" title=\"column-gap 列的间距\"></a>column-gap 列的间距</h3><h3 id=\"column-rule-列间距（宽度，样式，颜色\"><a href=\"#column-rule-列间距（宽度，样式，颜色\" class=\"headerlink\" title=\"column-rule 列间距（宽度，样式，颜色)\"></a>column-rule 列间距（宽度，样式，颜色)</h3><h3 id=\"column-span-none-all-元素跨所有列\"><a href=\"#column-span-none-all-元素跨所有列\" class=\"headerlink\" title=\"column-span: none || all 元素跨所有列\"></a>column-span: none || all 元素跨所有列</h3><h3 id=\"总结：-做出上三，中一，下三的效果\"><a href=\"#总结：-做出上三，中一，下三的效果\" class=\"headerlink\" title=\"总结： 做出上三，中一，下三的效果\"></a>总结： 做出上三，中一，下三的效果</h3>"},{"title":"布局方案","type":"categories","_content":"\n## 两列布局\n左边定宽 + 右边自适应\n\n```\n<div class=\"parent\">\n    <div class=\"left\"><p>left</p></div>\n    <div class=\"right-fix\">\n        <div class=\"right\">\n            <p>right</p><p>right</p>\n        </div>\n    </div>\n</div>\n\n\n.left{\n    float: left;     //向左浮动\n    width: 100px;    //固定宽度\n    position: relative;//由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。\n}\n.right-fix{\n    float: right;     //向右浮动\n    width: 100%;    //为了自适应设为100%\n    margin-left: -100px;//由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）\n}\n.right{\n    margin-left: 120px;    //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。\n}\n```\n","source":"_posts/css/布局方案.md","raw":"---\ntitle: 布局方案\ntype: \"categories\"\ncategories: [前端, CSS]\n---\n\n## 两列布局\n左边定宽 + 右边自适应\n\n```\n<div class=\"parent\">\n    <div class=\"left\"><p>left</p></div>\n    <div class=\"right-fix\">\n        <div class=\"right\">\n            <p>right</p><p>right</p>\n        </div>\n    </div>\n</div>\n\n\n.left{\n    float: left;     //向左浮动\n    width: 100px;    //固定宽度\n    position: relative;//由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。\n}\n.right-fix{\n    float: right;     //向右浮动\n    width: 100%;    //为了自适应设为100%\n    margin-left: -100px;//由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）\n}\n.right{\n    margin-left: 120px;    //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。\n}\n```\n","slug":"css-布局方案","published":1,"date":"2017-04-14T09:09:19.000Z","updated":"2017-04-14T09:09:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cbl0002kzy6jd701e45","content":"<h2 id=\"两列布局\"><a href=\"#两列布局\" class=\"headerlink\" title=\"两列布局\"></a>两列布局</h2><p>左边定宽 + 右边自适应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;parent&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;left&quot;&gt;&lt;p&gt;left&lt;/p&gt;&lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;right-fix&quot;&gt;</div><div class=\"line\">        &lt;div class=&quot;right&quot;&gt;</div><div class=\"line\">            &lt;p&gt;right&lt;/p&gt;&lt;p&gt;right&lt;/p&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">.left&#123;</div><div class=\"line\">    float: left;     //向左浮动</div><div class=\"line\">    width: 100px;    //固定宽度</div><div class=\"line\">    position: relative;//由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。</div><div class=\"line\">&#125;</div><div class=\"line\">.right-fix&#123;</div><div class=\"line\">    float: right;     //向右浮动</div><div class=\"line\">    width: 100%;    //为了自适应设为100%</div><div class=\"line\">    margin-left: -100px;//由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）</div><div class=\"line\">&#125;</div><div class=\"line\">.right&#123;</div><div class=\"line\">    margin-left: 120px;    //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"两列布局\"><a href=\"#两列布局\" class=\"headerlink\" title=\"两列布局\"></a>两列布局</h2><p>左边定宽 + 右边自适应</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div class=&quot;parent&quot;&gt;</div><div class=\"line\">    &lt;div class=&quot;left&quot;&gt;&lt;p&gt;left&lt;/p&gt;&lt;/div&gt;</div><div class=\"line\">    &lt;div class=&quot;right-fix&quot;&gt;</div><div class=\"line\">        &lt;div class=&quot;right&quot;&gt;</div><div class=\"line\">            &lt;p&gt;right&lt;/p&gt;&lt;p&gt;right&lt;/p&gt;</div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    &lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">.left&#123;</div><div class=\"line\">    float: left;     //向左浮动</div><div class=\"line\">    width: 100px;    //固定宽度</div><div class=\"line\">    position: relative;//由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。</div><div class=\"line\">&#125;</div><div class=\"line\">.right-fix&#123;</div><div class=\"line\">    float: right;     //向右浮动</div><div class=\"line\">    width: 100%;    //为了自适应设为100%</div><div class=\"line\">    margin-left: -100px;//由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）</div><div class=\"line\">&#125;</div><div class=\"line\">.right&#123;</div><div class=\"line\">    margin-left: 120px;    //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"移动端多行样式注意事项","type":"categories","_content":"## 单行缩略\n```\noverflow: hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\n```\n\nWebKit内核的浏览器实现起来比较简单，可以通过添加一个-webkit-line-clamp的私有属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本的行数。 为了实现这个效果，它需要组合其他的WebKit属性：\n\ndisplay: -webkit-box 将对象作为弹性伸缩盒子模型显示；\n-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式；\ntext-overflow: ellipsis 用省略号“…”隐藏超出范围的文本。\n\n```\noverflow : hidden;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-line-clamp: 2;\n-webkit-box-orient: vertical;\n\n```\n\n**注意的地方来了**\nword-break: break-all;\n如果没加上面这个属性，有可能还没到两行就显示省略号了，因为浏览器会按照一个单词的解析机制来解析，如果你末尾全是111111111，或者wwwddfdfddf这种，浏览器会按照一个单词处理，但是如果加上这个单词，超出了两行就会提前换行了，朋友们，明白了吗...\n\n## 其他浏览器方案\n用相对定位的方案，配合伪类、行高、高、overflow和绝对定位，然后在最后面加上...即可\n```\np {\n    position:relative;\n    line-height:1.5em;\n    height:3em;\n    overflow:hidden;\n}\np:after {\n    content:\"...\";\n    position:absolute;\n    bottom:0;\n    right:0;\n    padding: 0 5px;\n    background-color: #fff;\n}\n```","source":"_posts/css/移动端多行样式注意事项.md","raw":"\n---\ntitle: 移动端多行样式注意事项\ntype: \"categories\"\ncategories: [前端, CSS]\n---\n## 单行缩略\n```\noverflow: hidden;\ntext-overflow: ellipsis;\nwhite-space: nowrap;\n```\n\nWebKit内核的浏览器实现起来比较简单，可以通过添加一个-webkit-line-clamp的私有属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本的行数。 为了实现这个效果，它需要组合其他的WebKit属性：\n\ndisplay: -webkit-box 将对象作为弹性伸缩盒子模型显示；\n-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式；\ntext-overflow: ellipsis 用省略号“…”隐藏超出范围的文本。\n\n```\noverflow : hidden;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-line-clamp: 2;\n-webkit-box-orient: vertical;\n\n```\n\n**注意的地方来了**\nword-break: break-all;\n如果没加上面这个属性，有可能还没到两行就显示省略号了，因为浏览器会按照一个单词的解析机制来解析，如果你末尾全是111111111，或者wwwddfdfddf这种，浏览器会按照一个单词处理，但是如果加上这个单词，超出了两行就会提前换行了，朋友们，明白了吗...\n\n## 其他浏览器方案\n用相对定位的方案，配合伪类、行高、高、overflow和绝对定位，然后在最后面加上...即可\n```\np {\n    position:relative;\n    line-height:1.5em;\n    height:3em;\n    overflow:hidden;\n}\np:after {\n    content:\"...\";\n    position:absolute;\n    bottom:0;\n    right:0;\n    padding: 0 5px;\n    background-color: #fff;\n}\n```","slug":"css-移动端多行样式注意事项","published":1,"date":"2017-03-23T04:01:35.000Z","updated":"2017-03-23T04:01:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cbq0004kzy6u0usiuji","content":"<h2 id=\"单行缩略\"><a href=\"#单行缩略\" class=\"headerlink\" title=\"单行缩略\"></a>单行缩略</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">overflow: hidden;</div><div class=\"line\">text-overflow: ellipsis;</div><div class=\"line\">white-space: nowrap;</div></pre></td></tr></table></figure>\n<p>WebKit内核的浏览器实现起来比较简单，可以通过添加一个-webkit-line-clamp的私有属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本的行数。 为了实现这个效果，它需要组合其他的WebKit属性：</p>\n<p>display: -webkit-box 将对象作为弹性伸缩盒子模型显示；<br>-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式；<br>text-overflow: ellipsis 用省略号“…”隐藏超出范围的文本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">overflow : hidden;</div><div class=\"line\">text-overflow: ellipsis;</div><div class=\"line\">display: -webkit-box;</div><div class=\"line\">-webkit-line-clamp: 2;</div><div class=\"line\">-webkit-box-orient: vertical;</div></pre></td></tr></table></figure>\n<p><strong>注意的地方来了</strong><br>word-break: break-all;<br>如果没加上面这个属性，有可能还没到两行就显示省略号了，因为浏览器会按照一个单词的解析机制来解析，如果你末尾全是111111111，或者wwwddfdfddf这种，浏览器会按照一个单词处理，但是如果加上这个单词，超出了两行就会提前换行了，朋友们，明白了吗…</p>\n<h2 id=\"其他浏览器方案\"><a href=\"#其他浏览器方案\" class=\"headerlink\" title=\"其他浏览器方案\"></a>其他浏览器方案</h2><p>用相对定位的方案，配合伪类、行高、高、overflow和绝对定位，然后在最后面加上…即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    position:relative;</div><div class=\"line\">    line-height:1.5em;</div><div class=\"line\">    height:3em;</div><div class=\"line\">    overflow:hidden;</div><div class=\"line\">&#125;</div><div class=\"line\">p:after &#123;</div><div class=\"line\">    content:&quot;...&quot;;</div><div class=\"line\">    position:absolute;</div><div class=\"line\">    bottom:0;</div><div class=\"line\">    right:0;</div><div class=\"line\">    padding: 0 5px;</div><div class=\"line\">    background-color: #fff;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单行缩略\"><a href=\"#单行缩略\" class=\"headerlink\" title=\"单行缩略\"></a>单行缩略</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">overflow: hidden;</div><div class=\"line\">text-overflow: ellipsis;</div><div class=\"line\">white-space: nowrap;</div></pre></td></tr></table></figure>\n<p>WebKit内核的浏览器实现起来比较简单，可以通过添加一个-webkit-line-clamp的私有属性来实现，-webkit-line-clamp是用来限制在一个块元素显示的文本的行数。 为了实现这个效果，它需要组合其他的WebKit属性：</p>\n<p>display: -webkit-box 将对象作为弹性伸缩盒子模型显示；<br>-webkit-box-orient 设置或检索伸缩盒对象的子元素的排列方式；<br>text-overflow: ellipsis 用省略号“…”隐藏超出范围的文本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">overflow : hidden;</div><div class=\"line\">text-overflow: ellipsis;</div><div class=\"line\">display: -webkit-box;</div><div class=\"line\">-webkit-line-clamp: 2;</div><div class=\"line\">-webkit-box-orient: vertical;</div></pre></td></tr></table></figure>\n<p><strong>注意的地方来了</strong><br>word-break: break-all;<br>如果没加上面这个属性，有可能还没到两行就显示省略号了，因为浏览器会按照一个单词的解析机制来解析，如果你末尾全是111111111，或者wwwddfdfddf这种，浏览器会按照一个单词处理，但是如果加上这个单词，超出了两行就会提前换行了，朋友们，明白了吗…</p>\n<h2 id=\"其他浏览器方案\"><a href=\"#其他浏览器方案\" class=\"headerlink\" title=\"其他浏览器方案\"></a>其他浏览器方案</h2><p>用相对定位的方案，配合伪类、行高、高、overflow和绝对定位，然后在最后面加上…即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">p &#123;</div><div class=\"line\">    position:relative;</div><div class=\"line\">    line-height:1.5em;</div><div class=\"line\">    height:3em;</div><div class=\"line\">    overflow:hidden;</div><div class=\"line\">&#125;</div><div class=\"line\">p:after &#123;</div><div class=\"line\">    content:&quot;...&quot;;</div><div class=\"line\">    position:absolute;</div><div class=\"line\">    bottom:0;</div><div class=\"line\">    right:0;</div><div class=\"line\">    padding: 0 5px;</div><div class=\"line\">    background-color: #fff;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"数据库连接池原理","type":"categories","_content":"\n# 原始的数据库操作\n- 初始化数据库连接\n- 创建连接\n- CURD操作\n- 关闭连接\n\n# 技术演进后的数据库连接池\n频繁的与数据库进行连接和释放，加大了内存吞吐的开销，于是数据库连接池技术应运而生\n- 预先在l连接池放入若干连接，当需要与数据库建立连接的时候，从缓存取出一个，使用完放回去，可以通过设定连接池最大连接数来防止系统无尽的与数据库连接\n\n# 连接池实现的关键问题\n## 并发\n由于 Node.js 是单线程的，所以这个问题并不会给我们造成多大的困扰\n## 多数据库服务器和多用户\n## 事务处理\n## 连接池的分配与释放\n## 连接池的配置与维护\n如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。\n\n[参考](https://aidandai.github.io/posts/the-principle-of-database-connection-pool.html#1-原始的数据库操作)","source":"_posts/database/数据库连接池原理.md","raw":"---\ntitle: 数据库连接池原理\ntype: \"categories\"\ncategories: 数据库\n---\n\n# 原始的数据库操作\n- 初始化数据库连接\n- 创建连接\n- CURD操作\n- 关闭连接\n\n# 技术演进后的数据库连接池\n频繁的与数据库进行连接和释放，加大了内存吞吐的开销，于是数据库连接池技术应运而生\n- 预先在l连接池放入若干连接，当需要与数据库建立连接的时候，从缓存取出一个，使用完放回去，可以通过设定连接池最大连接数来防止系统无尽的与数据库连接\n\n# 连接池实现的关键问题\n## 并发\n由于 Node.js 是单线程的，所以这个问题并不会给我们造成多大的困扰\n## 多数据库服务器和多用户\n## 事务处理\n## 连接池的分配与释放\n## 连接池的配置与维护\n如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。\n\n[参考](https://aidandai.github.io/posts/the-principle-of-database-connection-pool.html#1-原始的数据库操作)","slug":"database-数据库连接池原理","published":1,"date":"2017-09-26T08:35:10.000Z","updated":"2017-09-26T08:35:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cbs0005kzy6kb5oqd9h","content":"<h1 id=\"原始的数据库操作\"><a href=\"#原始的数据库操作\" class=\"headerlink\" title=\"原始的数据库操作\"></a>原始的数据库操作</h1><ul>\n<li>初始化数据库连接</li>\n<li>创建连接</li>\n<li>CURD操作</li>\n<li>关闭连接</li>\n</ul>\n<h1 id=\"技术演进后的数据库连接池\"><a href=\"#技术演进后的数据库连接池\" class=\"headerlink\" title=\"技术演进后的数据库连接池\"></a>技术演进后的数据库连接池</h1><p>频繁的与数据库进行连接和释放，加大了内存吞吐的开销，于是数据库连接池技术应运而生</p>\n<ul>\n<li>预先在l连接池放入若干连接，当需要与数据库建立连接的时候，从缓存取出一个，使用完放回去，可以通过设定连接池最大连接数来防止系统无尽的与数据库连接</li>\n</ul>\n<h1 id=\"连接池实现的关键问题\"><a href=\"#连接池实现的关键问题\" class=\"headerlink\" title=\"连接池实现的关键问题\"></a>连接池实现的关键问题</h1><h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><p>由于 Node.js 是单线程的，所以这个问题并不会给我们造成多大的困扰</p>\n<h2 id=\"多数据库服务器和多用户\"><a href=\"#多数据库服务器和多用户\" class=\"headerlink\" title=\"多数据库服务器和多用户\"></a>多数据库服务器和多用户</h2><h2 id=\"事务处理\"><a href=\"#事务处理\" class=\"headerlink\" title=\"事务处理\"></a>事务处理</h2><h2 id=\"连接池的分配与释放\"><a href=\"#连接池的分配与释放\" class=\"headerlink\" title=\"连接池的分配与释放\"></a>连接池的分配与释放</h2><h2 id=\"连接池的配置与维护\"><a href=\"#连接池的配置与维护\" class=\"headerlink\" title=\"连接池的配置与维护\"></a>连接池的配置与维护</h2><p>如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</p>\n<p><a href=\"https://aidandai.github.io/posts/the-principle-of-database-connection-pool.html#1-原始的数据库操作\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"原始的数据库操作\"><a href=\"#原始的数据库操作\" class=\"headerlink\" title=\"原始的数据库操作\"></a>原始的数据库操作</h1><ul>\n<li>初始化数据库连接</li>\n<li>创建连接</li>\n<li>CURD操作</li>\n<li>关闭连接</li>\n</ul>\n<h1 id=\"技术演进后的数据库连接池\"><a href=\"#技术演进后的数据库连接池\" class=\"headerlink\" title=\"技术演进后的数据库连接池\"></a>技术演进后的数据库连接池</h1><p>频繁的与数据库进行连接和释放，加大了内存吞吐的开销，于是数据库连接池技术应运而生</p>\n<ul>\n<li>预先在l连接池放入若干连接，当需要与数据库建立连接的时候，从缓存取出一个，使用完放回去，可以通过设定连接池最大连接数来防止系统无尽的与数据库连接</li>\n</ul>\n<h1 id=\"连接池实现的关键问题\"><a href=\"#连接池实现的关键问题\" class=\"headerlink\" title=\"连接池实现的关键问题\"></a>连接池实现的关键问题</h1><h2 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h2><p>由于 Node.js 是单线程的，所以这个问题并不会给我们造成多大的困扰</p>\n<h2 id=\"多数据库服务器和多用户\"><a href=\"#多数据库服务器和多用户\" class=\"headerlink\" title=\"多数据库服务器和多用户\"></a>多数据库服务器和多用户</h2><h2 id=\"事务处理\"><a href=\"#事务处理\" class=\"headerlink\" title=\"事务处理\"></a>事务处理</h2><h2 id=\"连接池的分配与释放\"><a href=\"#连接池的分配与释放\" class=\"headerlink\" title=\"连接池的分配与释放\"></a>连接池的分配与释放</h2><h2 id=\"连接池的配置与维护\"><a href=\"#连接池的配置与维护\" class=\"headerlink\" title=\"连接池的配置与维护\"></a>连接池的配置与维护</h2><p>如何确保连接池中的最小连接数呢？有动态和静态两种策略。动态即每隔一定时间就对连接池进行检测，如果发现连接数量小于最小连接数，则补充相应数量的新连接以保证连接池的正常运转。静态是发现空闲连接不够时再去检查。</p>\n<p><a href=\"https://aidandai.github.io/posts/the-principle-of-database-connection-pool.html#1-原始的数据库操作\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"http基础","type":"categories","_content":"\n## keep-alive模式\n\n为什么要开启keep-alive模式？\n> 避免下载客户端和服务器再次建立释放连接的开销\n> 单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用不超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。\n\n如何开启关闭keep-alive？\n> http1.0默认是关闭的，启用需要在头上加入：Connection: Keep-Alive\n> http1.1默认开启的，关闭：Connection: close\n> 大多数浏览器采用的是http1.1\n\nkeep-alive模式如何确定响应数据接收完毕，我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判定\n- Content-Length,表示实体内容的长度，客户端可以根据这个值来判断数据是否接收完成，但是如果没有这个字段呢\n- Transfer-Encoding,当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用\"Transfer-Encoding: chunked\"这样的方式来代替Content-Length。\nchunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0 的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字 ）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开\n- 两者都出现的时候，Transfer-Encoding优先级高\n\n## http头字段总结\n- Accept：告诉web服务器接收什么介质类型，‘/‘表示任何类型， type/* 表示该类型下的所有子类型，type/sub-type。\n- Accept-Charset： 浏览器声明自己接收的字符集\n- Accept-Ranges：表示服务器是否接收实体一部分（一部分）的请求，bytes：表示接收，none表示不接受\n- Age： 当代理服务器用自己缓存的实体去响应请求时候，表明该实体从产生到现在有多长时间\n- Content-Encoding：表明web服务器用什么了压缩方法（gzip,deflate)压缩响应的对象\n- Content-Language：web服务器告诉浏览器自己响应对象的语言\n- Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022\n- Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml\n- Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT\n- Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn\n- If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。\n- If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。\n- If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT\n- Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的\n- If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。\n- Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-\n-  Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/\n-  Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache\n- Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked\n\n## 浏览器的缓存机制\n如果是请求头带有Cache-Control:max-age=0代表强制返回最新文件\n如果是响应头中带有Cache-Control:max-age=0，则代表服务器要求浏览器你在使用本地缓存的时候，必须先和服务器进行一遍通信，将etag、 If-Not-Modified、If-None-Match、If-Modified-Since等字段传递给服务器以便验证当前浏览器端使用的文件是否是最新的,如果是最新的，服务端返回304，否则200，重新下载\n并且确认浏览器中Disable Cache勾上没\n\n<img src=\"/images/cache.png\">\n\n### 强制缓存\n#### Expires\n服务器返回一个**绝对时间**，然后与下次客户端请求的时间进行对比，如果未过期，直接从本地缓存获取，请求返回200（from Cache）\n- 缺点： 客户端的时间与服务器的时间相差很大（时钟不同步，跨时区的因素），所以误差大，所以在HTTP1.1版开始，使用Cache-Control: max-age=秒替代\n\n#### Cache-Control\n服务器返回的是一个**相对时间**，客户端两个间隔请求之差小于Cache-Control中设置的时间差，那么就从本地缓存中取，返回 200 （from Cache)\n\n#### 优先级\nCache-Control > Expires,Cache-Control的值可以是：\n\n- Public 指示响应可被任何缓存区缓存。\n- Private 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。\n- no-cache 指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认\n- no-store 在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。\n- max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）<客户端当前时间\n- min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n- max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\n### 协商缓存\n\nLast-Modified / If-Modified-Since ： 标识资源的最后修改时间(由服务器返回)， 配合Cache-Control使用\n#### If-Modified-Since**\n> 重复请求时，当强缓存失效，发现请求头中有Last-Modified声明，则添加If-Modified-Since，内容为当前请求时间，发送请求，服务器获取请求时间与资源最后修改时间对比：\n如果最后个性时间大于请求时间，则说明资源更新过，返回资源文件和状态200，\n如果请求时间大于最后修改时间，则说明资源未修改，返回状态304告知浏览器使用缓存\n\n**过程**\n1. 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header\n2. 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值是Last-Modified中的值\n3. 服务器再次收到这个资源请求，根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200\n\n缺点： \n- Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件）\n- 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）。\n\n所以Etag / If-None-Match出现了，配合Cache-Control使用\n\nEtag: 由服务器返回，内容为资源的唯一标识，生成规则由服务器决定。 Apache中，Etag的值为文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\nIf-None-Match\n> 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对：\n如果相同，则返回304\n如果不同，则返回200和资源文件\n\nEtag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。\n\n**优先级**\nEtag的优先级 大于 Last-Modified的\n\n**过程**\n1.客户端请求一个页面（A）。\n2.服务器返回页面A，并在给A加上一个ETag，值是这个资源的唯一标识，由服务器端生成。\n3.客户端展现该页面，并将页面连同ETag一起缓存。\n4.客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。\n5.服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。\n\n### 用户行为与缓存\n- 用户在地址栏回车、页面链接跳转、新开窗口、前进后退时，缓存是有效的\n- 用户点击F5的时候，Last-Modified/Etag是有效的，但是Expires、Cache-Control重置失效\n- ctrl+f5缓存全部失效\n\n<img src=\"/images/userCache.png\">\n\n### 常见状态码\n- 200：强缓Expires/Cache-Control存失效时，返回新的资源文件\n- 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304\n- 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功\n\n<img src=\"/images/trangle.png\">\n\n### 应用\n- 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。\n\n- 当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；\n\n- 而当用户使用Ctrl+F5进行强制刷新的时候，会跳过强缓存和协商缓存，重新从服务器下载资源。\n\n- 分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败\n分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)\n\n[参考](http://coderlt.coding.me/2016/11/21/web-cache/)\n\n## 攻击\n\n### CRSF（cross site request Forgery)跨站请求伪造\n登录网站A，生成本地Cookie信息；登录危险网站B，B获取网站A的内容，并向A发送请求操作，若成功，则CRSF过程成功。其中登录B网站，行为可以是点击网站A中的链接链接。 \n\n#### CSRF的防范\n1. 验证HTTP Referer字段\n2. 在请求地址中添加token并验证\n\n### XSS攻击（跨脚本攻击）Cross-site scripting\nXSS攻击基本原理——代码注入（html,sql)\n\n\n","source":"_posts/internet/http基础.md","raw":"---\ntitle: http基础\ntype: \"categories\"\ncategories: [Internet]\n---\n\n## keep-alive模式\n\n为什么要开启keep-alive模式？\n> 避免下载客户端和服务器再次建立释放连接的开销\n> 单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用不超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。\n\n如何开启关闭keep-alive？\n> http1.0默认是关闭的，启用需要在头上加入：Connection: Keep-Alive\n> http1.1默认开启的，关闭：Connection: close\n> 大多数浏览器采用的是http1.1\n\nkeep-alive模式如何确定响应数据接收完毕，我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判定\n- Content-Length,表示实体内容的长度，客户端可以根据这个值来判断数据是否接收完成，但是如果没有这个字段呢\n- Transfer-Encoding,当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用\"Transfer-Encoding: chunked\"这样的方式来代替Content-Length。\nchunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0 的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字 ）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开\n- 两者都出现的时候，Transfer-Encoding优先级高\n\n## http头字段总结\n- Accept：告诉web服务器接收什么介质类型，‘/‘表示任何类型， type/* 表示该类型下的所有子类型，type/sub-type。\n- Accept-Charset： 浏览器声明自己接收的字符集\n- Accept-Ranges：表示服务器是否接收实体一部分（一部分）的请求，bytes：表示接收，none表示不接受\n- Age： 当代理服务器用自己缓存的实体去响应请求时候，表明该实体从产生到现在有多长时间\n- Content-Encoding：表明web服务器用什么了压缩方法（gzip,deflate)压缩响应的对象\n- Content-Language：web服务器告诉浏览器自己响应对象的语言\n- Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022\n- Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml\n- Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT\n- Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn\n- If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。\n- If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。\n- If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT\n- Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的\n- If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。\n- Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-\n-  Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/\n-  Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache\n- Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked\n\n## 浏览器的缓存机制\n如果是请求头带有Cache-Control:max-age=0代表强制返回最新文件\n如果是响应头中带有Cache-Control:max-age=0，则代表服务器要求浏览器你在使用本地缓存的时候，必须先和服务器进行一遍通信，将etag、 If-Not-Modified、If-None-Match、If-Modified-Since等字段传递给服务器以便验证当前浏览器端使用的文件是否是最新的,如果是最新的，服务端返回304，否则200，重新下载\n并且确认浏览器中Disable Cache勾上没\n\n<img src=\"/images/cache.png\">\n\n### 强制缓存\n#### Expires\n服务器返回一个**绝对时间**，然后与下次客户端请求的时间进行对比，如果未过期，直接从本地缓存获取，请求返回200（from Cache）\n- 缺点： 客户端的时间与服务器的时间相差很大（时钟不同步，跨时区的因素），所以误差大，所以在HTTP1.1版开始，使用Cache-Control: max-age=秒替代\n\n#### Cache-Control\n服务器返回的是一个**相对时间**，客户端两个间隔请求之差小于Cache-Control中设置的时间差，那么就从本地缓存中取，返回 200 （from Cache)\n\n#### 优先级\nCache-Control > Expires,Cache-Control的值可以是：\n\n- Public 指示响应可被任何缓存区缓存。\n- Private 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。\n- no-cache 指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认\n- no-store 在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。\n- max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）<客户端当前时间\n- min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。\n- max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。\n\n### 协商缓存\n\nLast-Modified / If-Modified-Since ： 标识资源的最后修改时间(由服务器返回)， 配合Cache-Control使用\n#### If-Modified-Since**\n> 重复请求时，当强缓存失效，发现请求头中有Last-Modified声明，则添加If-Modified-Since，内容为当前请求时间，发送请求，服务器获取请求时间与资源最后修改时间对比：\n如果最后个性时间大于请求时间，则说明资源更新过，返回资源文件和状态200，\n如果请求时间大于最后修改时间，则说明资源未修改，返回状态304告知浏览器使用缓存\n\n**过程**\n1. 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header\n2. 浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值是Last-Modified中的值\n3. 服务器再次收到这个资源请求，根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200\n\n缺点： \n- Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件）\n- 如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）。\n\n所以Etag / If-None-Match出现了，配合Cache-Control使用\n\nEtag: 由服务器返回，内容为资源的唯一标识，生成规则由服务器决定。 Apache中，Etag的值为文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。\nIf-None-Match\n> 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对：\n如果相同，则返回304\n如果不同，则返回200和资源文件\n\nEtag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。\n\n**优先级**\nEtag的优先级 大于 Last-Modified的\n\n**过程**\n1.客户端请求一个页面（A）。\n2.服务器返回页面A，并在给A加上一个ETag，值是这个资源的唯一标识，由服务器端生成。\n3.客户端展现该页面，并将页面连同ETag一起缓存。\n4.客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。\n5.服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。\n\n### 用户行为与缓存\n- 用户在地址栏回车、页面链接跳转、新开窗口、前进后退时，缓存是有效的\n- 用户点击F5的时候，Last-Modified/Etag是有效的，但是Expires、Cache-Control重置失效\n- ctrl+f5缓存全部失效\n\n<img src=\"/images/userCache.png\">\n\n### 常见状态码\n- 200：强缓Expires/Cache-Control存失效时，返回新的资源文件\n- 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304\n- 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功\n\n<img src=\"/images/trangle.png\">\n\n### 应用\n- 一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。\n\n- 当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；\n\n- 而当用户使用Ctrl+F5进行强制刷新的时候，会跳过强缓存和协商缓存，重新从服务器下载资源。\n\n- 分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败\n分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)\n\n[参考](http://coderlt.coding.me/2016/11/21/web-cache/)\n\n## 攻击\n\n### CRSF（cross site request Forgery)跨站请求伪造\n登录网站A，生成本地Cookie信息；登录危险网站B，B获取网站A的内容，并向A发送请求操作，若成功，则CRSF过程成功。其中登录B网站，行为可以是点击网站A中的链接链接。 \n\n#### CSRF的防范\n1. 验证HTTP Referer字段\n2. 在请求地址中添加token并验证\n\n### XSS攻击（跨脚本攻击）Cross-site scripting\nXSS攻击基本原理——代码注入（html,sql)\n\n\n","slug":"internet-http基础","published":1,"date":"2017-04-27T10:41:18.000Z","updated":"2017-04-27T10:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cbu0006kzy6jbr0cixo","content":"<h2 id=\"keep-alive模式\"><a href=\"#keep-alive模式\" class=\"headerlink\" title=\"keep-alive模式\"></a>keep-alive模式</h2><p>为什么要开启keep-alive模式？</p>\n<blockquote>\n<p>避免下载客户端和服务器再次建立释放连接的开销<br>单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用不超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。</p>\n</blockquote>\n<p>如何开启关闭keep-alive？</p>\n<blockquote>\n<p>http1.0默认是关闭的，启用需要在头上加入：Connection: Keep-Alive<br>http1.1默认开启的，关闭：Connection: close<br>大多数浏览器采用的是http1.1</p>\n</blockquote>\n<p>keep-alive模式如何确定响应数据接收完毕，我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判定</p>\n<ul>\n<li>Content-Length,表示实体内容的长度，客户端可以根据这个值来判断数据是否接收完成，但是如果没有这个字段呢</li>\n<li>Transfer-Encoding,当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。<br>chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0 的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字 ）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开</li>\n<li>两者都出现的时候，Transfer-Encoding优先级高</li>\n</ul>\n<h2 id=\"http头字段总结\"><a href=\"#http头字段总结\" class=\"headerlink\" title=\"http头字段总结\"></a>http头字段总结</h2><ul>\n<li>Accept：告诉web服务器接收什么介质类型，‘/‘表示任何类型， type/* 表示该类型下的所有子类型，type/sub-type。</li>\n<li>Accept-Charset： 浏览器声明自己接收的字符集</li>\n<li>Accept-Ranges：表示服务器是否接收实体一部分（一部分）的请求，bytes：表示接收，none表示不接受</li>\n<li>Age： 当代理服务器用自己缓存的实体去响应请求时候，表明该实体从产生到现在有多长时间</li>\n<li>Content-Encoding：表明web服务器用什么了压缩方法（gzip,deflate)压缩响应的对象</li>\n<li>Content-Language：web服务器告诉浏览器自己响应对象的语言</li>\n<li>Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022</li>\n<li>Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</li>\n<li>Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT</li>\n<li>Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</li>\n<li>If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。</li>\n<li>If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。</li>\n<li>If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</li>\n<li>Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的</li>\n<li>If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</li>\n<li>Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-</li>\n<li>Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：<a href=\"http://www.sina.com/\" target=\"_blank\" rel=\"external\">http://www.sina.com/</a></li>\n<li>Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache</li>\n<li>Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked</li>\n</ul>\n<h2 id=\"浏览器的缓存机制\"><a href=\"#浏览器的缓存机制\" class=\"headerlink\" title=\"浏览器的缓存机制\"></a>浏览器的缓存机制</h2><p>如果是请求头带有Cache-Control:max-age=0代表强制返回最新文件<br>如果是响应头中带有Cache-Control:max-age=0，则代表服务器要求浏览器你在使用本地缓存的时候，必须先和服务器进行一遍通信，将etag、 If-Not-Modified、If-None-Match、If-Modified-Since等字段传递给服务器以便验证当前浏览器端使用的文件是否是最新的,如果是最新的，服务端返回304，否则200，重新下载<br>并且确认浏览器中Disable Cache勾上没</p>\n<p><img src=\"/images/cache.png\"></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>服务器返回一个<strong>绝对时间</strong>，然后与下次客户端请求的时间进行对比，如果未过期，直接从本地缓存获取，请求返回200（from Cache）</p>\n<ul>\n<li>缺点： 客户端的时间与服务器的时间相差很大（时钟不同步，跨时区的因素），所以误差大，所以在HTTP1.1版开始，使用Cache-Control: max-age=秒替代</li>\n</ul>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>服务器返回的是一个<strong>相对时间</strong>，客户端两个间隔请求之差小于Cache-Control中设置的时间差，那么就从本地缓存中取，返回 200 （from Cache)</p>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><p>Cache-Control &gt; Expires,Cache-Control的值可以是：</p>\n<ul>\n<li>Public 指示响应可被任何缓存区缓存。</li>\n<li>Private 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>\n<li>no-cache 指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认</li>\n<li>no-store 在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。</li>\n<li>max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）&lt;客户端当前时间</li>\n<li>min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>\n<li>max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>\n</ul>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>Last-Modified / If-Modified-Since ： 标识资源的最后修改时间(由服务器返回)， 配合Cache-Control使用</p>\n<h4 id=\"If-Modified-Since\"><a href=\"#If-Modified-Since\" class=\"headerlink\" title=\"If-Modified-Since**\"></a>If-Modified-Since**</h4><blockquote>\n<p>重复请求时，当强缓存失效，发现请求头中有Last-Modified声明，则添加If-Modified-Since，内容为当前请求时间，发送请求，服务器获取请求时间与资源最后修改时间对比：<br>如果最后个性时间大于请求时间，则说明资源更新过，返回资源文件和状态200，<br>如果请求时间大于最后修改时间，则说明资源未修改，返回状态304告知浏览器使用缓存</p>\n</blockquote>\n<p><strong>过程</strong></p>\n<ol>\n<li>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header</li>\n<li>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值是Last-Modified中的值</li>\n<li>服务器再次收到这个资源请求，根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</li>\n</ol>\n<p>缺点： </p>\n<ul>\n<li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件）</li>\n<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）。</li>\n</ul>\n<p>所以Etag / If-None-Match出现了，配合Cache-Control使用</p>\n<p>Etag: 由服务器返回，内容为资源的唯一标识，生成规则由服务器决定。 Apache中，Etag的值为文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br>If-None-Match</p>\n<blockquote>\n<p>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对：<br>如果相同，则返回304<br>如果不同，则返回200和资源文件</p>\n</blockquote>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。</p>\n<p><strong>优先级</strong><br>Etag的优先级 大于 Last-Modified的</p>\n<p><strong>过程</strong><br>1.客户端请求一个页面（A）。<br>2.服务器返回页面A，并在给A加上一个ETag，值是这个资源的唯一标识，由服务器端生成。<br>3.客户端展现该页面，并将页面连同ETag一起缓存。<br>4.客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。<br>5.服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</p>\n<h3 id=\"用户行为与缓存\"><a href=\"#用户行为与缓存\" class=\"headerlink\" title=\"用户行为与缓存\"></a>用户行为与缓存</h3><ul>\n<li>用户在地址栏回车、页面链接跳转、新开窗口、前进后退时，缓存是有效的</li>\n<li>用户点击F5的时候，Last-Modified/Etag是有效的，但是Expires、Cache-Control重置失效</li>\n<li>ctrl+f5缓存全部失效</li>\n</ul>\n<p><img src=\"/images/userCache.png\"></p>\n<h3 id=\"常见状态码\"><a href=\"#常见状态码\" class=\"headerlink\" title=\"常见状态码\"></a>常见状态码</h3><ul>\n<li>200：强缓Expires/Cache-Control存失效时，返回新的资源文件</li>\n<li>304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304</li>\n<li>200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功</li>\n</ul>\n<p><img src=\"/images/trangle.png\"></p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><ul>\n<li><p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。</p>\n</li>\n<li><p>当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；</p>\n</li>\n<li><p>而当用户使用Ctrl+F5进行强制刷新的时候，会跳过强缓存和协商缓存，重新从服务器下载资源。</p>\n</li>\n<li><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)</p>\n</li>\n</ul>\n<p><a href=\"http://coderlt.coding.me/2016/11/21/web-cache/\" target=\"_blank\" rel=\"external\">参考</a></p>\n<h2 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h2><h3 id=\"CRSF（cross-site-request-Forgery-跨站请求伪造\"><a href=\"#CRSF（cross-site-request-Forgery-跨站请求伪造\" class=\"headerlink\" title=\"CRSF（cross site request Forgery)跨站请求伪造\"></a>CRSF（cross site request Forgery)跨站请求伪造</h3><p>登录网站A，生成本地Cookie信息；登录危险网站B，B获取网站A的内容，并向A发送请求操作，若成功，则CRSF过程成功。其中登录B网站，行为可以是点击网站A中的链接链接。 </p>\n<h4 id=\"CSRF的防范\"><a href=\"#CSRF的防范\" class=\"headerlink\" title=\"CSRF的防范\"></a>CSRF的防范</h4><ol>\n<li>验证HTTP Referer字段</li>\n<li>在请求地址中添加token并验证</li>\n</ol>\n<h3 id=\"XSS攻击（跨脚本攻击）Cross-site-scripting\"><a href=\"#XSS攻击（跨脚本攻击）Cross-site-scripting\" class=\"headerlink\" title=\"XSS攻击（跨脚本攻击）Cross-site scripting\"></a>XSS攻击（跨脚本攻击）Cross-site scripting</h3><p>XSS攻击基本原理——代码注入（html,sql)</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"keep-alive模式\"><a href=\"#keep-alive模式\" class=\"headerlink\" title=\"keep-alive模式\"></a>keep-alive模式</h2><p>为什么要开启keep-alive模式？</p>\n<blockquote>\n<p>避免下载客户端和服务器再次建立释放连接的开销<br>单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用不超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。</p>\n</blockquote>\n<p>如何开启关闭keep-alive？</p>\n<blockquote>\n<p>http1.0默认是关闭的，启用需要在头上加入：Connection: Keep-Alive<br>http1.1默认开启的，关闭：Connection: close<br>大多数浏览器采用的是http1.1</p>\n</blockquote>\n<p>keep-alive模式如何确定响应数据接收完毕，我们已经知道 了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判定</p>\n<ul>\n<li>Content-Length,表示实体内容的长度，客户端可以根据这个值来判断数据是否接收完成，但是如果没有这个字段呢</li>\n<li>Transfer-Encoding,当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输 数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。<br>chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明长度为0 的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（十六进制的数字 ）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用回车换行(CRLF) 隔开</li>\n<li>两者都出现的时候，Transfer-Encoding优先级高</li>\n</ul>\n<h2 id=\"http头字段总结\"><a href=\"#http头字段总结\" class=\"headerlink\" title=\"http头字段总结\"></a>http头字段总结</h2><ul>\n<li>Accept：告诉web服务器接收什么介质类型，‘/‘表示任何类型， type/* 表示该类型下的所有子类型，type/sub-type。</li>\n<li>Accept-Charset： 浏览器声明自己接收的字符集</li>\n<li>Accept-Ranges：表示服务器是否接收实体一部分（一部分）的请求，bytes：表示接收，none表示不接受</li>\n<li>Age： 当代理服务器用自己缓存的实体去响应请求时候，表明该实体从产生到现在有多长时间</li>\n<li>Content-Encoding：表明web服务器用什么了压缩方法（gzip,deflate)压缩响应的对象</li>\n<li>Content-Language：web服务器告诉浏览器自己响应对象的语言</li>\n<li>Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022</li>\n<li>Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml</li>\n<li>Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT</li>\n<li>Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn</li>\n<li>If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。</li>\n<li>If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。</li>\n<li>If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器 该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT</li>\n<li>Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的</li>\n<li>If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的 ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。</li>\n<li>Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546-</li>\n<li>Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：<a href=\"http://www.sina.com/\" target=\"_blank\" rel=\"external\">http://www.sina.com/</a></li>\n<li>Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache</li>\n<li>Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked</li>\n</ul>\n<h2 id=\"浏览器的缓存机制\"><a href=\"#浏览器的缓存机制\" class=\"headerlink\" title=\"浏览器的缓存机制\"></a>浏览器的缓存机制</h2><p>如果是请求头带有Cache-Control:max-age=0代表强制返回最新文件<br>如果是响应头中带有Cache-Control:max-age=0，则代表服务器要求浏览器你在使用本地缓存的时候，必须先和服务器进行一遍通信，将etag、 If-Not-Modified、If-None-Match、If-Modified-Since等字段传递给服务器以便验证当前浏览器端使用的文件是否是最新的,如果是最新的，服务端返回304，否则200，重新下载<br>并且确认浏览器中Disable Cache勾上没</p>\n<p><img src=\"/images/cache.png\"></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><h4 id=\"Expires\"><a href=\"#Expires\" class=\"headerlink\" title=\"Expires\"></a>Expires</h4><p>服务器返回一个<strong>绝对时间</strong>，然后与下次客户端请求的时间进行对比，如果未过期，直接从本地缓存获取，请求返回200（from Cache）</p>\n<ul>\n<li>缺点： 客户端的时间与服务器的时间相差很大（时钟不同步，跨时区的因素），所以误差大，所以在HTTP1.1版开始，使用Cache-Control: max-age=秒替代</li>\n</ul>\n<h4 id=\"Cache-Control\"><a href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"></a>Cache-Control</h4><p>服务器返回的是一个<strong>相对时间</strong>，客户端两个间隔请求之差小于Cache-Control中设置的时间差，那么就从本地缓存中取，返回 200 （from Cache)</p>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><p>Cache-Control &gt; Expires,Cache-Control的值可以是：</p>\n<ul>\n<li>Public 指示响应可被任何缓存区缓存。</li>\n<li>Private 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当前用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>\n<li>no-cache 指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，而是需要和服务器确认</li>\n<li>no-store 在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。</li>\n<li>max-age 指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。上次缓存时间（客户端的）+max-age（64200s）&lt;客户端当前时间</li>\n<li>min-fresh 指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>\n<li>max-stale 指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>\n</ul>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>Last-Modified / If-Modified-Since ： 标识资源的最后修改时间(由服务器返回)， 配合Cache-Control使用</p>\n<h4 id=\"If-Modified-Since\"><a href=\"#If-Modified-Since\" class=\"headerlink\" title=\"If-Modified-Since**\"></a>If-Modified-Since**</h4><blockquote>\n<p>重复请求时，当强缓存失效，发现请求头中有Last-Modified声明，则添加If-Modified-Since，内容为当前请求时间，发送请求，服务器获取请求时间与资源最后修改时间对比：<br>如果最后个性时间大于请求时间，则说明资源更新过，返回资源文件和状态200，<br>如果请求时间大于最后修改时间，则说明资源未修改，返回状态304告知浏览器使用缓存</p>\n</blockquote>\n<p><strong>过程</strong></p>\n<ol>\n<li>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header</li>\n<li>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值是Last-Modified中的值</li>\n<li>服务器再次收到这个资源请求，根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</li>\n</ol>\n<p>缺点： </p>\n<ul>\n<li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间（无法及时更新文件）</li>\n<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存，有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形（无法使用缓存）。</li>\n</ul>\n<p>所以Etag / If-None-Match出现了，配合Cache-Control使用</p>\n<p>Etag: 由服务器返回，内容为资源的唯一标识，生成规则由服务器决定。 Apache中，Etag的值为文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br>If-None-Match</p>\n<blockquote>\n<p>当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对：<br>如果相同，则返回304<br>如果不同，则返回200和资源文件</p>\n</blockquote>\n<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。</p>\n<p><strong>优先级</strong><br>Etag的优先级 大于 Last-Modified的</p>\n<p><strong>过程</strong><br>1.客户端请求一个页面（A）。<br>2.服务器返回页面A，并在给A加上一个ETag，值是这个资源的唯一标识，由服务器端生成。<br>3.客户端展现该页面，并将页面连同ETag一起缓存。<br>4.客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。<br>5.服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。</p>\n<h3 id=\"用户行为与缓存\"><a href=\"#用户行为与缓存\" class=\"headerlink\" title=\"用户行为与缓存\"></a>用户行为与缓存</h3><ul>\n<li>用户在地址栏回车、页面链接跳转、新开窗口、前进后退时，缓存是有效的</li>\n<li>用户点击F5的时候，Last-Modified/Etag是有效的，但是Expires、Cache-Control重置失效</li>\n<li>ctrl+f5缓存全部失效</li>\n</ul>\n<p><img src=\"/images/userCache.png\"></p>\n<h3 id=\"常见状态码\"><a href=\"#常见状态码\" class=\"headerlink\" title=\"常见状态码\"></a>常见状态码</h3><ul>\n<li>200：强缓Expires/Cache-Control存失效时，返回新的资源文件</li>\n<li>304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304</li>\n<li>200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功</li>\n</ul>\n<p><img src=\"/images/trangle.png\"></p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><ul>\n<li><p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。</p>\n</li>\n<li><p>当用户在按F5进行刷新的时候，会忽略Expires/Cache-Control的设置，会再次发送请求去服务器请求，而Last-Modified/Etag还是有效的，服务器会根据情况判断返回304还是200；</p>\n</li>\n<li><p>而当用户使用Ctrl+F5进行强制刷新的时候，会跳过强缓存和协商缓存，重新从服务器下载资源。</p>\n</li>\n<li><p>分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败<br>分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)</p>\n</li>\n</ul>\n<p><a href=\"http://coderlt.coding.me/2016/11/21/web-cache/\" target=\"_blank\" rel=\"external\">参考</a></p>\n<h2 id=\"攻击\"><a href=\"#攻击\" class=\"headerlink\" title=\"攻击\"></a>攻击</h2><h3 id=\"CRSF（cross-site-request-Forgery-跨站请求伪造\"><a href=\"#CRSF（cross-site-request-Forgery-跨站请求伪造\" class=\"headerlink\" title=\"CRSF（cross site request Forgery)跨站请求伪造\"></a>CRSF（cross site request Forgery)跨站请求伪造</h3><p>登录网站A，生成本地Cookie信息；登录危险网站B，B获取网站A的内容，并向A发送请求操作，若成功，则CRSF过程成功。其中登录B网站，行为可以是点击网站A中的链接链接。 </p>\n<h4 id=\"CSRF的防范\"><a href=\"#CSRF的防范\" class=\"headerlink\" title=\"CSRF的防范\"></a>CSRF的防范</h4><ol>\n<li>验证HTTP Referer字段</li>\n<li>在请求地址中添加token并验证</li>\n</ol>\n<h3 id=\"XSS攻击（跨脚本攻击）Cross-site-scripting\"><a href=\"#XSS攻击（跨脚本攻击）Cross-site-scripting\" class=\"headerlink\" title=\"XSS攻击（跨脚本攻击）Cross-site scripting\"></a>XSS攻击（跨脚本攻击）Cross-site scripting</h3><p>XSS攻击基本原理——代码注入（html,sql)</p>\n"},{"title":"网络协议","type":"categories","_content":"\n# 什么是网络\n计算机主机设备等设备透过网络线或者无线网络技术，将这些设备连接起来，使得数据可以通过网络媒体传输的一种方式\n#  计算机网络协议： OSI 七层协定\n[参考](http://cn.linux.vbird.org/linux_server/0110network_basic.php#whatisnetwork_what)\n\n# 计算机网络协议： TCP/IP\n<img src=\"/images/xieyi.png\">\n浏览器键入一个网址发生了什么?\n应用层（http）->传送层（tcp）->网络层（ip）->链结层（利用传输媒体传送到远程主机）\n\n# DNS\n<img src=\"/images/dns.png\">\n\n# 端口\n<img src=\"/images/port.png\">","source":"_posts/internet/网络协议.md","raw":"---\ntitle: 网络协议\ntype: \"categories\"\ncategories: [Internet]\n---\n\n# 什么是网络\n计算机主机设备等设备透过网络线或者无线网络技术，将这些设备连接起来，使得数据可以通过网络媒体传输的一种方式\n#  计算机网络协议： OSI 七层协定\n[参考](http://cn.linux.vbird.org/linux_server/0110network_basic.php#whatisnetwork_what)\n\n# 计算机网络协议： TCP/IP\n<img src=\"/images/xieyi.png\">\n浏览器键入一个网址发生了什么?\n应用层（http）->传送层（tcp）->网络层（ip）->链结层（利用传输媒体传送到远程主机）\n\n# DNS\n<img src=\"/images/dns.png\">\n\n# 端口\n<img src=\"/images/port.png\">","slug":"internet-网络协议","published":1,"date":"2017-04-27T10:41:10.000Z","updated":"2017-04-27T10:41:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cc80008kzy6mz8kjxow","content":"<h1 id=\"什么是网络\"><a href=\"#什么是网络\" class=\"headerlink\" title=\"什么是网络\"></a>什么是网络</h1><p>计算机主机设备等设备透过网络线或者无线网络技术，将这些设备连接起来，使得数据可以通过网络媒体传输的一种方式</p>\n<h1 id=\"计算机网络协议：-OSI-七层协定\"><a href=\"#计算机网络协议：-OSI-七层协定\" class=\"headerlink\" title=\"计算机网络协议： OSI 七层协定\"></a>计算机网络协议： OSI 七层协定</h1><p><a href=\"http://cn.linux.vbird.org/linux_server/0110network_basic.php#whatisnetwork_what\" target=\"_blank\" rel=\"external\">参考</a></p>\n<h1 id=\"计算机网络协议：-TCP-IP\"><a href=\"#计算机网络协议：-TCP-IP\" class=\"headerlink\" title=\"计算机网络协议： TCP/IP\"></a>计算机网络协议： TCP/IP</h1><p><img src=\"/images/xieyi.png\"><br>浏览器键入一个网址发生了什么?<br>应用层（http）-&gt;传送层（tcp）-&gt;网络层（ip）-&gt;链结层（利用传输媒体传送到远程主机）</p>\n<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><p><img src=\"/images/dns.png\"></p>\n<h1 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h1><p><img src=\"/images/port.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是网络\"><a href=\"#什么是网络\" class=\"headerlink\" title=\"什么是网络\"></a>什么是网络</h1><p>计算机主机设备等设备透过网络线或者无线网络技术，将这些设备连接起来，使得数据可以通过网络媒体传输的一种方式</p>\n<h1 id=\"计算机网络协议：-OSI-七层协定\"><a href=\"#计算机网络协议：-OSI-七层协定\" class=\"headerlink\" title=\"计算机网络协议： OSI 七层协定\"></a>计算机网络协议： OSI 七层协定</h1><p><a href=\"http://cn.linux.vbird.org/linux_server/0110network_basic.php#whatisnetwork_what\" target=\"_blank\" rel=\"external\">参考</a></p>\n<h1 id=\"计算机网络协议：-TCP-IP\"><a href=\"#计算机网络协议：-TCP-IP\" class=\"headerlink\" title=\"计算机网络协议： TCP/IP\"></a>计算机网络协议： TCP/IP</h1><p><img src=\"/images/xieyi.png\"><br>浏览器键入一个网址发生了什么?<br>应用层（http）-&gt;传送层（tcp）-&gt;网络层（ip）-&gt;链结层（利用传输媒体传送到远程主机）</p>\n<h1 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h1><p><img src=\"/images/dns.png\"></p>\n<h1 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h1><p><img src=\"/images/port.png\"></p>\n"},{"title":"JWT","type":"categories","_content":"\n# JWT\nhttp协议是无状态的，所以会有cookie/session来解决状态问题，但是随着终端设备增多，前后端分离方式流行，RESTful API是目前比较成熟的一套接口规范，提倡无状态，JWT可以实现无状态，避免了session这种有状态的，大量的占用服务器的内存，需要借助于redis集群来存储session，JWT将用户状态权限放到客户端，服务端根据传递过去的的token来判断是否有访问这个资源的权限\n\n# JWT组成部分\n- 头部\n- 负载\n- 签名\ntoken经过对头部，负载进行base64处理，再将头部，负载，签名通过加密算法进行加密，最后生成token = 头部.负载.签名\n\n[参考](https://segmentfault.com/a/1190000009030769)","source":"_posts/node/JWT.md","raw":"---\ntitle: JWT\ntype: \"categories\"\ncategories: 后端\n---\n\n# JWT\nhttp协议是无状态的，所以会有cookie/session来解决状态问题，但是随着终端设备增多，前后端分离方式流行，RESTful API是目前比较成熟的一套接口规范，提倡无状态，JWT可以实现无状态，避免了session这种有状态的，大量的占用服务器的内存，需要借助于redis集群来存储session，JWT将用户状态权限放到客户端，服务端根据传递过去的的token来判断是否有访问这个资源的权限\n\n# JWT组成部分\n- 头部\n- 负载\n- 签名\ntoken经过对头部，负载进行base64处理，再将头部，负载，签名通过加密算法进行加密，最后生成token = 头部.负载.签名\n\n[参考](https://segmentfault.com/a/1190000009030769)","slug":"node-JWT","published":1,"date":"2017-09-26T08:35:10.000Z","updated":"2017-09-26T08:35:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cce0009kzy6msvshfss","content":"<h1 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h1><p>http协议是无状态的，所以会有cookie/session来解决状态问题，但是随着终端设备增多，前后端分离方式流行，RESTful API是目前比较成熟的一套接口规范，提倡无状态，JWT可以实现无状态，避免了session这种有状态的，大量的占用服务器的内存，需要借助于redis集群来存储session，JWT将用户状态权限放到客户端，服务端根据传递过去的的token来判断是否有访问这个资源的权限</p>\n<h1 id=\"JWT组成部分\"><a href=\"#JWT组成部分\" class=\"headerlink\" title=\"JWT组成部分\"></a>JWT组成部分</h1><ul>\n<li>头部</li>\n<li>负载</li>\n<li>签名<br>token经过对头部，负载进行base64处理，再将头部，负载，签名通过加密算法进行加密，最后生成token = 头部.负载.签名</li>\n</ul>\n<p><a href=\"https://segmentfault.com/a/1190000009030769\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JWT\"><a href=\"#JWT\" class=\"headerlink\" title=\"JWT\"></a>JWT</h1><p>http协议是无状态的，所以会有cookie/session来解决状态问题，但是随着终端设备增多，前后端分离方式流行，RESTful API是目前比较成熟的一套接口规范，提倡无状态，JWT可以实现无状态，避免了session这种有状态的，大量的占用服务器的内存，需要借助于redis集群来存储session，JWT将用户状态权限放到客户端，服务端根据传递过去的的token来判断是否有访问这个资源的权限</p>\n<h1 id=\"JWT组成部分\"><a href=\"#JWT组成部分\" class=\"headerlink\" title=\"JWT组成部分\"></a>JWT组成部分</h1><ul>\n<li>头部</li>\n<li>负载</li>\n<li>签名<br>token经过对头部，负载进行base64处理，再将头部，负载，签名通过加密算法进行加密，最后生成token = 头部.负载.签名</li>\n</ul>\n<p><a href=\"https://segmentfault.com/a/1190000009030769\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"UMD规范","type":"categories","_content":"\n### AMD 预加载异步加载，一个文件中可定义多个模块\n\n### CMD 执行到了再加载\n\n### CommonJS 一个文件一个模块，同步加载，单独作用域\n为什么服务端用CommonJS无妨呢， ，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\"假死\"状态。\n\n### UMD规范\n\n\n```\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery', 'underscore'], factory);\n    } else if (typeof exports === 'object') {\n        //if (typeof define === 'function' && define.cmd) {} 在前端可以用这个\n        // Node, CommonJS-like\n        module.exports = factory(require('jquery'), require('underscore'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.jQuery, root._);\n    }\n}(this, function ($, _) {\n    //    methods\n    function a(){};    //    private because it's not returned (see below)\n    function b(){};    //    public because it's returned\n    function c(){};    //    public because it's returned\n\n    //    exposed public methods\n    return {\n        b: b,\n        c: c\n    }\n}));\n\n```\n\n### 模块开发的好处：使各模块高内聚、低耦合，方便拓展维护","source":"_posts/node/UMD规范.md","raw":"---\ntitle: UMD规范\ntype: \"categories\"\ncategories: 后端\n---\n\n### AMD 预加载异步加载，一个文件中可定义多个模块\n\n### CMD 执行到了再加载\n\n### CommonJS 一个文件一个模块，同步加载，单独作用域\n为什么服务端用CommonJS无妨呢， ，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于\"假死\"状态。\n\n### UMD规范\n\n\n```\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery', 'underscore'], factory);\n    } else if (typeof exports === 'object') {\n        //if (typeof define === 'function' && define.cmd) {} 在前端可以用这个\n        // Node, CommonJS-like\n        module.exports = factory(require('jquery'), require('underscore'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.jQuery, root._);\n    }\n}(this, function ($, _) {\n    //    methods\n    function a(){};    //    private because it's not returned (see below)\n    function b(){};    //    public because it's returned\n    function c(){};    //    public because it's returned\n\n    //    exposed public methods\n    return {\n        b: b,\n        c: c\n    }\n}));\n\n```\n\n### 模块开发的好处：使各模块高内聚、低耦合，方便拓展维护","slug":"node-UMD规范","published":1,"date":"2017-03-15T10:00:44.000Z","updated":"2017-03-15T10:00:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccg000bkzy6oaegtw7u","content":"<h3 id=\"AMD-预加载异步加载，一个文件中可定义多个模块\"><a href=\"#AMD-预加载异步加载，一个文件中可定义多个模块\" class=\"headerlink\" title=\"AMD 预加载异步加载，一个文件中可定义多个模块\"></a>AMD 预加载异步加载，一个文件中可定义多个模块</h3><h3 id=\"CMD-执行到了再加载\"><a href=\"#CMD-执行到了再加载\" class=\"headerlink\" title=\"CMD 执行到了再加载\"></a>CMD 执行到了再加载</h3><h3 id=\"CommonJS-一个文件一个模块，同步加载，单独作用域\"><a href=\"#CommonJS-一个文件一个模块，同步加载，单独作用域\" class=\"headerlink\" title=\"CommonJS 一个文件一个模块，同步加载，单独作用域\"></a>CommonJS 一个文件一个模块，同步加载，单独作用域</h3><p>为什么服务端用CommonJS无妨呢， ，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>\n<h3 id=\"UMD规范\"><a href=\"#UMD规范\" class=\"headerlink\" title=\"UMD规范\"></a>UMD规范</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (root, factory) &#123;</div><div class=\"line\">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</div><div class=\"line\">        // AMD</div><div class=\"line\">        define([&apos;jquery&apos;, &apos;underscore&apos;], factory);</div><div class=\"line\">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</div><div class=\"line\">        //if (typeof define === &apos;function&apos; &amp;&amp; define.cmd) &#123;&#125; 在前端可以用这个</div><div class=\"line\">        // Node, CommonJS-like</div><div class=\"line\">        module.exports = factory(require(&apos;jquery&apos;), require(&apos;underscore&apos;));</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Browser globals (root is window)</div><div class=\"line\">        root.returnExports = factory(root.jQuery, root._);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;(this, function ($, _) &#123;</div><div class=\"line\">    //    methods</div><div class=\"line\">    function a()&#123;&#125;;    //    private because it&apos;s not returned (see below)</div><div class=\"line\">    function b()&#123;&#125;;    //    public because it&apos;s returned</div><div class=\"line\">    function c()&#123;&#125;;    //    public because it&apos;s returned</div><div class=\"line\"></div><div class=\"line\">    //    exposed public methods</div><div class=\"line\">    return &#123;</div><div class=\"line\">        b: b,</div><div class=\"line\">        c: c</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure>\n<h3 id=\"模块开发的好处：使各模块高内聚、低耦合，方便拓展维护\"><a href=\"#模块开发的好处：使各模块高内聚、低耦合，方便拓展维护\" class=\"headerlink\" title=\"模块开发的好处：使各模块高内聚、低耦合，方便拓展维护\"></a>模块开发的好处：使各模块高内聚、低耦合，方便拓展维护</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"AMD-预加载异步加载，一个文件中可定义多个模块\"><a href=\"#AMD-预加载异步加载，一个文件中可定义多个模块\" class=\"headerlink\" title=\"AMD 预加载异步加载，一个文件中可定义多个模块\"></a>AMD 预加载异步加载，一个文件中可定义多个模块</h3><h3 id=\"CMD-执行到了再加载\"><a href=\"#CMD-执行到了再加载\" class=\"headerlink\" title=\"CMD 执行到了再加载\"></a>CMD 执行到了再加载</h3><h3 id=\"CommonJS-一个文件一个模块，同步加载，单独作用域\"><a href=\"#CommonJS-一个文件一个模块，同步加载，单独作用域\" class=\"headerlink\" title=\"CommonJS 一个文件一个模块，同步加载，单独作用域\"></a>CommonJS 一个文件一个模块，同步加载，单独作用域</h3><p>为什么服务端用CommonJS无妨呢， ，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p>\n<h3 id=\"UMD规范\"><a href=\"#UMD规范\" class=\"headerlink\" title=\"UMD规范\"></a>UMD规范</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (root, factory) &#123;</div><div class=\"line\">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</div><div class=\"line\">        // AMD</div><div class=\"line\">        define([&apos;jquery&apos;, &apos;underscore&apos;], factory);</div><div class=\"line\">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</div><div class=\"line\">        //if (typeof define === &apos;function&apos; &amp;&amp; define.cmd) &#123;&#125; 在前端可以用这个</div><div class=\"line\">        // Node, CommonJS-like</div><div class=\"line\">        module.exports = factory(require(&apos;jquery&apos;), require(&apos;underscore&apos;));</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Browser globals (root is window)</div><div class=\"line\">        root.returnExports = factory(root.jQuery, root._);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;(this, function ($, _) &#123;</div><div class=\"line\">    //    methods</div><div class=\"line\">    function a()&#123;&#125;;    //    private because it&apos;s not returned (see below)</div><div class=\"line\">    function b()&#123;&#125;;    //    public because it&apos;s returned</div><div class=\"line\">    function c()&#123;&#125;;    //    public because it&apos;s returned</div><div class=\"line\"></div><div class=\"line\">    //    exposed public methods</div><div class=\"line\">    return &#123;</div><div class=\"line\">        b: b,</div><div class=\"line\">        c: c</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;));</div></pre></td></tr></table></figure>\n<h3 id=\"模块开发的好处：使各模块高内聚、低耦合，方便拓展维护\"><a href=\"#模块开发的好处：使各模块高内聚、低耦合，方便拓展维护\" class=\"headerlink\" title=\"模块开发的好处：使各模块高内聚、低耦合，方便拓展维护\"></a>模块开发的好处：使各模块高内聚、低耦合，方便拓展维护</h3>"},{"title":"buffer","type":"categories","_content":"\n# 为什么要出现Buffer\n因为js删除处理unicode数据，但对二进制数据处理不擅长，所以诞生了Buffer对象（对node.js处理二进制数据的接口）\n# buffer特点\nbuffer所占用的内存不是通过V8来分配的，属于堆外内存，不是通过fs.readFile()和fs.writeRile()直接对大文件进行操作，而是通过fs.createReadStream()和fs.createWriteStream()方法通过流的方式对大文件进行操作\n# Buffer结构\nBuffer是一个像Array的对象，主要用于操作字节\n\n## 模块结构\nbuffer是一个Javascript与c++结合的模块，性能部分用C++实现，非性能相关部分用Javascript实现\n\n## Buffer对象\nBuffer类似于数组，元素为16进制的两位数，即0-255的数值，utf-8下，中文占3个元素，字母和半角点占用1个\n\n## Buffer内存分配\nNode采用了slab分配机制，动态内存管理机制，以8kb作为一个界限，分配小buffer对象和大buffer对象\n\n#Buffer的转换\n支持的编码 ASCII UTF_8 Base64等\n\n## 字符串转化成Buffer\nnew Buffer(str, [encoding])\n\n## Buffer转字符串\nbuf.toString([encoding], [start], [end])\n\n## Buffer不支持的编码类型\nBuffer.isEncoding(encoding) 判断方法\n不支持的采用第三方模块，iconv和iconv-lite，前者是采用C++调用libiconv库完成，后者是纯Javascript，因为转码耗cpu，在v8的高性能下，少了C++到Javascript的转换，所以后者更好\n\n# buffer的拼接\n宽字节的中文会造成乱码问题，比如‘大哥大’这个三个字符一共9个字节，我们要是设置，highWaterMark设置为8，那么就有一个字节将会以乱码输出\n\n## setEncoding() 和 string_decoder()\nsetEncoding()是为了让data事件传递的不是一个Buffer对象，而是编码的字符串，输出的时候不再受Buffer大小影响了，因为在调用setEncoding（）时，可读流对象在内部设置了一个decorder对象，每次data事件都通过decorder对象进行Buffer到字符串的解码，然后传递给调用者。\n\n## 正确拼接buffer\n用一个数组来存储收到的所有Buffer片段，并且记录下所有片段的总长度，调用Buffer.concat()方法生成一个合并的Buffer对象，Buffer.concat()方法封装了从小buffer对象到大buffer对象的复制过程，实现十分细腻\n\n# buffer与性能\n字符串的传输效率低于buffer对象的传输效率，当读取大文件的时候，highWaterMark值的大小越大，读取速度越快","source":"_posts/node/buffer.md","raw":"---\ntitle: buffer\ntype: \"categories\"\ncategories: 后端\n---\n\n# 为什么要出现Buffer\n因为js删除处理unicode数据，但对二进制数据处理不擅长，所以诞生了Buffer对象（对node.js处理二进制数据的接口）\n# buffer特点\nbuffer所占用的内存不是通过V8来分配的，属于堆外内存，不是通过fs.readFile()和fs.writeRile()直接对大文件进行操作，而是通过fs.createReadStream()和fs.createWriteStream()方法通过流的方式对大文件进行操作\n# Buffer结构\nBuffer是一个像Array的对象，主要用于操作字节\n\n## 模块结构\nbuffer是一个Javascript与c++结合的模块，性能部分用C++实现，非性能相关部分用Javascript实现\n\n## Buffer对象\nBuffer类似于数组，元素为16进制的两位数，即0-255的数值，utf-8下，中文占3个元素，字母和半角点占用1个\n\n## Buffer内存分配\nNode采用了slab分配机制，动态内存管理机制，以8kb作为一个界限，分配小buffer对象和大buffer对象\n\n#Buffer的转换\n支持的编码 ASCII UTF_8 Base64等\n\n## 字符串转化成Buffer\nnew Buffer(str, [encoding])\n\n## Buffer转字符串\nbuf.toString([encoding], [start], [end])\n\n## Buffer不支持的编码类型\nBuffer.isEncoding(encoding) 判断方法\n不支持的采用第三方模块，iconv和iconv-lite，前者是采用C++调用libiconv库完成，后者是纯Javascript，因为转码耗cpu，在v8的高性能下，少了C++到Javascript的转换，所以后者更好\n\n# buffer的拼接\n宽字节的中文会造成乱码问题，比如‘大哥大’这个三个字符一共9个字节，我们要是设置，highWaterMark设置为8，那么就有一个字节将会以乱码输出\n\n## setEncoding() 和 string_decoder()\nsetEncoding()是为了让data事件传递的不是一个Buffer对象，而是编码的字符串，输出的时候不再受Buffer大小影响了，因为在调用setEncoding（）时，可读流对象在内部设置了一个decorder对象，每次data事件都通过decorder对象进行Buffer到字符串的解码，然后传递给调用者。\n\n## 正确拼接buffer\n用一个数组来存储收到的所有Buffer片段，并且记录下所有片段的总长度，调用Buffer.concat()方法生成一个合并的Buffer对象，Buffer.concat()方法封装了从小buffer对象到大buffer对象的复制过程，实现十分细腻\n\n# buffer与性能\n字符串的传输效率低于buffer对象的传输效率，当读取大文件的时候，highWaterMark值的大小越大，读取速度越快","slug":"node-buffer","published":1,"date":"2017-09-14T10:53:59.000Z","updated":"2017-09-14T10:53:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cch000ckzy6phur6gax","content":"<h1 id=\"为什么要出现Buffer\"><a href=\"#为什么要出现Buffer\" class=\"headerlink\" title=\"为什么要出现Buffer\"></a>为什么要出现Buffer</h1><p>因为js删除处理unicode数据，但对二进制数据处理不擅长，所以诞生了Buffer对象（对node.js处理二进制数据的接口）</p>\n<h1 id=\"buffer特点\"><a href=\"#buffer特点\" class=\"headerlink\" title=\"buffer特点\"></a>buffer特点</h1><p>buffer所占用的内存不是通过V8来分配的，属于堆外内存，不是通过fs.readFile()和fs.writeRile()直接对大文件进行操作，而是通过fs.createReadStream()和fs.createWriteStream()方法通过流的方式对大文件进行操作</p>\n<h1 id=\"Buffer结构\"><a href=\"#Buffer结构\" class=\"headerlink\" title=\"Buffer结构\"></a>Buffer结构</h1><p>Buffer是一个像Array的对象，主要用于操作字节</p>\n<h2 id=\"模块结构\"><a href=\"#模块结构\" class=\"headerlink\" title=\"模块结构\"></a>模块结构</h2><p>buffer是一个Javascript与c++结合的模块，性能部分用C++实现，非性能相关部分用Javascript实现</p>\n<h2 id=\"Buffer对象\"><a href=\"#Buffer对象\" class=\"headerlink\" title=\"Buffer对象\"></a>Buffer对象</h2><p>Buffer类似于数组，元素为16进制的两位数，即0-255的数值，utf-8下，中文占3个元素，字母和半角点占用1个</p>\n<h2 id=\"Buffer内存分配\"><a href=\"#Buffer内存分配\" class=\"headerlink\" title=\"Buffer内存分配\"></a>Buffer内存分配</h2><p>Node采用了slab分配机制，动态内存管理机制，以8kb作为一个界限，分配小buffer对象和大buffer对象</p>\n<p>#Buffer的转换<br>支持的编码 ASCII UTF_8 Base64等</p>\n<h2 id=\"字符串转化成Buffer\"><a href=\"#字符串转化成Buffer\" class=\"headerlink\" title=\"字符串转化成Buffer\"></a>字符串转化成Buffer</h2><p>new Buffer(str, [encoding])</p>\n<h2 id=\"Buffer转字符串\"><a href=\"#Buffer转字符串\" class=\"headerlink\" title=\"Buffer转字符串\"></a>Buffer转字符串</h2><p>buf.toString([encoding], [start], [end])</p>\n<h2 id=\"Buffer不支持的编码类型\"><a href=\"#Buffer不支持的编码类型\" class=\"headerlink\" title=\"Buffer不支持的编码类型\"></a>Buffer不支持的编码类型</h2><p>Buffer.isEncoding(encoding) 判断方法<br>不支持的采用第三方模块，iconv和iconv-lite，前者是采用C++调用libiconv库完成，后者是纯Javascript，因为转码耗cpu，在v8的高性能下，少了C++到Javascript的转换，所以后者更好</p>\n<h1 id=\"buffer的拼接\"><a href=\"#buffer的拼接\" class=\"headerlink\" title=\"buffer的拼接\"></a>buffer的拼接</h1><p>宽字节的中文会造成乱码问题，比如‘大哥大’这个三个字符一共9个字节，我们要是设置，highWaterMark设置为8，那么就有一个字节将会以乱码输出</p>\n<h2 id=\"setEncoding-和-string-decoder\"><a href=\"#setEncoding-和-string-decoder\" class=\"headerlink\" title=\"setEncoding() 和 string_decoder()\"></a>setEncoding() 和 string_decoder()</h2><p>setEncoding()是为了让data事件传递的不是一个Buffer对象，而是编码的字符串，输出的时候不再受Buffer大小影响了，因为在调用setEncoding（）时，可读流对象在内部设置了一个decorder对象，每次data事件都通过decorder对象进行Buffer到字符串的解码，然后传递给调用者。</p>\n<h2 id=\"正确拼接buffer\"><a href=\"#正确拼接buffer\" class=\"headerlink\" title=\"正确拼接buffer\"></a>正确拼接buffer</h2><p>用一个数组来存储收到的所有Buffer片段，并且记录下所有片段的总长度，调用Buffer.concat()方法生成一个合并的Buffer对象，Buffer.concat()方法封装了从小buffer对象到大buffer对象的复制过程，实现十分细腻</p>\n<h1 id=\"buffer与性能\"><a href=\"#buffer与性能\" class=\"headerlink\" title=\"buffer与性能\"></a>buffer与性能</h1><p>字符串的传输效率低于buffer对象的传输效率，当读取大文件的时候，highWaterMark值的大小越大，读取速度越快</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要出现Buffer\"><a href=\"#为什么要出现Buffer\" class=\"headerlink\" title=\"为什么要出现Buffer\"></a>为什么要出现Buffer</h1><p>因为js删除处理unicode数据，但对二进制数据处理不擅长，所以诞生了Buffer对象（对node.js处理二进制数据的接口）</p>\n<h1 id=\"buffer特点\"><a href=\"#buffer特点\" class=\"headerlink\" title=\"buffer特点\"></a>buffer特点</h1><p>buffer所占用的内存不是通过V8来分配的，属于堆外内存，不是通过fs.readFile()和fs.writeRile()直接对大文件进行操作，而是通过fs.createReadStream()和fs.createWriteStream()方法通过流的方式对大文件进行操作</p>\n<h1 id=\"Buffer结构\"><a href=\"#Buffer结构\" class=\"headerlink\" title=\"Buffer结构\"></a>Buffer结构</h1><p>Buffer是一个像Array的对象，主要用于操作字节</p>\n<h2 id=\"模块结构\"><a href=\"#模块结构\" class=\"headerlink\" title=\"模块结构\"></a>模块结构</h2><p>buffer是一个Javascript与c++结合的模块，性能部分用C++实现，非性能相关部分用Javascript实现</p>\n<h2 id=\"Buffer对象\"><a href=\"#Buffer对象\" class=\"headerlink\" title=\"Buffer对象\"></a>Buffer对象</h2><p>Buffer类似于数组，元素为16进制的两位数，即0-255的数值，utf-8下，中文占3个元素，字母和半角点占用1个</p>\n<h2 id=\"Buffer内存分配\"><a href=\"#Buffer内存分配\" class=\"headerlink\" title=\"Buffer内存分配\"></a>Buffer内存分配</h2><p>Node采用了slab分配机制，动态内存管理机制，以8kb作为一个界限，分配小buffer对象和大buffer对象</p>\n<p>#Buffer的转换<br>支持的编码 ASCII UTF_8 Base64等</p>\n<h2 id=\"字符串转化成Buffer\"><a href=\"#字符串转化成Buffer\" class=\"headerlink\" title=\"字符串转化成Buffer\"></a>字符串转化成Buffer</h2><p>new Buffer(str, [encoding])</p>\n<h2 id=\"Buffer转字符串\"><a href=\"#Buffer转字符串\" class=\"headerlink\" title=\"Buffer转字符串\"></a>Buffer转字符串</h2><p>buf.toString([encoding], [start], [end])</p>\n<h2 id=\"Buffer不支持的编码类型\"><a href=\"#Buffer不支持的编码类型\" class=\"headerlink\" title=\"Buffer不支持的编码类型\"></a>Buffer不支持的编码类型</h2><p>Buffer.isEncoding(encoding) 判断方法<br>不支持的采用第三方模块，iconv和iconv-lite，前者是采用C++调用libiconv库完成，后者是纯Javascript，因为转码耗cpu，在v8的高性能下，少了C++到Javascript的转换，所以后者更好</p>\n<h1 id=\"buffer的拼接\"><a href=\"#buffer的拼接\" class=\"headerlink\" title=\"buffer的拼接\"></a>buffer的拼接</h1><p>宽字节的中文会造成乱码问题，比如‘大哥大’这个三个字符一共9个字节，我们要是设置，highWaterMark设置为8，那么就有一个字节将会以乱码输出</p>\n<h2 id=\"setEncoding-和-string-decoder\"><a href=\"#setEncoding-和-string-decoder\" class=\"headerlink\" title=\"setEncoding() 和 string_decoder()\"></a>setEncoding() 和 string_decoder()</h2><p>setEncoding()是为了让data事件传递的不是一个Buffer对象，而是编码的字符串，输出的时候不再受Buffer大小影响了，因为在调用setEncoding（）时，可读流对象在内部设置了一个decorder对象，每次data事件都通过decorder对象进行Buffer到字符串的解码，然后传递给调用者。</p>\n<h2 id=\"正确拼接buffer\"><a href=\"#正确拼接buffer\" class=\"headerlink\" title=\"正确拼接buffer\"></a>正确拼接buffer</h2><p>用一个数组来存储收到的所有Buffer片段，并且记录下所有片段的总长度，调用Buffer.concat()方法生成一个合并的Buffer对象，Buffer.concat()方法封装了从小buffer对象到大buffer对象的复制过程，实现十分细腻</p>\n<h1 id=\"buffer与性能\"><a href=\"#buffer与性能\" class=\"headerlink\" title=\"buffer与性能\"></a>buffer与性能</h1><p>字符串的传输效率低于buffer对象的传输效率，当读取大文件的时候，highWaterMark值的大小越大，读取速度越快</p>\n"},{"title":"process","type":"categories","_content":"\n```\n//默认情况下，输入流是关闭的，要监听输入流的数据，首先要开启输入流\n\nprocess.stdin.resume()\n\nlet a, b\n\nprocess.stout.write('请输入a的值')\n\n//用于监听用户输入的数据\n\nprocess.stdin.on('data', (chunk)=> {\n\tif(!a) {\n\t\ta = Number(chunk)\n\t\tprocess.stdout.write('请输入b的值：')\n\t} else {\n\t\tb = Number(chunk)\n\t\tprocess.stdout.write(`计算结果是： ${a} + ${b}`)\n\t}\n})\n\n```","source":"_posts/node/process.md","raw":"---\ntitle: process\ntype: \"categories\"\ncategories: 后端\n---\n\n```\n//默认情况下，输入流是关闭的，要监听输入流的数据，首先要开启输入流\n\nprocess.stdin.resume()\n\nlet a, b\n\nprocess.stout.write('请输入a的值')\n\n//用于监听用户输入的数据\n\nprocess.stdin.on('data', (chunk)=> {\n\tif(!a) {\n\t\ta = Number(chunk)\n\t\tprocess.stdout.write('请输入b的值：')\n\t} else {\n\t\tb = Number(chunk)\n\t\tprocess.stdout.write(`计算结果是： ${a} + ${b}`)\n\t}\n})\n\n```","slug":"node-process","published":1,"date":"2017-03-05T08:45:19.000Z","updated":"2017-03-05T08:45:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cci000ekzy6ty4lnjew","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//默认情况下，输入流是关闭的，要监听输入流的数据，首先要开启输入流</div><div class=\"line\"></div><div class=\"line\">process.stdin.resume()</div><div class=\"line\"></div><div class=\"line\">let a, b</div><div class=\"line\"></div><div class=\"line\">process.stout.write(&apos;请输入a的值&apos;)</div><div class=\"line\"></div><div class=\"line\">//用于监听用户输入的数据</div><div class=\"line\"></div><div class=\"line\">process.stdin.on(&apos;data&apos;, (chunk)=&gt; &#123;</div><div class=\"line\">\tif(!a) &#123;</div><div class=\"line\">\t\ta = Number(chunk)</div><div class=\"line\">\t\tprocess.stdout.write(&apos;请输入b的值：&apos;)</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\tb = Number(chunk)</div><div class=\"line\">\t\tprocess.stdout.write(`计算结果是： $&#123;a&#125; + $&#123;b&#125;`)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">//默认情况下，输入流是关闭的，要监听输入流的数据，首先要开启输入流</div><div class=\"line\"></div><div class=\"line\">process.stdin.resume()</div><div class=\"line\"></div><div class=\"line\">let a, b</div><div class=\"line\"></div><div class=\"line\">process.stout.write(&apos;请输入a的值&apos;)</div><div class=\"line\"></div><div class=\"line\">//用于监听用户输入的数据</div><div class=\"line\"></div><div class=\"line\">process.stdin.on(&apos;data&apos;, (chunk)=&gt; &#123;</div><div class=\"line\">\tif(!a) &#123;</div><div class=\"line\">\t\ta = Number(chunk)</div><div class=\"line\">\t\tprocess.stdout.write(&apos;请输入b的值：&apos;)</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\tb = Number(chunk)</div><div class=\"line\">\t\tprocess.stdout.write(`计算结果是： $&#123;a&#125; + $&#123;b&#125;`)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>"},{"title":"node作为中间层","type":"categories","_content":"\n# 优点\n- 一个Server端可以服务于多个Client端（IOS、andriod、Node）\n- node层处理业务逻辑，做高层次的抽象，后端提供相关服务，让java端和前端更加解耦\n- node方便部署\n\n# 什么时候选择node作为中间层\n- SPA 项目并有服务端渲染需求的项目\n- 大批量页面渲染，多为静态且页面大，少量的动态数据 \n\n# 缺点\n不适合做cpu密集型的运算，因为会阻塞","source":"_posts/node/node做中间层的好处.md","raw":"---\ntitle: node作为中间层\ntype: \"categories\"\ncategories: 后端\n---\n\n# 优点\n- 一个Server端可以服务于多个Client端（IOS、andriod、Node）\n- node层处理业务逻辑，做高层次的抽象，后端提供相关服务，让java端和前端更加解耦\n- node方便部署\n\n# 什么时候选择node作为中间层\n- SPA 项目并有服务端渲染需求的项目\n- 大批量页面渲染，多为静态且页面大，少量的动态数据 \n\n# 缺点\n不适合做cpu密集型的运算，因为会阻塞","slug":"node-node做中间层的好处","published":1,"date":"2017-07-25T03:10:25.000Z","updated":"2017-07-25T03:38:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cck000fkzy68ekbz95r","content":"<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><ul>\n<li>一个Server端可以服务于多个Client端（IOS、andriod、Node）</li>\n<li>node层处理业务逻辑，做高层次的抽象，后端提供相关服务，让java端和前端更加解耦</li>\n<li>node方便部署</li>\n</ul>\n<h1 id=\"什么时候选择node作为中间层\"><a href=\"#什么时候选择node作为中间层\" class=\"headerlink\" title=\"什么时候选择node作为中间层\"></a>什么时候选择node作为中间层</h1><ul>\n<li>SPA 项目并有服务端渲染需求的项目</li>\n<li>大批量页面渲染，多为静态且页面大，少量的动态数据 </li>\n</ul>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>不适合做cpu密集型的运算，因为会阻塞</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><ul>\n<li>一个Server端可以服务于多个Client端（IOS、andriod、Node）</li>\n<li>node层处理业务逻辑，做高层次的抽象，后端提供相关服务，让java端和前端更加解耦</li>\n<li>node方便部署</li>\n</ul>\n<h1 id=\"什么时候选择node作为中间层\"><a href=\"#什么时候选择node作为中间层\" class=\"headerlink\" title=\"什么时候选择node作为中间层\"></a>什么时候选择node作为中间层</h1><ul>\n<li>SPA 项目并有服务端渲染需求的项目</li>\n<li>大批量页面渲染，多为静态且页面大，少量的动态数据 </li>\n</ul>\n<h1 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h1><p>不适合做cpu密集型的运算，因为会阻塞</p>\n"},{"title":"promise、co、gennerator、async深入理解","type":"categories","_content":"\n## promise注意要点：\n\n[实践案例移步](https://github.com/wbcz/untils)\n\n## Event Loop Queue(事件循环队列)\n\n```\nsetTimeout(() => {\n  console.log(\"B\");\n}, 1000);\n```\nsetTimeout 延迟 1000 不一定是准确的,因为如果还有其他的任务在前面，它要等待那些任务对应的消息都出队，也就是程序都执行完成，它才能将 callback 放入队列。也就是实际延迟会大于或等于一秒。\n\nEvent Loop Queue中存放的都是消息，每个消息关联着一个函数，JavaScript Engine 就按照队列中的消息顺序执行它们，也就是执行 chunk。\n```\ntry {\n  setTimeout(() => {\n    throw new Error(\"Error - from try statement\");\n  }, 0);\n} catch (e) {\n  console.error(e);\n}\n//try catch 与 setTimeout 不在同一个 chunk，所以捕捉不到错误\n```\n\n```\n//下面的堆栈信息会输出 C - B - A 吗？\nsetTimeout(function A() {\n  setTimeout(function B() {\n    setTimeout(function C() {\n      throw new Error(\"Error - from function C\");\n    }, 0);\n  }, 0);\n}, 0);\n//它们并不对应同一条 Event Loop Queue 中的消息，分别有各自的调用栈，所以错误栈里面只有 C。\n```\n\n## Job Queue\nJob 是 ES6 中新增的概念，它与 Promise 的执行有关，可以理解为等待执行的任务；Job Queue 就是这种类型的任务的队列。JavaScript Runtime 对于 Job Queue 与 Event Loop Queue 的处理有所不同。\n\n相同点:\n- 都用作先进先出队列\n不同点：\n- 每个 JavaScript Runtime 可以有多个 Job Queue，但只有一个 Event Loop Queue\n- 当 JavaScript Engine 处理完当前 chunk 后，优先执行所有的 Job Queue，然后再处理 Event Loop Queue\nES6 中，一个 Promise 就是一个 PromiseJob，一种 Job。\n```\nconsole.log(\"A\");\n\nsetTimeout(() => {\n  console.log(\"A - setTimeout\");\n}, 0);\n\nnew Promise((resolve) => {\n  resolve();\n})\n.then(() => {\n  return console.log(\"A - Promise 1\");\n})\n.then(() => {\n  return console.log(\"B - Promise 1\");\n});\n\nnew Promise((resolve) => {\n  resolve();\n})\n.then(() => {\n  return console.log(\"A - Promise 2\");\n})\n.then(() => {\n  return console.log(\"B - Promise 2\");\n})\n.then(() => {\n  return console.log(\"C - Promise 2\");\n});\n\nconsole.log(\"AA\");\n\n```\n答案：\n```\nA\nAA\nA - Promise 1\nA - Promise 2\nB - Promise 1\nB - Promise 2\nC - Promise 2\nA - setTimeout\n```\n解答：\n- A 与 AA 最先输出，因为它们不是异步任务，属于第一个 chunk。\n\n- Promise 1 与 Promise 2 先于 setTimeout 执行，因为 Job Queue 的执行优先于 Event Loop Queue。\n\n- Promise 1 与 Promise 2 各自的输出都是顺序的，因为 Job Queue 是先进先出队列，同一 Job Queue 中的任务顺序执行。\n\n- Promise 1 与 Promise 2 的后续任务是交错的，因为 Promise 1 与 Promise 2 都是独立的 PromiseJob（job 的其中一种），属于不同的 Job Queue，它们之间的顺序规范中没有规定。\n\n```\n\t1.返回新的回调加return\n\t2.then参数不要传递类似promise.resolve()这样的参数，会被解析为null，尽量采用function() {}的方式返回\n\t3.捕捉错误，用catch，同时catch函数是作为then单独的一个函数，不要then里面包含其他的函数，防止捕捉不到错误\n\t4.多层循环里面的异步中的异步，用co函数和promise配合解决\n```\n#### [async和generator](http://www.ruanyifeng.com/blog/2015/05/async.html)\n\n```\n\t//async并发异步操作\n\tfunction go() {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log('go')\n\t\t},2000)\n\t}\n\n\tfunction go1() {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log('go1')\n\t\t},3000)\n\t}\n\n\tfunction go2() {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log('go2')\n\t\t},1000)\n\t}\n\n\tasync function test() {\n\t  let docs = [go, go1, go2];\n\n\t  for (let doc of docs) {\n\t    await doc();\n\t  }\n\t}\n\n\ttest()\n\n```\n\n```\n\t//co函数的并发操作\n\t\n\tco(function* () {\n\n\t    var res = yield [\n\t    \tPromise.resolve(1),\n\t    \tPromise.resolve(2)\n\t    ];\n\n\t  \tconsole.log(res);\n\n\t}).catch(onerror);\n\n```\n","source":"_posts/node/promise、co、gennerator、async深入理解.md","raw":"---\ntitle: promise、co、gennerator、async深入理解\ntype: \"categories\"\ncategories: 后端\n---\n\n## promise注意要点：\n\n[实践案例移步](https://github.com/wbcz/untils)\n\n## Event Loop Queue(事件循环队列)\n\n```\nsetTimeout(() => {\n  console.log(\"B\");\n}, 1000);\n```\nsetTimeout 延迟 1000 不一定是准确的,因为如果还有其他的任务在前面，它要等待那些任务对应的消息都出队，也就是程序都执行完成，它才能将 callback 放入队列。也就是实际延迟会大于或等于一秒。\n\nEvent Loop Queue中存放的都是消息，每个消息关联着一个函数，JavaScript Engine 就按照队列中的消息顺序执行它们，也就是执行 chunk。\n```\ntry {\n  setTimeout(() => {\n    throw new Error(\"Error - from try statement\");\n  }, 0);\n} catch (e) {\n  console.error(e);\n}\n//try catch 与 setTimeout 不在同一个 chunk，所以捕捉不到错误\n```\n\n```\n//下面的堆栈信息会输出 C - B - A 吗？\nsetTimeout(function A() {\n  setTimeout(function B() {\n    setTimeout(function C() {\n      throw new Error(\"Error - from function C\");\n    }, 0);\n  }, 0);\n}, 0);\n//它们并不对应同一条 Event Loop Queue 中的消息，分别有各自的调用栈，所以错误栈里面只有 C。\n```\n\n## Job Queue\nJob 是 ES6 中新增的概念，它与 Promise 的执行有关，可以理解为等待执行的任务；Job Queue 就是这种类型的任务的队列。JavaScript Runtime 对于 Job Queue 与 Event Loop Queue 的处理有所不同。\n\n相同点:\n- 都用作先进先出队列\n不同点：\n- 每个 JavaScript Runtime 可以有多个 Job Queue，但只有一个 Event Loop Queue\n- 当 JavaScript Engine 处理完当前 chunk 后，优先执行所有的 Job Queue，然后再处理 Event Loop Queue\nES6 中，一个 Promise 就是一个 PromiseJob，一种 Job。\n```\nconsole.log(\"A\");\n\nsetTimeout(() => {\n  console.log(\"A - setTimeout\");\n}, 0);\n\nnew Promise((resolve) => {\n  resolve();\n})\n.then(() => {\n  return console.log(\"A - Promise 1\");\n})\n.then(() => {\n  return console.log(\"B - Promise 1\");\n});\n\nnew Promise((resolve) => {\n  resolve();\n})\n.then(() => {\n  return console.log(\"A - Promise 2\");\n})\n.then(() => {\n  return console.log(\"B - Promise 2\");\n})\n.then(() => {\n  return console.log(\"C - Promise 2\");\n});\n\nconsole.log(\"AA\");\n\n```\n答案：\n```\nA\nAA\nA - Promise 1\nA - Promise 2\nB - Promise 1\nB - Promise 2\nC - Promise 2\nA - setTimeout\n```\n解答：\n- A 与 AA 最先输出，因为它们不是异步任务，属于第一个 chunk。\n\n- Promise 1 与 Promise 2 先于 setTimeout 执行，因为 Job Queue 的执行优先于 Event Loop Queue。\n\n- Promise 1 与 Promise 2 各自的输出都是顺序的，因为 Job Queue 是先进先出队列，同一 Job Queue 中的任务顺序执行。\n\n- Promise 1 与 Promise 2 的后续任务是交错的，因为 Promise 1 与 Promise 2 都是独立的 PromiseJob（job 的其中一种），属于不同的 Job Queue，它们之间的顺序规范中没有规定。\n\n```\n\t1.返回新的回调加return\n\t2.then参数不要传递类似promise.resolve()这样的参数，会被解析为null，尽量采用function() {}的方式返回\n\t3.捕捉错误，用catch，同时catch函数是作为then单独的一个函数，不要then里面包含其他的函数，防止捕捉不到错误\n\t4.多层循环里面的异步中的异步，用co函数和promise配合解决\n```\n#### [async和generator](http://www.ruanyifeng.com/blog/2015/05/async.html)\n\n```\n\t//async并发异步操作\n\tfunction go() {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log('go')\n\t\t},2000)\n\t}\n\n\tfunction go1() {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log('go1')\n\t\t},3000)\n\t}\n\n\tfunction go2() {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log('go2')\n\t\t},1000)\n\t}\n\n\tasync function test() {\n\t  let docs = [go, go1, go2];\n\n\t  for (let doc of docs) {\n\t    await doc();\n\t  }\n\t}\n\n\ttest()\n\n```\n\n```\n\t//co函数的并发操作\n\t\n\tco(function* () {\n\n\t    var res = yield [\n\t    \tPromise.resolve(1),\n\t    \tPromise.resolve(2)\n\t    ];\n\n\t  \tconsole.log(res);\n\n\t}).catch(onerror);\n\n```\n","slug":"node-promise、co、gennerator、async深入理解","published":1,"date":"2017-04-07T03:56:52.000Z","updated":"2017-04-07T03:56:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccm000hkzy6w9rowj69","content":"<h2 id=\"promise注意要点：\"><a href=\"#promise注意要点：\" class=\"headerlink\" title=\"promise注意要点：\"></a>promise注意要点：</h2><p><a href=\"https://github.com/wbcz/untils\" target=\"_blank\" rel=\"external\">实践案例移步</a></p>\n<h2 id=\"Event-Loop-Queue-事件循环队列\"><a href=\"#Event-Loop-Queue-事件循环队列\" class=\"headerlink\" title=\"Event Loop Queue(事件循环队列)\"></a>Event Loop Queue(事件循环队列)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">  console.log(&quot;B&quot;);</div><div class=\"line\">&#125;, 1000);</div></pre></td></tr></table></figure>\n<p>setTimeout 延迟 1000 不一定是准确的,因为如果还有其他的任务在前面，它要等待那些任务对应的消息都出队，也就是程序都执行完成，它才能将 callback 放入队列。也就是实际延迟会大于或等于一秒。</p>\n<p>Event Loop Queue中存放的都是消息，每个消息关联着一个函数，JavaScript Engine 就按照队列中的消息顺序执行它们，也就是执行 chunk。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">  setTimeout(() =&gt; &#123;</div><div class=\"line\">    throw new Error(&quot;Error - from try statement&quot;);</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\">&#125; catch (e) &#123;</div><div class=\"line\">  console.error(e);</div><div class=\"line\">&#125;</div><div class=\"line\">//try catch 与 setTimeout 不在同一个 chunk，所以捕捉不到错误</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//下面的堆栈信息会输出 C - B - A 吗？</div><div class=\"line\">setTimeout(function A() &#123;</div><div class=\"line\">  setTimeout(function B() &#123;</div><div class=\"line\">    setTimeout(function C() &#123;</div><div class=\"line\">      throw new Error(&quot;Error - from function C&quot;);</div><div class=\"line\">    &#125;, 0);</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\">&#125;, 0);</div><div class=\"line\">//它们并不对应同一条 Event Loop Queue 中的消息，分别有各自的调用栈，所以错误栈里面只有 C。</div></pre></td></tr></table></figure>\n<h2 id=\"Job-Queue\"><a href=\"#Job-Queue\" class=\"headerlink\" title=\"Job Queue\"></a>Job Queue</h2><p>Job 是 ES6 中新增的概念，它与 Promise 的执行有关，可以理解为等待执行的任务；Job Queue 就是这种类型的任务的队列。JavaScript Runtime 对于 Job Queue 与 Event Loop Queue 的处理有所不同。</p>\n<p>相同点:</p>\n<ul>\n<li>都用作先进先出队列<br>不同点：</li>\n<li>每个 JavaScript Runtime 可以有多个 Job Queue，但只有一个 Event Loop Queue</li>\n<li>当 JavaScript Engine 处理完当前 chunk 后，优先执行所有的 Job Queue，然后再处理 Event Loop Queue<br>ES6 中，一个 Promise 就是一个 PromiseJob，一种 Job。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(&quot;A&quot;);</div><div class=\"line\"></div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">  console.log(&quot;A - setTimeout&quot;);</div><div class=\"line\">&#125;, 0);</div><div class=\"line\"></div><div class=\"line\">new Promise((resolve) =&gt; &#123;</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;A - Promise 1&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;B - Promise 1&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">new Promise((resolve) =&gt; &#123;</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;A - Promise 2&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;B - Promise 2&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;C - Promise 2&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;AA&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>答案：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">A</div><div class=\"line\">AA</div><div class=\"line\">A - Promise 1</div><div class=\"line\">A - Promise 2</div><div class=\"line\">B - Promise 1</div><div class=\"line\">B - Promise 2</div><div class=\"line\">C - Promise 2</div><div class=\"line\">A - setTimeout</div></pre></td></tr></table></figure></p>\n<p>解答：</p>\n<ul>\n<li><p>A 与 AA 最先输出，因为它们不是异步任务，属于第一个 chunk。</p>\n</li>\n<li><p>Promise 1 与 Promise 2 先于 setTimeout 执行，因为 Job Queue 的执行优先于 Event Loop Queue。</p>\n</li>\n<li><p>Promise 1 与 Promise 2 各自的输出都是顺序的，因为 Job Queue 是先进先出队列，同一 Job Queue 中的任务顺序执行。</p>\n</li>\n<li><p>Promise 1 与 Promise 2 的后续任务是交错的，因为 Promise 1 与 Promise 2 都是独立的 PromiseJob（job 的其中一种），属于不同的 Job Queue，它们之间的顺序规范中没有规定。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.返回新的回调加return</div><div class=\"line\">2.then参数不要传递类似promise.resolve()这样的参数，会被解析为null，尽量采用function() &#123;&#125;的方式返回</div><div class=\"line\">3.捕捉错误，用catch，同时catch函数是作为then单独的一个函数，不要then里面包含其他的函数，防止捕捉不到错误</div><div class=\"line\">4.多层循环里面的异步中的异步，用co函数和promise配合解决</div></pre></td></tr></table></figure>\n<h4 id=\"async和generator\"><a href=\"#async和generator\" class=\"headerlink\" title=\"async和generator\"></a><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"external\">async和generator</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">//async并发异步操作</div><div class=\"line\">function go() &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;go&apos;)</div><div class=\"line\">\t&#125;,2000)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function go1() &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;go1&apos;)</div><div class=\"line\">\t&#125;,3000)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function go2() &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;go2&apos;)</div><div class=\"line\">\t&#125;,1000)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">async function test() &#123;</div><div class=\"line\">  let docs = [go, go1, go2];</div><div class=\"line\"></div><div class=\"line\">  for (let doc of docs) &#123;</div><div class=\"line\">    await doc();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">test()</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//co函数的并发操作</div><div class=\"line\"></div><div class=\"line\">co(function* () &#123;</div><div class=\"line\"></div><div class=\"line\">    var res = yield [</div><div class=\"line\">    \tPromise.resolve(1),</div><div class=\"line\">    \tPromise.resolve(2)</div><div class=\"line\">    ];</div><div class=\"line\"></div><div class=\"line\">  \tconsole.log(res);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(onerror);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"promise注意要点：\"><a href=\"#promise注意要点：\" class=\"headerlink\" title=\"promise注意要点：\"></a>promise注意要点：</h2><p><a href=\"https://github.com/wbcz/untils\" target=\"_blank\" rel=\"external\">实践案例移步</a></p>\n<h2 id=\"Event-Loop-Queue-事件循环队列\"><a href=\"#Event-Loop-Queue-事件循环队列\" class=\"headerlink\" title=\"Event Loop Queue(事件循环队列)\"></a>Event Loop Queue(事件循环队列)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">  console.log(&quot;B&quot;);</div><div class=\"line\">&#125;, 1000);</div></pre></td></tr></table></figure>\n<p>setTimeout 延迟 1000 不一定是准确的,因为如果还有其他的任务在前面，它要等待那些任务对应的消息都出队，也就是程序都执行完成，它才能将 callback 放入队列。也就是实际延迟会大于或等于一秒。</p>\n<p>Event Loop Queue中存放的都是消息，每个消息关联着一个函数，JavaScript Engine 就按照队列中的消息顺序执行它们，也就是执行 chunk。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">  setTimeout(() =&gt; &#123;</div><div class=\"line\">    throw new Error(&quot;Error - from try statement&quot;);</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\">&#125; catch (e) &#123;</div><div class=\"line\">  console.error(e);</div><div class=\"line\">&#125;</div><div class=\"line\">//try catch 与 setTimeout 不在同一个 chunk，所以捕捉不到错误</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//下面的堆栈信息会输出 C - B - A 吗？</div><div class=\"line\">setTimeout(function A() &#123;</div><div class=\"line\">  setTimeout(function B() &#123;</div><div class=\"line\">    setTimeout(function C() &#123;</div><div class=\"line\">      throw new Error(&quot;Error - from function C&quot;);</div><div class=\"line\">    &#125;, 0);</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\">&#125;, 0);</div><div class=\"line\">//它们并不对应同一条 Event Loop Queue 中的消息，分别有各自的调用栈，所以错误栈里面只有 C。</div></pre></td></tr></table></figure>\n<h2 id=\"Job-Queue\"><a href=\"#Job-Queue\" class=\"headerlink\" title=\"Job Queue\"></a>Job Queue</h2><p>Job 是 ES6 中新增的概念，它与 Promise 的执行有关，可以理解为等待执行的任务；Job Queue 就是这种类型的任务的队列。JavaScript Runtime 对于 Job Queue 与 Event Loop Queue 的处理有所不同。</p>\n<p>相同点:</p>\n<ul>\n<li>都用作先进先出队列<br>不同点：</li>\n<li>每个 JavaScript Runtime 可以有多个 Job Queue，但只有一个 Event Loop Queue</li>\n<li>当 JavaScript Engine 处理完当前 chunk 后，优先执行所有的 Job Queue，然后再处理 Event Loop Queue<br>ES6 中，一个 Promise 就是一个 PromiseJob，一种 Job。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(&quot;A&quot;);</div><div class=\"line\"></div><div class=\"line\">setTimeout(() =&gt; &#123;</div><div class=\"line\">  console.log(&quot;A - setTimeout&quot;);</div><div class=\"line\">&#125;, 0);</div><div class=\"line\"></div><div class=\"line\">new Promise((resolve) =&gt; &#123;</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;A - Promise 1&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;B - Promise 1&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">new Promise((resolve) =&gt; &#123;</div><div class=\"line\">  resolve();</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;A - Promise 2&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;B - Promise 2&quot;);</div><div class=\"line\">&#125;)</div><div class=\"line\">.then(() =&gt; &#123;</div><div class=\"line\">  return console.log(&quot;C - Promise 2&quot;);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">console.log(&quot;AA&quot;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>答案：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">A</div><div class=\"line\">AA</div><div class=\"line\">A - Promise 1</div><div class=\"line\">A - Promise 2</div><div class=\"line\">B - Promise 1</div><div class=\"line\">B - Promise 2</div><div class=\"line\">C - Promise 2</div><div class=\"line\">A - setTimeout</div></pre></td></tr></table></figure></p>\n<p>解答：</p>\n<ul>\n<li><p>A 与 AA 最先输出，因为它们不是异步任务，属于第一个 chunk。</p>\n</li>\n<li><p>Promise 1 与 Promise 2 先于 setTimeout 执行，因为 Job Queue 的执行优先于 Event Loop Queue。</p>\n</li>\n<li><p>Promise 1 与 Promise 2 各自的输出都是顺序的，因为 Job Queue 是先进先出队列，同一 Job Queue 中的任务顺序执行。</p>\n</li>\n<li><p>Promise 1 与 Promise 2 的后续任务是交错的，因为 Promise 1 与 Promise 2 都是独立的 PromiseJob（job 的其中一种），属于不同的 Job Queue，它们之间的顺序规范中没有规定。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.返回新的回调加return</div><div class=\"line\">2.then参数不要传递类似promise.resolve()这样的参数，会被解析为null，尽量采用function() &#123;&#125;的方式返回</div><div class=\"line\">3.捕捉错误，用catch，同时catch函数是作为then单独的一个函数，不要then里面包含其他的函数，防止捕捉不到错误</div><div class=\"line\">4.多层循环里面的异步中的异步，用co函数和promise配合解决</div></pre></td></tr></table></figure>\n<h4 id=\"async和generator\"><a href=\"#async和generator\" class=\"headerlink\" title=\"async和generator\"></a><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"external\">async和generator</a></h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">//async并发异步操作</div><div class=\"line\">function go() &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;go&apos;)</div><div class=\"line\">\t&#125;,2000)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function go1() &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;go1&apos;)</div><div class=\"line\">\t&#125;,3000)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function go2() &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;go2&apos;)</div><div class=\"line\">\t&#125;,1000)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">async function test() &#123;</div><div class=\"line\">  let docs = [go, go1, go2];</div><div class=\"line\"></div><div class=\"line\">  for (let doc of docs) &#123;</div><div class=\"line\">    await doc();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">test()</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//co函数的并发操作</div><div class=\"line\"></div><div class=\"line\">co(function* () &#123;</div><div class=\"line\"></div><div class=\"line\">    var res = yield [</div><div class=\"line\">    \tPromise.resolve(1),</div><div class=\"line\">    \tPromise.resolve(2)</div><div class=\"line\">    ];</div><div class=\"line\"></div><div class=\"line\">  \tconsole.log(res);</div><div class=\"line\"></div><div class=\"line\">&#125;).catch(onerror);</div></pre></td></tr></table></figure>\n"},{"title":"stream","type":"categories","_content":"\n## 先来普及一下概念\n\n### 什么是流IO？\n\n> 流是一种抽象概念，它代表了数据的无 结构化传递。 按照流的方式进行输入输出，**数据被当成无结构的字节序或字符序列**。从流中取得数据的操作称为提取操作，而 向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，**IO流就是以流的方式进行输入输出。输入输出（IO）是指计算机同 任何外部设备之间的数据传递**。常见的输入输出设备有文件、键盘、打印机、屏幕等。数据可以按记录（或称数据块）的方式传递，也可以流的方式传递。\n\n\n> 流(stream)的概念源于UNIX中管道(pipe)的概念。在UNIX中，**管道是一条不间断的字节流，用来实现程序或进程间的通信**，或读写外围设备、外部文件等。一 个流，必有源端和目的端，它们可以是计算机内存的某些区域，也可以是磁盘文件，甚至可以是Internet上的某个URL。流的方向是重要的，根据的方 向，流可分为两类：输入流和输出流。\njava中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存流中的称为输入流，将数据从内存写入外存中的称为输出流。读==》输入，写==》输出\n\n\n### 数据流概念\n\n> 是处理系统缓存的一种方式。操作系统采用数据块（chunk)的方式读取数据，每接收一次数据，就存入缓存。\n\n#### 处理缓存的两种方式\n> 数据全部接收，读入内存，一次性读取\n> 边读边接收\n\n#### 特点\n> 通过事件通信，具有readable、writable、drain、data、end、close等事件，既可以读取数据，也可以写入数据。\n读写数据时，每读入（或写入）一段数据，就会触发一次data事件，全部读取（或写入）完毕，触发end事件。如果发生错误，则触发error事件\n\n### Stream接口三类\n> 可读数据流接口，用于对外提供数据。\n> 可写数据流接口，用于写入数据。\n> 双向数据流接口，用于读取和写入数据，比如Node的tcp sockets、zlib、crypto都部署了这个接口。\n\n#### 哪些对象部署了Stream接口\n> 文件读写\n> HTTP请求读写\n> TCP的连接\n> 标准的输入输出\n\n### 可读数据流\n> 数据的来源\n```\nvar Readable = require('stream').Readable;\n\nvar rs = new Readable();\nrs.push('beep ');\nrs.push('boop\\n');\nrs.push(null);\n\nrs.pipe(process.stdout);\n//可读数据流的push方法，用来将数据输入缓存\n//rs.push(null)中的null，用来告诉rs，数据输入完毕。\n```\n\n#### 可读数据流状态\n> 流动态和暂停态，流动态的时候才能读取数据，如果处于暂停态，需要显示调用stream.read(),转换成流动态\n\n#### 暂停转流动态\n\n> 添加data事件的监听函数\n> 添加resume方法\n> 调用pipe方法将数据送往一个可写的数据流\n\n#### 流动转为暂停态\n> 不存在pipe方法的目的地时，调用pause方法\n> 存在pipe方法的目的地时，移除所有data事件的监听函数，并且调用uppipe方法，移除目的地\n\n注意，只移除data事件的监听函数，并不会自动引发数据流进入“暂停态”。\n另外，存在pipe方法的目的地时，调用pause方法，并不能保证数据流总是处于暂停态，一旦那些目的地发出数据请求，数据流有可能会继续提供数据。\n每当系统有新的数据，该接口可以监听到data事件，从而回调函数\n\n```\nvar fs = require('fs');\nvar readableStream = fs.createReadStream('file.txt');\nvar data = '';\n\nreadableStream.setEncoding('utf8');\n\nreadableStream.on('data', function(chunk) {\n  data+=chunk;\n});\n\nreadableStream.on('end', function() {\n  console.log(data);\n});\n```\n上面代码中，fs模块的createReadStream方法，是部署了Stream接口的文件读取方法。该方法对指定的文件，返回一个对象。该对象只要监听data事件，回调函数就能读到数据。\n\n除了data事件，监听readable事件，也可以读到数据。\n\n```\nvar fs = require('fs');\nvar readableStream = fs.createReadStream('file.txt');\nvar data = '';\nvar chunk;\n\nreadableStream.setEncoding('utf8');\n\nreadableStream.on('readable', function() {\n  while ((chunk=readableStream.read()) !== null) {\n    data += chunk;\n  }\n});\n\nreadableStream.on('end', function() {\n  console.log(data)\n});\n```\nreadable事件表示系统缓冲之中有可读的数据，使用read方法去读出数据。如果没有数据可读，read方法会返回null。\n\n> Readable.pause() ：暂停数据流。已经存在的数据，也不再触发data事件，数据将保留在缓存之中，此时的数据流称为静态数据流。如果对静态数据流再次调用pause方法，数据流将重新开始流动，但是缓存中现有的数据，不会再触发data事件。\n> Readable.resume()：恢复暂停的数据流。\n> Readable.unpipe()：从管道中移除目的地数据流。如果该方法使用时带有参数，会阻止“可读数据流”进入某个特定的目的地数据流。如果使用时不带有参数，则会移除所有的目的地数据流。\n\n### 总结\n> 想要读取数据，需要实现stream的接口\n> 读取数据的流程是先把数据读到缓存，并且让可读数据流是流动态\n> 用事件来监听并且导入数据\n","source":"_posts/node/stream接口.md","raw":"---\ntitle: stream\ntype: \"categories\"\ncategories: 后端\n---\n\n## 先来普及一下概念\n\n### 什么是流IO？\n\n> 流是一种抽象概念，它代表了数据的无 结构化传递。 按照流的方式进行输入输出，**数据被当成无结构的字节序或字符序列**。从流中取得数据的操作称为提取操作，而 向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，**IO流就是以流的方式进行输入输出。输入输出（IO）是指计算机同 任何外部设备之间的数据传递**。常见的输入输出设备有文件、键盘、打印机、屏幕等。数据可以按记录（或称数据块）的方式传递，也可以流的方式传递。\n\n\n> 流(stream)的概念源于UNIX中管道(pipe)的概念。在UNIX中，**管道是一条不间断的字节流，用来实现程序或进程间的通信**，或读写外围设备、外部文件等。一 个流，必有源端和目的端，它们可以是计算机内存的某些区域，也可以是磁盘文件，甚至可以是Internet上的某个URL。流的方向是重要的，根据的方 向，流可分为两类：输入流和输出流。\njava中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存流中的称为输入流，将数据从内存写入外存中的称为输出流。读==》输入，写==》输出\n\n\n### 数据流概念\n\n> 是处理系统缓存的一种方式。操作系统采用数据块（chunk)的方式读取数据，每接收一次数据，就存入缓存。\n\n#### 处理缓存的两种方式\n> 数据全部接收，读入内存，一次性读取\n> 边读边接收\n\n#### 特点\n> 通过事件通信，具有readable、writable、drain、data、end、close等事件，既可以读取数据，也可以写入数据。\n读写数据时，每读入（或写入）一段数据，就会触发一次data事件，全部读取（或写入）完毕，触发end事件。如果发生错误，则触发error事件\n\n### Stream接口三类\n> 可读数据流接口，用于对外提供数据。\n> 可写数据流接口，用于写入数据。\n> 双向数据流接口，用于读取和写入数据，比如Node的tcp sockets、zlib、crypto都部署了这个接口。\n\n#### 哪些对象部署了Stream接口\n> 文件读写\n> HTTP请求读写\n> TCP的连接\n> 标准的输入输出\n\n### 可读数据流\n> 数据的来源\n```\nvar Readable = require('stream').Readable;\n\nvar rs = new Readable();\nrs.push('beep ');\nrs.push('boop\\n');\nrs.push(null);\n\nrs.pipe(process.stdout);\n//可读数据流的push方法，用来将数据输入缓存\n//rs.push(null)中的null，用来告诉rs，数据输入完毕。\n```\n\n#### 可读数据流状态\n> 流动态和暂停态，流动态的时候才能读取数据，如果处于暂停态，需要显示调用stream.read(),转换成流动态\n\n#### 暂停转流动态\n\n> 添加data事件的监听函数\n> 添加resume方法\n> 调用pipe方法将数据送往一个可写的数据流\n\n#### 流动转为暂停态\n> 不存在pipe方法的目的地时，调用pause方法\n> 存在pipe方法的目的地时，移除所有data事件的监听函数，并且调用uppipe方法，移除目的地\n\n注意，只移除data事件的监听函数，并不会自动引发数据流进入“暂停态”。\n另外，存在pipe方法的目的地时，调用pause方法，并不能保证数据流总是处于暂停态，一旦那些目的地发出数据请求，数据流有可能会继续提供数据。\n每当系统有新的数据，该接口可以监听到data事件，从而回调函数\n\n```\nvar fs = require('fs');\nvar readableStream = fs.createReadStream('file.txt');\nvar data = '';\n\nreadableStream.setEncoding('utf8');\n\nreadableStream.on('data', function(chunk) {\n  data+=chunk;\n});\n\nreadableStream.on('end', function() {\n  console.log(data);\n});\n```\n上面代码中，fs模块的createReadStream方法，是部署了Stream接口的文件读取方法。该方法对指定的文件，返回一个对象。该对象只要监听data事件，回调函数就能读到数据。\n\n除了data事件，监听readable事件，也可以读到数据。\n\n```\nvar fs = require('fs');\nvar readableStream = fs.createReadStream('file.txt');\nvar data = '';\nvar chunk;\n\nreadableStream.setEncoding('utf8');\n\nreadableStream.on('readable', function() {\n  while ((chunk=readableStream.read()) !== null) {\n    data += chunk;\n  }\n});\n\nreadableStream.on('end', function() {\n  console.log(data)\n});\n```\nreadable事件表示系统缓冲之中有可读的数据，使用read方法去读出数据。如果没有数据可读，read方法会返回null。\n\n> Readable.pause() ：暂停数据流。已经存在的数据，也不再触发data事件，数据将保留在缓存之中，此时的数据流称为静态数据流。如果对静态数据流再次调用pause方法，数据流将重新开始流动，但是缓存中现有的数据，不会再触发data事件。\n> Readable.resume()：恢复暂停的数据流。\n> Readable.unpipe()：从管道中移除目的地数据流。如果该方法使用时带有参数，会阻止“可读数据流”进入某个特定的目的地数据流。如果使用时不带有参数，则会移除所有的目的地数据流。\n\n### 总结\n> 想要读取数据，需要实现stream的接口\n> 读取数据的流程是先把数据读到缓存，并且让可读数据流是流动态\n> 用事件来监听并且导入数据\n","slug":"node-stream接口","published":1,"date":"2017-03-02T08:35:16.000Z","updated":"2017-03-02T08:35:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccn000ikzy6986ld3z1","content":"<h2 id=\"先来普及一下概念\"><a href=\"#先来普及一下概念\" class=\"headerlink\" title=\"先来普及一下概念\"></a>先来普及一下概念</h2><h3 id=\"什么是流IO？\"><a href=\"#什么是流IO？\" class=\"headerlink\" title=\"什么是流IO？\"></a>什么是流IO？</h3><blockquote>\n<p>流是一种抽象概念，它代表了数据的无 结构化传递。 按照流的方式进行输入输出，<strong>数据被当成无结构的字节序或字符序列</strong>。从流中取得数据的操作称为提取操作，而 向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，<strong>IO流就是以流的方式进行输入输出。输入输出（IO）是指计算机同 任何外部设备之间的数据传递</strong>。常见的输入输出设备有文件、键盘、打印机、屏幕等。数据可以按记录（或称数据块）的方式传递，也可以流的方式传递。</p>\n<p>流(stream)的概念源于UNIX中管道(pipe)的概念。在UNIX中，<strong>管道是一条不间断的字节流，用来实现程序或进程间的通信</strong>，或读写外围设备、外部文件等。一 个流，必有源端和目的端，它们可以是计算机内存的某些区域，也可以是磁盘文件，甚至可以是Internet上的某个URL。流的方向是重要的，根据的方 向，流可分为两类：输入流和输出流。<br>java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存流中的称为输入流，将数据从内存写入外存中的称为输出流。读==》输入，写==》输出</p>\n</blockquote>\n<h3 id=\"数据流概念\"><a href=\"#数据流概念\" class=\"headerlink\" title=\"数据流概念\"></a>数据流概念</h3><blockquote>\n<p>是处理系统缓存的一种方式。操作系统采用数据块（chunk)的方式读取数据，每接收一次数据，就存入缓存。</p>\n</blockquote>\n<h4 id=\"处理缓存的两种方式\"><a href=\"#处理缓存的两种方式\" class=\"headerlink\" title=\"处理缓存的两种方式\"></a>处理缓存的两种方式</h4><blockquote>\n<p>数据全部接收，读入内存，一次性读取<br>边读边接收</p>\n</blockquote>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><blockquote>\n<p>通过事件通信，具有readable、writable、drain、data、end、close等事件，既可以读取数据，也可以写入数据。<br>读写数据时，每读入（或写入）一段数据，就会触发一次data事件，全部读取（或写入）完毕，触发end事件。如果发生错误，则触发error事件</p>\n</blockquote>\n<h3 id=\"Stream接口三类\"><a href=\"#Stream接口三类\" class=\"headerlink\" title=\"Stream接口三类\"></a>Stream接口三类</h3><blockquote>\n<p>可读数据流接口，用于对外提供数据。<br>可写数据流接口，用于写入数据。<br>双向数据流接口，用于读取和写入数据，比如Node的tcp sockets、zlib、crypto都部署了这个接口。</p>\n</blockquote>\n<h4 id=\"哪些对象部署了Stream接口\"><a href=\"#哪些对象部署了Stream接口\" class=\"headerlink\" title=\"哪些对象部署了Stream接口\"></a>哪些对象部署了Stream接口</h4><blockquote>\n<p>文件读写<br>HTTP请求读写<br>TCP的连接<br>标准的输入输出</p>\n</blockquote>\n<h3 id=\"可读数据流\"><a href=\"#可读数据流\" class=\"headerlink\" title=\"可读数据流\"></a>可读数据流</h3><blockquote>\n<p>数据的来源<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Readable = require(&apos;stream&apos;).Readable;</div><div class=\"line\"></div><div class=\"line\">var rs = new Readable();</div><div class=\"line\">rs.push(&apos;beep &apos;);</div><div class=\"line\">rs.push(&apos;boop\\n&apos;);</div><div class=\"line\">rs.push(null);</div><div class=\"line\"></div><div class=\"line\">rs.pipe(process.stdout);</div><div class=\"line\">//可读数据流的push方法，用来将数据输入缓存</div><div class=\"line\">//rs.push(null)中的null，用来告诉rs，数据输入完毕。</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"可读数据流状态\"><a href=\"#可读数据流状态\" class=\"headerlink\" title=\"可读数据流状态\"></a>可读数据流状态</h4><blockquote>\n<p>流动态和暂停态，流动态的时候才能读取数据，如果处于暂停态，需要显示调用stream.read(),转换成流动态</p>\n</blockquote>\n<h4 id=\"暂停转流动态\"><a href=\"#暂停转流动态\" class=\"headerlink\" title=\"暂停转流动态\"></a>暂停转流动态</h4><blockquote>\n<p>添加data事件的监听函数<br>添加resume方法<br>调用pipe方法将数据送往一个可写的数据流</p>\n</blockquote>\n<h4 id=\"流动转为暂停态\"><a href=\"#流动转为暂停态\" class=\"headerlink\" title=\"流动转为暂停态\"></a>流动转为暂停态</h4><blockquote>\n<p>不存在pipe方法的目的地时，调用pause方法<br>存在pipe方法的目的地时，移除所有data事件的监听函数，并且调用uppipe方法，移除目的地</p>\n</blockquote>\n<p>注意，只移除data事件的监听函数，并不会自动引发数据流进入“暂停态”。<br>另外，存在pipe方法的目的地时，调用pause方法，并不能保证数据流总是处于暂停态，一旦那些目的地发出数据请求，数据流有可能会继续提供数据。<br>每当系统有新的数据，该接口可以监听到data事件，从而回调函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\">var readableStream = fs.createReadStream(&apos;file.txt&apos;);</div><div class=\"line\">var data = &apos;&apos;;</div><div class=\"line\"></div><div class=\"line\">readableStream.setEncoding(&apos;utf8&apos;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;data&apos;, function(chunk) &#123;</div><div class=\"line\">  data+=chunk;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;end&apos;, function() &#123;</div><div class=\"line\">  console.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码中，fs模块的createReadStream方法，是部署了Stream接口的文件读取方法。该方法对指定的文件，返回一个对象。该对象只要监听data事件，回调函数就能读到数据。</p>\n<p>除了data事件，监听readable事件，也可以读到数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\">var readableStream = fs.createReadStream(&apos;file.txt&apos;);</div><div class=\"line\">var data = &apos;&apos;;</div><div class=\"line\">var chunk;</div><div class=\"line\"></div><div class=\"line\">readableStream.setEncoding(&apos;utf8&apos;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;readable&apos;, function() &#123;</div><div class=\"line\">  while ((chunk=readableStream.read()) !== null) &#123;</div><div class=\"line\">    data += chunk;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;end&apos;, function() &#123;</div><div class=\"line\">  console.log(data)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>readable事件表示系统缓冲之中有可读的数据，使用read方法去读出数据。如果没有数据可读，read方法会返回null。</p>\n<blockquote>\n<p>Readable.pause() ：暂停数据流。已经存在的数据，也不再触发data事件，数据将保留在缓存之中，此时的数据流称为静态数据流。如果对静态数据流再次调用pause方法，数据流将重新开始流动，但是缓存中现有的数据，不会再触发data事件。<br>Readable.resume()：恢复暂停的数据流。<br>Readable.unpipe()：从管道中移除目的地数据流。如果该方法使用时带有参数，会阻止“可读数据流”进入某个特定的目的地数据流。如果使用时不带有参数，则会移除所有的目的地数据流。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>想要读取数据，需要实现stream的接口<br>读取数据的流程是先把数据读到缓存，并且让可读数据流是流动态<br>用事件来监听并且导入数据</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"先来普及一下概念\"><a href=\"#先来普及一下概念\" class=\"headerlink\" title=\"先来普及一下概念\"></a>先来普及一下概念</h2><h3 id=\"什么是流IO？\"><a href=\"#什么是流IO？\" class=\"headerlink\" title=\"什么是流IO？\"></a>什么是流IO？</h3><blockquote>\n<p>流是一种抽象概念，它代表了数据的无 结构化传递。 按照流的方式进行输入输出，<strong>数据被当成无结构的字节序或字符序列</strong>。从流中取得数据的操作称为提取操作，而 向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，<strong>IO流就是以流的方式进行输入输出。输入输出（IO）是指计算机同 任何外部设备之间的数据传递</strong>。常见的输入输出设备有文件、键盘、打印机、屏幕等。数据可以按记录（或称数据块）的方式传递，也可以流的方式传递。</p>\n<p>流(stream)的概念源于UNIX中管道(pipe)的概念。在UNIX中，<strong>管道是一条不间断的字节流，用来实现程序或进程间的通信</strong>，或读写外围设备、外部文件等。一 个流，必有源端和目的端，它们可以是计算机内存的某些区域，也可以是磁盘文件，甚至可以是Internet上的某个URL。流的方向是重要的，根据的方 向，流可分为两类：输入流和输出流。<br>java中将输入输出抽象称为流，就好像水管，将两个容器连接起来。将数据冲外存中读取到内存流中的称为输入流，将数据从内存写入外存中的称为输出流。读==》输入，写==》输出</p>\n</blockquote>\n<h3 id=\"数据流概念\"><a href=\"#数据流概念\" class=\"headerlink\" title=\"数据流概念\"></a>数据流概念</h3><blockquote>\n<p>是处理系统缓存的一种方式。操作系统采用数据块（chunk)的方式读取数据，每接收一次数据，就存入缓存。</p>\n</blockquote>\n<h4 id=\"处理缓存的两种方式\"><a href=\"#处理缓存的两种方式\" class=\"headerlink\" title=\"处理缓存的两种方式\"></a>处理缓存的两种方式</h4><blockquote>\n<p>数据全部接收，读入内存，一次性读取<br>边读边接收</p>\n</blockquote>\n<h4 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h4><blockquote>\n<p>通过事件通信，具有readable、writable、drain、data、end、close等事件，既可以读取数据，也可以写入数据。<br>读写数据时，每读入（或写入）一段数据，就会触发一次data事件，全部读取（或写入）完毕，触发end事件。如果发生错误，则触发error事件</p>\n</blockquote>\n<h3 id=\"Stream接口三类\"><a href=\"#Stream接口三类\" class=\"headerlink\" title=\"Stream接口三类\"></a>Stream接口三类</h3><blockquote>\n<p>可读数据流接口，用于对外提供数据。<br>可写数据流接口，用于写入数据。<br>双向数据流接口，用于读取和写入数据，比如Node的tcp sockets、zlib、crypto都部署了这个接口。</p>\n</blockquote>\n<h4 id=\"哪些对象部署了Stream接口\"><a href=\"#哪些对象部署了Stream接口\" class=\"headerlink\" title=\"哪些对象部署了Stream接口\"></a>哪些对象部署了Stream接口</h4><blockquote>\n<p>文件读写<br>HTTP请求读写<br>TCP的连接<br>标准的输入输出</p>\n</blockquote>\n<h3 id=\"可读数据流\"><a href=\"#可读数据流\" class=\"headerlink\" title=\"可读数据流\"></a>可读数据流</h3><blockquote>\n<p>数据的来源<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var Readable = require(&apos;stream&apos;).Readable;</div><div class=\"line\"></div><div class=\"line\">var rs = new Readable();</div><div class=\"line\">rs.push(&apos;beep &apos;);</div><div class=\"line\">rs.push(&apos;boop\\n&apos;);</div><div class=\"line\">rs.push(null);</div><div class=\"line\"></div><div class=\"line\">rs.pipe(process.stdout);</div><div class=\"line\">//可读数据流的push方法，用来将数据输入缓存</div><div class=\"line\">//rs.push(null)中的null，用来告诉rs，数据输入完毕。</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"可读数据流状态\"><a href=\"#可读数据流状态\" class=\"headerlink\" title=\"可读数据流状态\"></a>可读数据流状态</h4><blockquote>\n<p>流动态和暂停态，流动态的时候才能读取数据，如果处于暂停态，需要显示调用stream.read(),转换成流动态</p>\n</blockquote>\n<h4 id=\"暂停转流动态\"><a href=\"#暂停转流动态\" class=\"headerlink\" title=\"暂停转流动态\"></a>暂停转流动态</h4><blockquote>\n<p>添加data事件的监听函数<br>添加resume方法<br>调用pipe方法将数据送往一个可写的数据流</p>\n</blockquote>\n<h4 id=\"流动转为暂停态\"><a href=\"#流动转为暂停态\" class=\"headerlink\" title=\"流动转为暂停态\"></a>流动转为暂停态</h4><blockquote>\n<p>不存在pipe方法的目的地时，调用pause方法<br>存在pipe方法的目的地时，移除所有data事件的监听函数，并且调用uppipe方法，移除目的地</p>\n</blockquote>\n<p>注意，只移除data事件的监听函数，并不会自动引发数据流进入“暂停态”。<br>另外，存在pipe方法的目的地时，调用pause方法，并不能保证数据流总是处于暂停态，一旦那些目的地发出数据请求，数据流有可能会继续提供数据。<br>每当系统有新的数据，该接口可以监听到data事件，从而回调函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\">var readableStream = fs.createReadStream(&apos;file.txt&apos;);</div><div class=\"line\">var data = &apos;&apos;;</div><div class=\"line\"></div><div class=\"line\">readableStream.setEncoding(&apos;utf8&apos;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;data&apos;, function(chunk) &#123;</div><div class=\"line\">  data+=chunk;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;end&apos;, function() &#123;</div><div class=\"line\">  console.log(data);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>上面代码中，fs模块的createReadStream方法，是部署了Stream接口的文件读取方法。该方法对指定的文件，返回一个对象。该对象只要监听data事件，回调函数就能读到数据。</p>\n<p>除了data事件，监听readable事件，也可以读到数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">var fs = require(&apos;fs&apos;);</div><div class=\"line\">var readableStream = fs.createReadStream(&apos;file.txt&apos;);</div><div class=\"line\">var data = &apos;&apos;;</div><div class=\"line\">var chunk;</div><div class=\"line\"></div><div class=\"line\">readableStream.setEncoding(&apos;utf8&apos;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;readable&apos;, function() &#123;</div><div class=\"line\">  while ((chunk=readableStream.read()) !== null) &#123;</div><div class=\"line\">    data += chunk;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">readableStream.on(&apos;end&apos;, function() &#123;</div><div class=\"line\">  console.log(data)</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>readable事件表示系统缓冲之中有可读的数据，使用read方法去读出数据。如果没有数据可读，read方法会返回null。</p>\n<blockquote>\n<p>Readable.pause() ：暂停数据流。已经存在的数据，也不再触发data事件，数据将保留在缓存之中，此时的数据流称为静态数据流。如果对静态数据流再次调用pause方法，数据流将重新开始流动，但是缓存中现有的数据，不会再触发data事件。<br>Readable.resume()：恢复暂停的数据流。<br>Readable.unpipe()：从管道中移除目的地数据流。如果该方法使用时带有参数，会阻止“可读数据流”进入某个特定的目的地数据流。如果使用时不带有参数，则会移除所有的目的地数据流。</p>\n</blockquote>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>想要读取数据，需要实现stream的接口<br>读取数据的流程是先把数据读到缓存，并且让可读数据流是流动态<br>用事件来监听并且导入数据</p>\n</blockquote>\n"},{"title":"内存指标","type":"categories","_content":"\n# 内存指标\n\n## 查看内存使用情况\nprocess.memoryUsage()可以看到node进程的内存占用情况，不过你也可以用os模块中的totalmem()和freemem()方法查看内存使用情况\n- rss （resident set size) 进程的常驻内存部分，进程的内存总共有几部分，一部分rss，其余部分在交换区（swap)或者文件系统（filesystem）中\n- heaptotal 堆中总申请的内存量\n- heapUsed 目前堆中使用的内存量\n以上三个单位为字节\n\n## 查看系统的内存占用\nos与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个是查看操作系统的内存使用情况，他们分别返回系统的总内存和闲置内存，以字节为单位。\n\n## 堆外内存\n由process.memoryUsage()结果看出，堆的内存总量总是小于进程常驻内存的总量，这意味着node中的内存使用并非都是通过V8进行分配的，我们将那些不是通过V8分配的内存称为**堆外内存**。\nbut堆外内存可以突破内存限制的问题，为何Buffer对象并非通过V8分配，这在于Node并不同与浏览器场景，在浏览器中，javascript直接处理字符串即可满足大多需求，而Node则需要处理网络流和文件I/O流，操作字符串不能满足传输的性能需求\n","source":"_posts/node/内存指标.md","raw":"---\ntitle: 内存指标\ntype: \"categories\"\ncategories: 后端\n---\n\n# 内存指标\n\n## 查看内存使用情况\nprocess.memoryUsage()可以看到node进程的内存占用情况，不过你也可以用os模块中的totalmem()和freemem()方法查看内存使用情况\n- rss （resident set size) 进程的常驻内存部分，进程的内存总共有几部分，一部分rss，其余部分在交换区（swap)或者文件系统（filesystem）中\n- heaptotal 堆中总申请的内存量\n- heapUsed 目前堆中使用的内存量\n以上三个单位为字节\n\n## 查看系统的内存占用\nos与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个是查看操作系统的内存使用情况，他们分别返回系统的总内存和闲置内存，以字节为单位。\n\n## 堆外内存\n由process.memoryUsage()结果看出，堆的内存总量总是小于进程常驻内存的总量，这意味着node中的内存使用并非都是通过V8进行分配的，我们将那些不是通过V8分配的内存称为**堆外内存**。\nbut堆外内存可以突破内存限制的问题，为何Buffer对象并非通过V8分配，这在于Node并不同与浏览器场景，在浏览器中，javascript直接处理字符串即可满足大多需求，而Node则需要处理网络流和文件I/O流，操作字符串不能满足传输的性能需求\n","slug":"node-内存指标","published":1,"date":"2017-07-25T02:41:31.000Z","updated":"2017-07-25T02:41:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cco000lkzy6k63e87s6","content":"<h1 id=\"内存指标\"><a href=\"#内存指标\" class=\"headerlink\" title=\"内存指标\"></a>内存指标</h1><h2 id=\"查看内存使用情况\"><a href=\"#查看内存使用情况\" class=\"headerlink\" title=\"查看内存使用情况\"></a>查看内存使用情况</h2><p>process.memoryUsage()可以看到node进程的内存占用情况，不过你也可以用os模块中的totalmem()和freemem()方法查看内存使用情况</p>\n<ul>\n<li>rss （resident set size) 进程的常驻内存部分，进程的内存总共有几部分，一部分rss，其余部分在交换区（swap)或者文件系统（filesystem）中</li>\n<li>heaptotal 堆中总申请的内存量</li>\n<li>heapUsed 目前堆中使用的内存量<br>以上三个单位为字节</li>\n</ul>\n<h2 id=\"查看系统的内存占用\"><a href=\"#查看系统的内存占用\" class=\"headerlink\" title=\"查看系统的内存占用\"></a>查看系统的内存占用</h2><p>os与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个是查看操作系统的内存使用情况，他们分别返回系统的总内存和闲置内存，以字节为单位。</p>\n<h2 id=\"堆外内存\"><a href=\"#堆外内存\" class=\"headerlink\" title=\"堆外内存\"></a>堆外内存</h2><p>由process.memoryUsage()结果看出，堆的内存总量总是小于进程常驻内存的总量，这意味着node中的内存使用并非都是通过V8进行分配的，我们将那些不是通过V8分配的内存称为<strong>堆外内存</strong>。<br>but堆外内存可以突破内存限制的问题，为何Buffer对象并非通过V8分配，这在于Node并不同与浏览器场景，在浏览器中，javascript直接处理字符串即可满足大多需求，而Node则需要处理网络流和文件I/O流，操作字符串不能满足传输的性能需求</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内存指标\"><a href=\"#内存指标\" class=\"headerlink\" title=\"内存指标\"></a>内存指标</h1><h2 id=\"查看内存使用情况\"><a href=\"#查看内存使用情况\" class=\"headerlink\" title=\"查看内存使用情况\"></a>查看内存使用情况</h2><p>process.memoryUsage()可以看到node进程的内存占用情况，不过你也可以用os模块中的totalmem()和freemem()方法查看内存使用情况</p>\n<ul>\n<li>rss （resident set size) 进程的常驻内存部分，进程的内存总共有几部分，一部分rss，其余部分在交换区（swap)或者文件系统（filesystem）中</li>\n<li>heaptotal 堆中总申请的内存量</li>\n<li>heapUsed 目前堆中使用的内存量<br>以上三个单位为字节</li>\n</ul>\n<h2 id=\"查看系统的内存占用\"><a href=\"#查看系统的内存占用\" class=\"headerlink\" title=\"查看系统的内存占用\"></a>查看系统的内存占用</h2><p>os与process.memoryUsage()不同的是，os模块中的totalmem()和freemem()这两个是查看操作系统的内存使用情况，他们分别返回系统的总内存和闲置内存，以字节为单位。</p>\n<h2 id=\"堆外内存\"><a href=\"#堆外内存\" class=\"headerlink\" title=\"堆外内存\"></a>堆外内存</h2><p>由process.memoryUsage()结果看出，堆的内存总量总是小于进程常驻内存的总量，这意味着node中的内存使用并非都是通过V8进行分配的，我们将那些不是通过V8分配的内存称为<strong>堆外内存</strong>。<br>but堆外内存可以突破内存限制的问题，为何Buffer对象并非通过V8分配，这在于Node并不同与浏览器场景，在浏览器中，javascript直接处理字符串即可满足大多需求，而Node则需要处理网络流和文件I/O流，操作字符串不能满足传输的性能需求</p>\n"},{"title":"内存控制","type":"categories","_content":"\n在终端中，内存泄漏只会影响终端用户，由于时间短，进程退出，内存就会释放，几乎没管理内存的必要，但是在服务器端，问题就爆发出来了。\n无阻塞、事件驱动建立的node服务具有内存消耗低，适合处理海量的网络请求\n高效的利用资源（利用cpu和IO、 合理高效的使用内存）-----高性能\n\n\n# V8垃圾回收机制与内存限制\n垃圾回收机制自动对内存进行管理，但是c/c++需要手动,另外，内存管理的好坏对服务构成影响\n## node与v8\nv8虚拟机的横空出世，node以它作为javascript脚本引擎，随着v8的升级，v8能享受到更好的语言特性（ES5,ES6等），但也受到V8一些限制\n\n## V8的内存限制\n其他后端语言内存基本没什么限制，但是在node通过javascript使用内存就会发现只能使用部分内存（64位系统约1.4G，32位约0.7G),所以node不能直接操作大内存对象，比如无法将2G内存的文件读入内存进行字符串处理，即使物理内存有32G，所以在单个node进程下，计算机的内存资源无法得到充足的利用\nwhy？ 主要是因为node基于V8构建，所以Node使用js对象的过程中都是通过V8自己的方式来分配管理的。V8这套内存管理机制在浏览器应用使用绰绰有余。所以合理使用内存很有必要\n\n## V8的内存分配\n在V8中所有js对象都是通过**堆**进行分配的，node提供了V8内存使用量的查看方式 process.memoryUsage(),问题来了，V8为什么要限制堆的大小呢？ps:1.5G的垃圾回收堆，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至达到1s以上，引起js线程暂停执行时间，性能和响应能力直线下降，所以限制堆内存成了当时一个好的选择。\n当然也可以打开这种限制，但是V8初始化一旦生效，不能动态改变\n\n## V8的垃圾回收机制\n### V8垃圾回收机制的算法\nV8的策略是基于**分代式**垃圾回收机制，任何一种垃圾回收算法不能胜任所有场景，因为对象的生存周期长短不一，不同的算法只能针对特定的情况具有最好的结果。现代垃圾回收机制算法中按**对象的存活时间**将内存的垃圾回收进行不同的分代，不同的分代的内存使用更高效的算法\n#### V8的内存分代\nV8中，内存由新生代（对象存活时间短）和老生代（存活时间长）组成\n\n#### Scavenge算法\n新生代中的对象主要通过Scavenge算法进行垃圾回收，在Scavenge具体实现中，采用了Cheney算法（采用复制的方式实现垃圾回收算法），新生代生存空间： From 和 To， 堆由 From 和 To 和老生代组成\n当一个对象经过多次复制依然存活，他将会被认为生命周期较长的现象，之后会被移到老生代中，用新的算法处理，这个过程称为**晋升**\n晋升需要的条件：\n- 对象是否被Scavenge回收\n默认情况下，V8的对象分配主要集中在From中，对象从From空间中复制到To的过程中会检查他的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果没，复制到To中，有，则将改对象复制到老生代空间中\n- To空间的占用比超过限制\n如果To空间使用超过了25%，则晋升到老生代空间中，why 25% ？如果占比过高， 会影响后续的内存分配\n\n#### Mark-Sweep & Mark-Compact\nMark-Sweep是标记清除和Mark-Compact结合，用于老生代垃圾回收，why not use Scavenge for old space?因为老生代中的对象存活对象多，scavenge的方式会存在，复制存活对象的效率将会降低；另一个问题依然是浪费一半空间的问题，这样导致了应对生命周期较长的对象时scavenge显得捉襟见肘！\nMark-Sweep在标记遍历堆中所有的对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清除死亡的对象，活着的对象呢在新生代中少， 死亡的对象呢在老生代中也少，这是这样处理高效的原因。\nMark-Sweep最大的问题在于进行一次标记清除回收后，内存空间会存在不连续的状态，这种内存碎片会对后续的内存分配造成问题，因此如果很可能出现分配一个大对象的情况这时所有的碎片空间无法完成此次分配，就会提前触发垃圾回收，而这个垃圾回收是没必要的。\n所以Mark-Compact应运而生，标记整理出来了，它的原理就是把活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n这三种算法在速度、空间开销、是否移动对象可以做个对比\n\n#### Incremental Marking\n为避免Javascript应用逻辑与垃圾回收器看到不一致的情况，垃圾回收的三种算法都需要将应用逻辑暂停下来，等执行完垃圾回收再恢复应用逻辑，这种行为被称为“停顿”，在V8的分代式垃圾回收中，一次小的垃圾回收只收集新生代，由于新生代默认配置的小，存活对象少，所以即便全停顿影响不大，但是老生代配置得较大，且存活对象多，全堆垃圾回收的标记，清除，整理的动作造成的停顿大。\n怎么办呢？所以V8先从标记阶段下手，将本一口气停顿完的动作改为增量标记，拆分为多个小步，每做完一步让Javascript应用逻辑先执行一会儿，逻辑与标记交替执行。当然后面V8也引入了增量清理（lazy Sweeping)，增量整理(incremental compaction),同时还引入了并行标记和并行清理，进一步利用多核降低每次停顿的时间。\n\n## 查看垃圾回收日志\nnode --trace__gc 可以查看哪些阶段比较耗时\nnode --prof 可以查看V8性能分析数据，比如垃圾回收的时间\n\n","source":"_posts/node/内存控制.md","raw":"---\ntitle: 内存控制\ntype: \"categories\"\ncategories: 后端\n---\n\n在终端中，内存泄漏只会影响终端用户，由于时间短，进程退出，内存就会释放，几乎没管理内存的必要，但是在服务器端，问题就爆发出来了。\n无阻塞、事件驱动建立的node服务具有内存消耗低，适合处理海量的网络请求\n高效的利用资源（利用cpu和IO、 合理高效的使用内存）-----高性能\n\n\n# V8垃圾回收机制与内存限制\n垃圾回收机制自动对内存进行管理，但是c/c++需要手动,另外，内存管理的好坏对服务构成影响\n## node与v8\nv8虚拟机的横空出世，node以它作为javascript脚本引擎，随着v8的升级，v8能享受到更好的语言特性（ES5,ES6等），但也受到V8一些限制\n\n## V8的内存限制\n其他后端语言内存基本没什么限制，但是在node通过javascript使用内存就会发现只能使用部分内存（64位系统约1.4G，32位约0.7G),所以node不能直接操作大内存对象，比如无法将2G内存的文件读入内存进行字符串处理，即使物理内存有32G，所以在单个node进程下，计算机的内存资源无法得到充足的利用\nwhy？ 主要是因为node基于V8构建，所以Node使用js对象的过程中都是通过V8自己的方式来分配管理的。V8这套内存管理机制在浏览器应用使用绰绰有余。所以合理使用内存很有必要\n\n## V8的内存分配\n在V8中所有js对象都是通过**堆**进行分配的，node提供了V8内存使用量的查看方式 process.memoryUsage(),问题来了，V8为什么要限制堆的大小呢？ps:1.5G的垃圾回收堆，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至达到1s以上，引起js线程暂停执行时间，性能和响应能力直线下降，所以限制堆内存成了当时一个好的选择。\n当然也可以打开这种限制，但是V8初始化一旦生效，不能动态改变\n\n## V8的垃圾回收机制\n### V8垃圾回收机制的算法\nV8的策略是基于**分代式**垃圾回收机制，任何一种垃圾回收算法不能胜任所有场景，因为对象的生存周期长短不一，不同的算法只能针对特定的情况具有最好的结果。现代垃圾回收机制算法中按**对象的存活时间**将内存的垃圾回收进行不同的分代，不同的分代的内存使用更高效的算法\n#### V8的内存分代\nV8中，内存由新生代（对象存活时间短）和老生代（存活时间长）组成\n\n#### Scavenge算法\n新生代中的对象主要通过Scavenge算法进行垃圾回收，在Scavenge具体实现中，采用了Cheney算法（采用复制的方式实现垃圾回收算法），新生代生存空间： From 和 To， 堆由 From 和 To 和老生代组成\n当一个对象经过多次复制依然存活，他将会被认为生命周期较长的现象，之后会被移到老生代中，用新的算法处理，这个过程称为**晋升**\n晋升需要的条件：\n- 对象是否被Scavenge回收\n默认情况下，V8的对象分配主要集中在From中，对象从From空间中复制到To的过程中会检查他的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果没，复制到To中，有，则将改对象复制到老生代空间中\n- To空间的占用比超过限制\n如果To空间使用超过了25%，则晋升到老生代空间中，why 25% ？如果占比过高， 会影响后续的内存分配\n\n#### Mark-Sweep & Mark-Compact\nMark-Sweep是标记清除和Mark-Compact结合，用于老生代垃圾回收，why not use Scavenge for old space?因为老生代中的对象存活对象多，scavenge的方式会存在，复制存活对象的效率将会降低；另一个问题依然是浪费一半空间的问题，这样导致了应对生命周期较长的对象时scavenge显得捉襟见肘！\nMark-Sweep在标记遍历堆中所有的对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清除死亡的对象，活着的对象呢在新生代中少， 死亡的对象呢在老生代中也少，这是这样处理高效的原因。\nMark-Sweep最大的问题在于进行一次标记清除回收后，内存空间会存在不连续的状态，这种内存碎片会对后续的内存分配造成问题，因此如果很可能出现分配一个大对象的情况这时所有的碎片空间无法完成此次分配，就会提前触发垃圾回收，而这个垃圾回收是没必要的。\n所以Mark-Compact应运而生，标记整理出来了，它的原理就是把活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。\n这三种算法在速度、空间开销、是否移动对象可以做个对比\n\n#### Incremental Marking\n为避免Javascript应用逻辑与垃圾回收器看到不一致的情况，垃圾回收的三种算法都需要将应用逻辑暂停下来，等执行完垃圾回收再恢复应用逻辑，这种行为被称为“停顿”，在V8的分代式垃圾回收中，一次小的垃圾回收只收集新生代，由于新生代默认配置的小，存活对象少，所以即便全停顿影响不大，但是老生代配置得较大，且存活对象多，全堆垃圾回收的标记，清除，整理的动作造成的停顿大。\n怎么办呢？所以V8先从标记阶段下手，将本一口气停顿完的动作改为增量标记，拆分为多个小步，每做完一步让Javascript应用逻辑先执行一会儿，逻辑与标记交替执行。当然后面V8也引入了增量清理（lazy Sweeping)，增量整理(incremental compaction),同时还引入了并行标记和并行清理，进一步利用多核降低每次停顿的时间。\n\n## 查看垃圾回收日志\nnode --trace__gc 可以查看哪些阶段比较耗时\nnode --prof 可以查看V8性能分析数据，比如垃圾回收的时间\n\n","slug":"node-内存控制","published":1,"date":"2017-07-25T02:41:31.000Z","updated":"2017-07-25T02:41:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccp000mkzy6ang8g8yg","content":"<p>在终端中，内存泄漏只会影响终端用户，由于时间短，进程退出，内存就会释放，几乎没管理内存的必要，但是在服务器端，问题就爆发出来了。<br>无阻塞、事件驱动建立的node服务具有内存消耗低，适合处理海量的网络请求<br>高效的利用资源（利用cpu和IO、 合理高效的使用内存）—–高性能</p>\n<h1 id=\"V8垃圾回收机制与内存限制\"><a href=\"#V8垃圾回收机制与内存限制\" class=\"headerlink\" title=\"V8垃圾回收机制与内存限制\"></a>V8垃圾回收机制与内存限制</h1><p>垃圾回收机制自动对内存进行管理，但是c/c++需要手动,另外，内存管理的好坏对服务构成影响</p>\n<h2 id=\"node与v8\"><a href=\"#node与v8\" class=\"headerlink\" title=\"node与v8\"></a>node与v8</h2><p>v8虚拟机的横空出世，node以它作为javascript脚本引擎，随着v8的升级，v8能享受到更好的语言特性（ES5,ES6等），但也受到V8一些限制</p>\n<h2 id=\"V8的内存限制\"><a href=\"#V8的内存限制\" class=\"headerlink\" title=\"V8的内存限制\"></a>V8的内存限制</h2><p>其他后端语言内存基本没什么限制，但是在node通过javascript使用内存就会发现只能使用部分内存（64位系统约1.4G，32位约0.7G),所以node不能直接操作大内存对象，比如无法将2G内存的文件读入内存进行字符串处理，即使物理内存有32G，所以在单个node进程下，计算机的内存资源无法得到充足的利用<br>why？ 主要是因为node基于V8构建，所以Node使用js对象的过程中都是通过V8自己的方式来分配管理的。V8这套内存管理机制在浏览器应用使用绰绰有余。所以合理使用内存很有必要</p>\n<h2 id=\"V8的内存分配\"><a href=\"#V8的内存分配\" class=\"headerlink\" title=\"V8的内存分配\"></a>V8的内存分配</h2><p>在V8中所有js对象都是通过<strong>堆</strong>进行分配的，node提供了V8内存使用量的查看方式 process.memoryUsage(),问题来了，V8为什么要限制堆的大小呢？ps:1.5G的垃圾回收堆，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至达到1s以上，引起js线程暂停执行时间，性能和响应能力直线下降，所以限制堆内存成了当时一个好的选择。<br>当然也可以打开这种限制，但是V8初始化一旦生效，不能动态改变</p>\n<h2 id=\"V8的垃圾回收机制\"><a href=\"#V8的垃圾回收机制\" class=\"headerlink\" title=\"V8的垃圾回收机制\"></a>V8的垃圾回收机制</h2><h3 id=\"V8垃圾回收机制的算法\"><a href=\"#V8垃圾回收机制的算法\" class=\"headerlink\" title=\"V8垃圾回收机制的算法\"></a>V8垃圾回收机制的算法</h3><p>V8的策略是基于<strong>分代式</strong>垃圾回收机制，任何一种垃圾回收算法不能胜任所有场景，因为对象的生存周期长短不一，不同的算法只能针对特定的情况具有最好的结果。现代垃圾回收机制算法中按<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，不同的分代的内存使用更高效的算法</p>\n<h4 id=\"V8的内存分代\"><a href=\"#V8的内存分代\" class=\"headerlink\" title=\"V8的内存分代\"></a>V8的内存分代</h4><p>V8中，内存由新生代（对象存活时间短）和老生代（存活时间长）组成</p>\n<h4 id=\"Scavenge算法\"><a href=\"#Scavenge算法\" class=\"headerlink\" title=\"Scavenge算法\"></a>Scavenge算法</h4><p>新生代中的对象主要通过Scavenge算法进行垃圾回收，在Scavenge具体实现中，采用了Cheney算法（采用复制的方式实现垃圾回收算法），新生代生存空间： From 和 To， 堆由 From 和 To 和老生代组成<br>当一个对象经过多次复制依然存活，他将会被认为生命周期较长的现象，之后会被移到老生代中，用新的算法处理，这个过程称为<strong>晋升</strong><br>晋升需要的条件：</p>\n<ul>\n<li>对象是否被Scavenge回收<br>默认情况下，V8的对象分配主要集中在From中，对象从From空间中复制到To的过程中会检查他的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果没，复制到To中，有，则将改对象复制到老生代空间中</li>\n<li>To空间的占用比超过限制<br>如果To空间使用超过了25%，则晋升到老生代空间中，why 25% ？如果占比过高， 会影响后续的内存分配</li>\n</ul>\n<h4 id=\"Mark-Sweep-amp-Mark-Compact\"><a href=\"#Mark-Sweep-amp-Mark-Compact\" class=\"headerlink\" title=\"Mark-Sweep &amp; Mark-Compact\"></a>Mark-Sweep &amp; Mark-Compact</h4><p>Mark-Sweep是标记清除和Mark-Compact结合，用于老生代垃圾回收，why not use Scavenge for old space?因为老生代中的对象存活对象多，scavenge的方式会存在，复制存活对象的效率将会降低；另一个问题依然是浪费一半空间的问题，这样导致了应对生命周期较长的对象时scavenge显得捉襟见肘！<br>Mark-Sweep在标记遍历堆中所有的对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清除死亡的对象，活着的对象呢在新生代中少， 死亡的对象呢在老生代中也少，这是这样处理高效的原因。<br>Mark-Sweep最大的问题在于进行一次标记清除回收后，内存空间会存在不连续的状态，这种内存碎片会对后续的内存分配造成问题，因此如果很可能出现分配一个大对象的情况这时所有的碎片空间无法完成此次分配，就会提前触发垃圾回收，而这个垃圾回收是没必要的。<br>所以Mark-Compact应运而生，标记整理出来了，它的原理就是把活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。<br>这三种算法在速度、空间开销、是否移动对象可以做个对比</p>\n<h4 id=\"Incremental-Marking\"><a href=\"#Incremental-Marking\" class=\"headerlink\" title=\"Incremental Marking\"></a>Incremental Marking</h4><p>为避免Javascript应用逻辑与垃圾回收器看到不一致的情况，垃圾回收的三种算法都需要将应用逻辑暂停下来，等执行完垃圾回收再恢复应用逻辑，这种行为被称为“停顿”，在V8的分代式垃圾回收中，一次小的垃圾回收只收集新生代，由于新生代默认配置的小，存活对象少，所以即便全停顿影响不大，但是老生代配置得较大，且存活对象多，全堆垃圾回收的标记，清除，整理的动作造成的停顿大。<br>怎么办呢？所以V8先从标记阶段下手，将本一口气停顿完的动作改为增量标记，拆分为多个小步，每做完一步让Javascript应用逻辑先执行一会儿，逻辑与标记交替执行。当然后面V8也引入了增量清理（lazy Sweeping)，增量整理(incremental compaction),同时还引入了并行标记和并行清理，进一步利用多核降低每次停顿的时间。</p>\n<h2 id=\"查看垃圾回收日志\"><a href=\"#查看垃圾回收日志\" class=\"headerlink\" title=\"查看垃圾回收日志\"></a>查看垃圾回收日志</h2><p>node –trace__gc 可以查看哪些阶段比较耗时<br>node –prof 可以查看V8性能分析数据，比如垃圾回收的时间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在终端中，内存泄漏只会影响终端用户，由于时间短，进程退出，内存就会释放，几乎没管理内存的必要，但是在服务器端，问题就爆发出来了。<br>无阻塞、事件驱动建立的node服务具有内存消耗低，适合处理海量的网络请求<br>高效的利用资源（利用cpu和IO、 合理高效的使用内存）—–高性能</p>\n<h1 id=\"V8垃圾回收机制与内存限制\"><a href=\"#V8垃圾回收机制与内存限制\" class=\"headerlink\" title=\"V8垃圾回收机制与内存限制\"></a>V8垃圾回收机制与内存限制</h1><p>垃圾回收机制自动对内存进行管理，但是c/c++需要手动,另外，内存管理的好坏对服务构成影响</p>\n<h2 id=\"node与v8\"><a href=\"#node与v8\" class=\"headerlink\" title=\"node与v8\"></a>node与v8</h2><p>v8虚拟机的横空出世，node以它作为javascript脚本引擎，随着v8的升级，v8能享受到更好的语言特性（ES5,ES6等），但也受到V8一些限制</p>\n<h2 id=\"V8的内存限制\"><a href=\"#V8的内存限制\" class=\"headerlink\" title=\"V8的内存限制\"></a>V8的内存限制</h2><p>其他后端语言内存基本没什么限制，但是在node通过javascript使用内存就会发现只能使用部分内存（64位系统约1.4G，32位约0.7G),所以node不能直接操作大内存对象，比如无法将2G内存的文件读入内存进行字符串处理，即使物理内存有32G，所以在单个node进程下，计算机的内存资源无法得到充足的利用<br>why？ 主要是因为node基于V8构建，所以Node使用js对象的过程中都是通过V8自己的方式来分配管理的。V8这套内存管理机制在浏览器应用使用绰绰有余。所以合理使用内存很有必要</p>\n<h2 id=\"V8的内存分配\"><a href=\"#V8的内存分配\" class=\"headerlink\" title=\"V8的内存分配\"></a>V8的内存分配</h2><p>在V8中所有js对象都是通过<strong>堆</strong>进行分配的，node提供了V8内存使用量的查看方式 process.memoryUsage(),问题来了，V8为什么要限制堆的大小呢？ps:1.5G的垃圾回收堆，V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至达到1s以上，引起js线程暂停执行时间，性能和响应能力直线下降，所以限制堆内存成了当时一个好的选择。<br>当然也可以打开这种限制，但是V8初始化一旦生效，不能动态改变</p>\n<h2 id=\"V8的垃圾回收机制\"><a href=\"#V8的垃圾回收机制\" class=\"headerlink\" title=\"V8的垃圾回收机制\"></a>V8的垃圾回收机制</h2><h3 id=\"V8垃圾回收机制的算法\"><a href=\"#V8垃圾回收机制的算法\" class=\"headerlink\" title=\"V8垃圾回收机制的算法\"></a>V8垃圾回收机制的算法</h3><p>V8的策略是基于<strong>分代式</strong>垃圾回收机制，任何一种垃圾回收算法不能胜任所有场景，因为对象的生存周期长短不一，不同的算法只能针对特定的情况具有最好的结果。现代垃圾回收机制算法中按<strong>对象的存活时间</strong>将内存的垃圾回收进行不同的分代，不同的分代的内存使用更高效的算法</p>\n<h4 id=\"V8的内存分代\"><a href=\"#V8的内存分代\" class=\"headerlink\" title=\"V8的内存分代\"></a>V8的内存分代</h4><p>V8中，内存由新生代（对象存活时间短）和老生代（存活时间长）组成</p>\n<h4 id=\"Scavenge算法\"><a href=\"#Scavenge算法\" class=\"headerlink\" title=\"Scavenge算法\"></a>Scavenge算法</h4><p>新生代中的对象主要通过Scavenge算法进行垃圾回收，在Scavenge具体实现中，采用了Cheney算法（采用复制的方式实现垃圾回收算法），新生代生存空间： From 和 To， 堆由 From 和 To 和老生代组成<br>当一个对象经过多次复制依然存活，他将会被认为生命周期较长的现象，之后会被移到老生代中，用新的算法处理，这个过程称为<strong>晋升</strong><br>晋升需要的条件：</p>\n<ul>\n<li>对象是否被Scavenge回收<br>默认情况下，V8的对象分配主要集中在From中，对象从From空间中复制到To的过程中会检查他的内存地址来判断这个对象是否已经经历过一次Scavenge回收，如果没，复制到To中，有，则将改对象复制到老生代空间中</li>\n<li>To空间的占用比超过限制<br>如果To空间使用超过了25%，则晋升到老生代空间中，why 25% ？如果占比过高， 会影响后续的内存分配</li>\n</ul>\n<h4 id=\"Mark-Sweep-amp-Mark-Compact\"><a href=\"#Mark-Sweep-amp-Mark-Compact\" class=\"headerlink\" title=\"Mark-Sweep &amp; Mark-Compact\"></a>Mark-Sweep &amp; Mark-Compact</h4><p>Mark-Sweep是标记清除和Mark-Compact结合，用于老生代垃圾回收，why not use Scavenge for old space?因为老生代中的对象存活对象多，scavenge的方式会存在，复制存活对象的效率将会降低；另一个问题依然是浪费一半空间的问题，这样导致了应对生命周期较长的对象时scavenge显得捉襟见肘！<br>Mark-Sweep在标记遍历堆中所有的对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。可以看出，Scavenge中只复制活着的对象，而Mark-Sweep只清除死亡的对象，活着的对象呢在新生代中少， 死亡的对象呢在老生代中也少，这是这样处理高效的原因。<br>Mark-Sweep最大的问题在于进行一次标记清除回收后，内存空间会存在不连续的状态，这种内存碎片会对后续的内存分配造成问题，因此如果很可能出现分配一个大对象的情况这时所有的碎片空间无法完成此次分配，就会提前触发垃圾回收，而这个垃圾回收是没必要的。<br>所以Mark-Compact应运而生，标记整理出来了，它的原理就是把活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。<br>这三种算法在速度、空间开销、是否移动对象可以做个对比</p>\n<h4 id=\"Incremental-Marking\"><a href=\"#Incremental-Marking\" class=\"headerlink\" title=\"Incremental Marking\"></a>Incremental Marking</h4><p>为避免Javascript应用逻辑与垃圾回收器看到不一致的情况，垃圾回收的三种算法都需要将应用逻辑暂停下来，等执行完垃圾回收再恢复应用逻辑，这种行为被称为“停顿”，在V8的分代式垃圾回收中，一次小的垃圾回收只收集新生代，由于新生代默认配置的小，存活对象少，所以即便全停顿影响不大，但是老生代配置得较大，且存活对象多，全堆垃圾回收的标记，清除，整理的动作造成的停顿大。<br>怎么办呢？所以V8先从标记阶段下手，将本一口气停顿完的动作改为增量标记，拆分为多个小步，每做完一步让Javascript应用逻辑先执行一会儿，逻辑与标记交替执行。当然后面V8也引入了增量清理（lazy Sweeping)，增量整理(incremental compaction),同时还引入了并行标记和并行清理，进一步利用多核降低每次停顿的时间。</p>\n<h2 id=\"查看垃圾回收日志\"><a href=\"#查看垃圾回收日志\" class=\"headerlink\" title=\"查看垃圾回收日志\"></a>查看垃圾回收日志</h2><p>node –trace__gc 可以查看哪些阶段比较耗时<br>node –prof 可以查看V8性能分析数据，比如垃圾回收的时间</p>\n"},{"title":"内存泄漏","type":"categories","_content":"\n# 内存泄漏\nNode对内存泄漏很敏感，一旦线上有成千上万的流量，哪怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多的时间进行扫描，应用响应缓慢，直到进程内内存溢出，应用崩溃。\n在V8的垃圾回收机制下，通常的代码编写中，很少出现内存泄漏的情况。但是内存泄漏产生于无意间，难排查，内存泄漏的情况不尽相同，但是实质上只有一个，就是应该回收的对象没有被回收，变成了常驻在老生代中的对象。\n\n内存泄漏造成的原因：\n- 全局变量\n- 闭包\n- 事件监听（同一个事件重复监听，忘记removeListener）\n- 缓存\n- 队列消费不及时\n- 作用域没释放\n\n## 慎将内存当缓存\n缓存在应用中很重要，可以十分节省资源，因为他的访问效率要比I/O的高，一旦命中，就可以节省一次I/O的时间。\n但是在Node中，一旦对象被缓存下来，就意味着他会常驻老生代中，缓存中存储的键越多，长期存活的对象也就多，这导致垃圾回收在进行扫描整理的时候，对这些对象做无用功。\n另一个问题在于js开发者喜欢用对象的键值对来缓存东西，但是没有缓存的过期策略，不能称为缓存。所以尽量少用，如果要用加上过期策略以防止内存无限增长。\n\n### 缓存限制策略\n使用limitableMap，实现对键值数量的限制\n\n```\nvar limitableMap = function(limit) {\n\tthis.limit = limit || 10\n\tthis.map = {}\n\tthis.keys = []\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty\nlimitableMap.prototype.set = function(key, value) {\n\tvar map = this.map\n\tvar keys = this.keys\n\tif(!hasOwnProperty.call(map, key)) {\n\t\tif(keys.length == this.limit) {\n\t\t\tvar firstKey = keys.shift()\n\t\t\tdelete map[firstKey]\n\t\t}\n\t\tkeys.push(key)\n\t}\n\tmap[key] = value\n}\nlimitableMap.prototype.get = function(key) {\n\treturn this.map[key]\n}\nmodules.exports = limitableMap\n//采用先进先出的方式进行淘汰\n```\n### 缓存的解决方案\n内存作为缓存除了限制缓存的大小外，另外要考虑的事情就是进程间无法共享内存，如果在进程内使用缓存，这些缓存不可避免的要重复，对物理内存是种浪费。\n如果大量使用内存，比较好的方案就是进程外的缓存，进程自身不存储状态。\n外部的缓存有较好的缓存过期淘汰策略，以及自有的内存管理，不影响Node的进程的性能，解决了以下问题\n- 减少常驻内存对象的数量，让垃圾回收更高效\n- 进程之间可以共享缓存\n常见的缓存有 Redis 和 Memcached\n\n## 关注队列的状态\n队列在消费者-生产者模型中经常充当中间产物，但是一旦消费者速度低于生产者速度，就会形成堆积。如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高\nps:收集日志用数据库来记录，日志是海量的，数据库构建在文件系统之上，写入效率远远低于文件的直接写入，于是会形成数据库写入操作的堆积，而Javascript中的相关的作用域，也得不到释放，内存占用不会回落，从而出现内存泄漏\n- 解决方案1： 监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知开发人员\n- 解决方案2：任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超异常，使得任意异步调用的回调都具备可响应时间，给消费者速度一个下限值\n\n# 内存泄漏的排查工具\nnode-headdump: 对v8堆内存抓取快照\nnode-mtrace: 用来分析堆\n\n","source":"_posts/node/内存泄漏.md","raw":"---\ntitle: 内存泄漏\ntype: \"categories\"\ncategories: 后端\n---\n\n# 内存泄漏\nNode对内存泄漏很敏感，一旦线上有成千上万的流量，哪怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多的时间进行扫描，应用响应缓慢，直到进程内内存溢出，应用崩溃。\n在V8的垃圾回收机制下，通常的代码编写中，很少出现内存泄漏的情况。但是内存泄漏产生于无意间，难排查，内存泄漏的情况不尽相同，但是实质上只有一个，就是应该回收的对象没有被回收，变成了常驻在老生代中的对象。\n\n内存泄漏造成的原因：\n- 全局变量\n- 闭包\n- 事件监听（同一个事件重复监听，忘记removeListener）\n- 缓存\n- 队列消费不及时\n- 作用域没释放\n\n## 慎将内存当缓存\n缓存在应用中很重要，可以十分节省资源，因为他的访问效率要比I/O的高，一旦命中，就可以节省一次I/O的时间。\n但是在Node中，一旦对象被缓存下来，就意味着他会常驻老生代中，缓存中存储的键越多，长期存活的对象也就多，这导致垃圾回收在进行扫描整理的时候，对这些对象做无用功。\n另一个问题在于js开发者喜欢用对象的键值对来缓存东西，但是没有缓存的过期策略，不能称为缓存。所以尽量少用，如果要用加上过期策略以防止内存无限增长。\n\n### 缓存限制策略\n使用limitableMap，实现对键值数量的限制\n\n```\nvar limitableMap = function(limit) {\n\tthis.limit = limit || 10\n\tthis.map = {}\n\tthis.keys = []\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty\nlimitableMap.prototype.set = function(key, value) {\n\tvar map = this.map\n\tvar keys = this.keys\n\tif(!hasOwnProperty.call(map, key)) {\n\t\tif(keys.length == this.limit) {\n\t\t\tvar firstKey = keys.shift()\n\t\t\tdelete map[firstKey]\n\t\t}\n\t\tkeys.push(key)\n\t}\n\tmap[key] = value\n}\nlimitableMap.prototype.get = function(key) {\n\treturn this.map[key]\n}\nmodules.exports = limitableMap\n//采用先进先出的方式进行淘汰\n```\n### 缓存的解决方案\n内存作为缓存除了限制缓存的大小外，另外要考虑的事情就是进程间无法共享内存，如果在进程内使用缓存，这些缓存不可避免的要重复，对物理内存是种浪费。\n如果大量使用内存，比较好的方案就是进程外的缓存，进程自身不存储状态。\n外部的缓存有较好的缓存过期淘汰策略，以及自有的内存管理，不影响Node的进程的性能，解决了以下问题\n- 减少常驻内存对象的数量，让垃圾回收更高效\n- 进程之间可以共享缓存\n常见的缓存有 Redis 和 Memcached\n\n## 关注队列的状态\n队列在消费者-生产者模型中经常充当中间产物，但是一旦消费者速度低于生产者速度，就会形成堆积。如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高\nps:收集日志用数据库来记录，日志是海量的，数据库构建在文件系统之上，写入效率远远低于文件的直接写入，于是会形成数据库写入操作的堆积，而Javascript中的相关的作用域，也得不到释放，内存占用不会回落，从而出现内存泄漏\n- 解决方案1： 监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知开发人员\n- 解决方案2：任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超异常，使得任意异步调用的回调都具备可响应时间，给消费者速度一个下限值\n\n# 内存泄漏的排查工具\nnode-headdump: 对v8堆内存抓取快照\nnode-mtrace: 用来分析堆\n\n","slug":"node-内存泄漏","published":1,"date":"2017-09-26T08:35:10.000Z","updated":"2017-09-26T08:35:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccr000pkzy6nu2fh8rc","content":"<h1 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h1><p>Node对内存泄漏很敏感，一旦线上有成千上万的流量，哪怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多的时间进行扫描，应用响应缓慢，直到进程内内存溢出，应用崩溃。<br>在V8的垃圾回收机制下，通常的代码编写中，很少出现内存泄漏的情况。但是内存泄漏产生于无意间，难排查，内存泄漏的情况不尽相同，但是实质上只有一个，就是应该回收的对象没有被回收，变成了常驻在老生代中的对象。</p>\n<p>内存泄漏造成的原因：</p>\n<ul>\n<li>全局变量</li>\n<li>闭包</li>\n<li>事件监听（同一个事件重复监听，忘记removeListener）</li>\n<li>缓存</li>\n<li>队列消费不及时</li>\n<li>作用域没释放</li>\n</ul>\n<h2 id=\"慎将内存当缓存\"><a href=\"#慎将内存当缓存\" class=\"headerlink\" title=\"慎将内存当缓存\"></a>慎将内存当缓存</h2><p>缓存在应用中很重要，可以十分节省资源，因为他的访问效率要比I/O的高，一旦命中，就可以节省一次I/O的时间。<br>但是在Node中，一旦对象被缓存下来，就意味着他会常驻老生代中，缓存中存储的键越多，长期存活的对象也就多，这导致垃圾回收在进行扫描整理的时候，对这些对象做无用功。<br>另一个问题在于js开发者喜欢用对象的键值对来缓存东西，但是没有缓存的过期策略，不能称为缓存。所以尽量少用，如果要用加上过期策略以防止内存无限增长。</p>\n<h3 id=\"缓存限制策略\"><a href=\"#缓存限制策略\" class=\"headerlink\" title=\"缓存限制策略\"></a>缓存限制策略</h3><p>使用limitableMap，实现对键值数量的限制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var limitableMap = function(limit) &#123;</div><div class=\"line\">\tthis.limit = limit || 10</div><div class=\"line\">\tthis.map = &#123;&#125;</div><div class=\"line\">\tthis.keys = []</div><div class=\"line\">&#125;</div><div class=\"line\">var hasOwnProperty = Object.prototype.hasOwnProperty</div><div class=\"line\">limitableMap.prototype.set = function(key, value) &#123;</div><div class=\"line\">\tvar map = this.map</div><div class=\"line\">\tvar keys = this.keys</div><div class=\"line\">\tif(!hasOwnProperty.call(map, key)) &#123;</div><div class=\"line\">\t\tif(keys.length == this.limit) &#123;</div><div class=\"line\">\t\t\tvar firstKey = keys.shift()</div><div class=\"line\">\t\t\tdelete map[firstKey]</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tkeys.push(key)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tmap[key] = value</div><div class=\"line\">&#125;</div><div class=\"line\">limitableMap.prototype.get = function(key) &#123;</div><div class=\"line\">\treturn this.map[key]</div><div class=\"line\">&#125;</div><div class=\"line\">modules.exports = limitableMap</div><div class=\"line\">//采用先进先出的方式进行淘汰</div></pre></td></tr></table></figure>\n<h3 id=\"缓存的解决方案\"><a href=\"#缓存的解决方案\" class=\"headerlink\" title=\"缓存的解决方案\"></a>缓存的解决方案</h3><p>内存作为缓存除了限制缓存的大小外，另外要考虑的事情就是进程间无法共享内存，如果在进程内使用缓存，这些缓存不可避免的要重复，对物理内存是种浪费。<br>如果大量使用内存，比较好的方案就是进程外的缓存，进程自身不存储状态。<br>外部的缓存有较好的缓存过期淘汰策略，以及自有的内存管理，不影响Node的进程的性能，解决了以下问题</p>\n<ul>\n<li>减少常驻内存对象的数量，让垃圾回收更高效</li>\n<li>进程之间可以共享缓存<br>常见的缓存有 Redis 和 Memcached</li>\n</ul>\n<h2 id=\"关注队列的状态\"><a href=\"#关注队列的状态\" class=\"headerlink\" title=\"关注队列的状态\"></a>关注队列的状态</h2><p>队列在消费者-生产者模型中经常充当中间产物，但是一旦消费者速度低于生产者速度，就会形成堆积。如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高<br>ps:收集日志用数据库来记录，日志是海量的，数据库构建在文件系统之上，写入效率远远低于文件的直接写入，于是会形成数据库写入操作的堆积，而Javascript中的相关的作用域，也得不到释放，内存占用不会回落，从而出现内存泄漏</p>\n<ul>\n<li>解决方案1： 监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知开发人员</li>\n<li>解决方案2：任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超异常，使得任意异步调用的回调都具备可响应时间，给消费者速度一个下限值</li>\n</ul>\n<h1 id=\"内存泄漏的排查工具\"><a href=\"#内存泄漏的排查工具\" class=\"headerlink\" title=\"内存泄漏的排查工具\"></a>内存泄漏的排查工具</h1><p>node-headdump: 对v8堆内存抓取快照<br>node-mtrace: 用来分析堆</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h1><p>Node对内存泄漏很敏感，一旦线上有成千上万的流量，哪怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多的时间进行扫描，应用响应缓慢，直到进程内内存溢出，应用崩溃。<br>在V8的垃圾回收机制下，通常的代码编写中，很少出现内存泄漏的情况。但是内存泄漏产生于无意间，难排查，内存泄漏的情况不尽相同，但是实质上只有一个，就是应该回收的对象没有被回收，变成了常驻在老生代中的对象。</p>\n<p>内存泄漏造成的原因：</p>\n<ul>\n<li>全局变量</li>\n<li>闭包</li>\n<li>事件监听（同一个事件重复监听，忘记removeListener）</li>\n<li>缓存</li>\n<li>队列消费不及时</li>\n<li>作用域没释放</li>\n</ul>\n<h2 id=\"慎将内存当缓存\"><a href=\"#慎将内存当缓存\" class=\"headerlink\" title=\"慎将内存当缓存\"></a>慎将内存当缓存</h2><p>缓存在应用中很重要，可以十分节省资源，因为他的访问效率要比I/O的高，一旦命中，就可以节省一次I/O的时间。<br>但是在Node中，一旦对象被缓存下来，就意味着他会常驻老生代中，缓存中存储的键越多，长期存活的对象也就多，这导致垃圾回收在进行扫描整理的时候，对这些对象做无用功。<br>另一个问题在于js开发者喜欢用对象的键值对来缓存东西，但是没有缓存的过期策略，不能称为缓存。所以尽量少用，如果要用加上过期策略以防止内存无限增长。</p>\n<h3 id=\"缓存限制策略\"><a href=\"#缓存限制策略\" class=\"headerlink\" title=\"缓存限制策略\"></a>缓存限制策略</h3><p>使用limitableMap，实现对键值数量的限制</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">var limitableMap = function(limit) &#123;</div><div class=\"line\">\tthis.limit = limit || 10</div><div class=\"line\">\tthis.map = &#123;&#125;</div><div class=\"line\">\tthis.keys = []</div><div class=\"line\">&#125;</div><div class=\"line\">var hasOwnProperty = Object.prototype.hasOwnProperty</div><div class=\"line\">limitableMap.prototype.set = function(key, value) &#123;</div><div class=\"line\">\tvar map = this.map</div><div class=\"line\">\tvar keys = this.keys</div><div class=\"line\">\tif(!hasOwnProperty.call(map, key)) &#123;</div><div class=\"line\">\t\tif(keys.length == this.limit) &#123;</div><div class=\"line\">\t\t\tvar firstKey = keys.shift()</div><div class=\"line\">\t\t\tdelete map[firstKey]</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tkeys.push(key)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tmap[key] = value</div><div class=\"line\">&#125;</div><div class=\"line\">limitableMap.prototype.get = function(key) &#123;</div><div class=\"line\">\treturn this.map[key]</div><div class=\"line\">&#125;</div><div class=\"line\">modules.exports = limitableMap</div><div class=\"line\">//采用先进先出的方式进行淘汰</div></pre></td></tr></table></figure>\n<h3 id=\"缓存的解决方案\"><a href=\"#缓存的解决方案\" class=\"headerlink\" title=\"缓存的解决方案\"></a>缓存的解决方案</h3><p>内存作为缓存除了限制缓存的大小外，另外要考虑的事情就是进程间无法共享内存，如果在进程内使用缓存，这些缓存不可避免的要重复，对物理内存是种浪费。<br>如果大量使用内存，比较好的方案就是进程外的缓存，进程自身不存储状态。<br>外部的缓存有较好的缓存过期淘汰策略，以及自有的内存管理，不影响Node的进程的性能，解决了以下问题</p>\n<ul>\n<li>减少常驻内存对象的数量，让垃圾回收更高效</li>\n<li>进程之间可以共享缓存<br>常见的缓存有 Redis 和 Memcached</li>\n</ul>\n<h2 id=\"关注队列的状态\"><a href=\"#关注队列的状态\" class=\"headerlink\" title=\"关注队列的状态\"></a>关注队列的状态</h2><p>队列在消费者-生产者模型中经常充当中间产物，但是一旦消费者速度低于生产者速度，就会形成堆积。如果有高 CPU 的同步代码，因为Node.js 是单线程的，所以不能处理处理请求，请求堆积导致内存占用过高<br>ps:收集日志用数据库来记录，日志是海量的，数据库构建在文件系统之上，写入效率远远低于文件的直接写入，于是会形成数据库写入操作的堆积，而Javascript中的相关的作用域，也得不到释放，内存占用不会回落，从而出现内存泄漏</p>\n<ul>\n<li>解决方案1： 监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知开发人员</li>\n<li>解决方案2：任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超异常，使得任意异步调用的回调都具备可响应时间，给消费者速度一个下限值</li>\n</ul>\n<h1 id=\"内存泄漏的排查工具\"><a href=\"#内存泄漏的排查工具\" class=\"headerlink\" title=\"内存泄漏的排查工具\"></a>内存泄漏的排查工具</h1><p>node-headdump: 对v8堆内存抓取快照<br>node-mtrace: 用来分析堆</p>\n"},{"title":"异步/同步 vs 阻塞/非阻塞","type":"categories","_content":"\n# 同步与异步\n同步/异步在与事情做完了，如何进行处理，或者是说关注的是一种消息通信机制\n\n- 同步：由处理消息者自己去等待消息是否触发\n- 异步： 由触发机制来通知处理消息者\n\nps: \n1.比如你叫别人出去玩，别人想了一会儿，决定跟你出去    --- 同步\n2.比如你叫别人出去玩，别人说等会儿想好了答复你    --- 异步\n  \n# 阻塞和非阻塞\n主要是针对请求者而言\n\n阻塞：发出请求等待结果返回，然后再处理后续的事情；\n非阻塞：发出请求不等待请求返回，可以接着做后面的事情\n\nps: \n1.别人在想的过程中，你可以去干别的事情（非阻塞），也可以等他想完（阻塞）\n2.基于等会儿在答复你的这种情况，你依然可以去干别的事情（非阻塞），或者等老师想好了通知你这个事件发生，才去租别的事情（阻塞）\n\n所以同步可以是阻塞的也可以是非阻塞的","source":"_posts/node/异步:同步vs阻塞:非阻塞.md","raw":"---\ntitle: 异步/同步 vs 阻塞/非阻塞\ntype: \"categories\"\ncategories: 后端\n---\n\n# 同步与异步\n同步/异步在与事情做完了，如何进行处理，或者是说关注的是一种消息通信机制\n\n- 同步：由处理消息者自己去等待消息是否触发\n- 异步： 由触发机制来通知处理消息者\n\nps: \n1.比如你叫别人出去玩，别人想了一会儿，决定跟你出去    --- 同步\n2.比如你叫别人出去玩，别人说等会儿想好了答复你    --- 异步\n  \n# 阻塞和非阻塞\n主要是针对请求者而言\n\n阻塞：发出请求等待结果返回，然后再处理后续的事情；\n非阻塞：发出请求不等待请求返回，可以接着做后面的事情\n\nps: \n1.别人在想的过程中，你可以去干别的事情（非阻塞），也可以等他想完（阻塞）\n2.基于等会儿在答复你的这种情况，你依然可以去干别的事情（非阻塞），或者等老师想好了通知你这个事件发生，才去租别的事情（阻塞）\n\n所以同步可以是阻塞的也可以是非阻塞的","slug":"node-异步-同步vs阻塞-非阻塞","published":1,"date":"2017-07-17T00:36:11.000Z","updated":"2017-07-17T00:36:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cct000rkzy67s648bq9","content":"<h1 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h1><p>同步/异步在与事情做完了，如何进行处理，或者是说关注的是一种消息通信机制</p>\n<ul>\n<li>同步：由处理消息者自己去等待消息是否触发</li>\n<li>异步： 由触发机制来通知处理消息者</li>\n</ul>\n<p>ps:<br>1.比如你叫别人出去玩，别人想了一会儿，决定跟你出去    — 同步<br>2.比如你叫别人出去玩，别人说等会儿想好了答复你    — 异步</p>\n<h1 id=\"阻塞和非阻塞\"><a href=\"#阻塞和非阻塞\" class=\"headerlink\" title=\"阻塞和非阻塞\"></a>阻塞和非阻塞</h1><p>主要是针对请求者而言</p>\n<p>阻塞：发出请求等待结果返回，然后再处理后续的事情；<br>非阻塞：发出请求不等待请求返回，可以接着做后面的事情</p>\n<p>ps:<br>1.别人在想的过程中，你可以去干别的事情（非阻塞），也可以等他想完（阻塞）<br>2.基于等会儿在答复你的这种情况，你依然可以去干别的事情（非阻塞），或者等老师想好了通知你这个事件发生，才去租别的事情（阻塞）</p>\n<p>所以同步可以是阻塞的也可以是非阻塞的</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"同步与异步\"><a href=\"#同步与异步\" class=\"headerlink\" title=\"同步与异步\"></a>同步与异步</h1><p>同步/异步在与事情做完了，如何进行处理，或者是说关注的是一种消息通信机制</p>\n<ul>\n<li>同步：由处理消息者自己去等待消息是否触发</li>\n<li>异步： 由触发机制来通知处理消息者</li>\n</ul>\n<p>ps:<br>1.比如你叫别人出去玩，别人想了一会儿，决定跟你出去    — 同步<br>2.比如你叫别人出去玩，别人说等会儿想好了答复你    — 异步</p>\n<h1 id=\"阻塞和非阻塞\"><a href=\"#阻塞和非阻塞\" class=\"headerlink\" title=\"阻塞和非阻塞\"></a>阻塞和非阻塞</h1><p>主要是针对请求者而言</p>\n<p>阻塞：发出请求等待结果返回，然后再处理后续的事情；<br>非阻塞：发出请求不等待请求返回，可以接着做后面的事情</p>\n<p>ps:<br>1.别人在想的过程中，你可以去干别的事情（非阻塞），也可以等他想完（阻塞）<br>2.基于等会儿在答复你的这种情况，你依然可以去干别的事情（非阻塞），或者等老师想好了通知你这个事件发生，才去租别的事情（阻塞）</p>\n<p>所以同步可以是阻塞的也可以是非阻塞的</p>\n"},{"title":"异步并发控制","type":"categories","_content":"\n众所周知，并发量太大，服务器吃不消，如果对文件系统进行大量的并发调用（异步IO），操作系统的文件描述符数量将会被瞬间用光，会抛出错误，所以异步总是压榨底层系统的的性能，需要给予一定的过载保护，以防过犹不及。\n\n# bagpipe解决方案\n- 通过一个队列来控制并发量\n- 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从列队中取出执行\n- 如果活跃调用达到限定值，调用暂时存放到队列中\n- 每个异步调用结束时候，从队列中取出新的异步调用执行\n\nbagpipe提供了push()方法和full事件\n```\nvar BagPipe = require('bagpipe')\nvar bag = new BagPipe(10) //并发数\nfor(var i of 100) {\n\tbagpipe.push(async, ()=> {\n\t\t//callback\n\t})\n}\nbag.on('full',(length)=> {\n\t.....\n})\n```\n\n## 拒绝模式\n有些方法执行太晚的时候，超过了等待的时间，所以没意义了，这种场景需要立即返回失败，\n```\nvar bagpipe = new Bagpipe(10, {\n\trefuse: true\n})\n在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常\n```\n## 超时控制\n```\nvar bagpipe = new Bagpipe(10, {\n\ttimeout: 3000\n})\n在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常\n```\n\n# async解决方案\n```\nasync.parallelLiit([\n\t\tfunction(callback) {},\n\t\tfunction(callback) {}\n\t], 2, function(err, results) { //并发数量\n\n\t}\n\n)\n但是这不能动态的添加并行任务，所以提供了queue() 方法\n```\n\n# 两方案对比\nbagpipe更加灵活，可以添加任意类型的异步任务，也可以动态的添加异步任务，并且有超时控制和拒绝模式\n\n","source":"_posts/node/异步并发控制.md","raw":"---\ntitle: 异步并发控制\ntype: \"categories\"\ncategories: 后端\n---\n\n众所周知，并发量太大，服务器吃不消，如果对文件系统进行大量的并发调用（异步IO），操作系统的文件描述符数量将会被瞬间用光，会抛出错误，所以异步总是压榨底层系统的的性能，需要给予一定的过载保护，以防过犹不及。\n\n# bagpipe解决方案\n- 通过一个队列来控制并发量\n- 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从列队中取出执行\n- 如果活跃调用达到限定值，调用暂时存放到队列中\n- 每个异步调用结束时候，从队列中取出新的异步调用执行\n\nbagpipe提供了push()方法和full事件\n```\nvar BagPipe = require('bagpipe')\nvar bag = new BagPipe(10) //并发数\nfor(var i of 100) {\n\tbagpipe.push(async, ()=> {\n\t\t//callback\n\t})\n}\nbag.on('full',(length)=> {\n\t.....\n})\n```\n\n## 拒绝模式\n有些方法执行太晚的时候，超过了等待的时间，所以没意义了，这种场景需要立即返回失败，\n```\nvar bagpipe = new Bagpipe(10, {\n\trefuse: true\n})\n在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常\n```\n## 超时控制\n```\nvar bagpipe = new Bagpipe(10, {\n\ttimeout: 3000\n})\n在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常\n```\n\n# async解决方案\n```\nasync.parallelLiit([\n\t\tfunction(callback) {},\n\t\tfunction(callback) {}\n\t], 2, function(err, results) { //并发数量\n\n\t}\n\n)\n但是这不能动态的添加并行任务，所以提供了queue() 方法\n```\n\n# 两方案对比\nbagpipe更加灵活，可以添加任意类型的异步任务，也可以动态的添加异步任务，并且有超时控制和拒绝模式\n\n","slug":"node-异步并发控制","published":1,"date":"2017-07-25T02:41:31.000Z","updated":"2017-07-25T02:41:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccu000ukzy6zy3wlnl2","content":"<p>众所周知，并发量太大，服务器吃不消，如果对文件系统进行大量的并发调用（异步IO），操作系统的文件描述符数量将会被瞬间用光，会抛出错误，所以异步总是压榨底层系统的的性能，需要给予一定的过载保护，以防过犹不及。</p>\n<h1 id=\"bagpipe解决方案\"><a href=\"#bagpipe解决方案\" class=\"headerlink\" title=\"bagpipe解决方案\"></a>bagpipe解决方案</h1><ul>\n<li>通过一个队列来控制并发量</li>\n<li>如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从列队中取出执行</li>\n<li>如果活跃调用达到限定值，调用暂时存放到队列中</li>\n<li>每个异步调用结束时候，从队列中取出新的异步调用执行</li>\n</ul>\n<p>bagpipe提供了push()方法和full事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var BagPipe = require(&apos;bagpipe&apos;)</div><div class=\"line\">var bag = new BagPipe(10) //并发数</div><div class=\"line\">for(var i of 100) &#123;</div><div class=\"line\">\tbagpipe.push(async, ()=&gt; &#123;</div><div class=\"line\">\t\t//callback</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">bag.on(&apos;full&apos;,(length)=&gt; &#123;</div><div class=\"line\">\t.....</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"拒绝模式\"><a href=\"#拒绝模式\" class=\"headerlink\" title=\"拒绝模式\"></a>拒绝模式</h2><p>有些方法执行太晚的时候，超过了等待的时间，所以没意义了，这种场景需要立即返回失败，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var bagpipe = new Bagpipe(10, &#123;</div><div class=\"line\">\trefuse: true</div><div class=\"line\">&#125;)</div><div class=\"line\">在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常</div></pre></td></tr></table></figure></p>\n<h2 id=\"超时控制\"><a href=\"#超时控制\" class=\"headerlink\" title=\"超时控制\"></a>超时控制</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var bagpipe = new Bagpipe(10, &#123;</div><div class=\"line\">\ttimeout: 3000</div><div class=\"line\">&#125;)</div><div class=\"line\">在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常</div></pre></td></tr></table></figure>\n<h1 id=\"async解决方案\"><a href=\"#async解决方案\" class=\"headerlink\" title=\"async解决方案\"></a>async解决方案</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">async.parallelLiit([</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;,</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;</div><div class=\"line\">\t], 2, function(err, results) &#123; //并发数量</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">)</div><div class=\"line\">但是这不能动态的添加并行任务，所以提供了queue() 方法</div></pre></td></tr></table></figure>\n<h1 id=\"两方案对比\"><a href=\"#两方案对比\" class=\"headerlink\" title=\"两方案对比\"></a>两方案对比</h1><p>bagpipe更加灵活，可以添加任意类型的异步任务，也可以动态的添加异步任务，并且有超时控制和拒绝模式</p>\n","site":{"data":{}},"excerpt":"","more":"<p>众所周知，并发量太大，服务器吃不消，如果对文件系统进行大量的并发调用（异步IO），操作系统的文件描述符数量将会被瞬间用光，会抛出错误，所以异步总是压榨底层系统的的性能，需要给予一定的过载保护，以防过犹不及。</p>\n<h1 id=\"bagpipe解决方案\"><a href=\"#bagpipe解决方案\" class=\"headerlink\" title=\"bagpipe解决方案\"></a>bagpipe解决方案</h1><ul>\n<li>通过一个队列来控制并发量</li>\n<li>如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从列队中取出执行</li>\n<li>如果活跃调用达到限定值，调用暂时存放到队列中</li>\n<li>每个异步调用结束时候，从队列中取出新的异步调用执行</li>\n</ul>\n<p>bagpipe提供了push()方法和full事件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var BagPipe = require(&apos;bagpipe&apos;)</div><div class=\"line\">var bag = new BagPipe(10) //并发数</div><div class=\"line\">for(var i of 100) &#123;</div><div class=\"line\">\tbagpipe.push(async, ()=&gt; &#123;</div><div class=\"line\">\t\t//callback</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">bag.on(&apos;full&apos;,(length)=&gt; &#123;</div><div class=\"line\">\t.....</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"拒绝模式\"><a href=\"#拒绝模式\" class=\"headerlink\" title=\"拒绝模式\"></a>拒绝模式</h2><p>有些方法执行太晚的时候，超过了等待的时间，所以没意义了，这种场景需要立即返回失败，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var bagpipe = new Bagpipe(10, &#123;</div><div class=\"line\">\trefuse: true</div><div class=\"line\">&#125;)</div><div class=\"line\">在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常</div></pre></td></tr></table></figure></p>\n<h2 id=\"超时控制\"><a href=\"#超时控制\" class=\"headerlink\" title=\"超时控制\"></a>超时控制</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">var bagpipe = new Bagpipe(10, &#123;</div><div class=\"line\">\ttimeout: 3000</div><div class=\"line\">&#125;)</div><div class=\"line\">在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返回给他一个队列太忙的异常</div></pre></td></tr></table></figure>\n<h1 id=\"async解决方案\"><a href=\"#async解决方案\" class=\"headerlink\" title=\"async解决方案\"></a>async解决方案</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">async.parallelLiit([</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;,</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;</div><div class=\"line\">\t], 2, function(err, results) &#123; //并发数量</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">)</div><div class=\"line\">但是这不能动态的添加并行任务，所以提供了queue() 方法</div></pre></td></tr></table></figure>\n<h1 id=\"两方案对比\"><a href=\"#两方案对比\" class=\"headerlink\" title=\"两方案对比\"></a>两方案对比</h1><p>bagpipe更加灵活，可以添加任意类型的异步任务，也可以动态的添加异步任务，并且有超时控制和拒绝模式</p>\n"},{"title":"异步编程解决方案","type":"categories","_content":"\n# 事件订阅/发布方式\n- 订阅事件相当于一个高阶函数的应用，事件与多个回调函数（事件侦听器）的关联，事件侦听器可以灵活删除添加，使得事件和具体处理逻辑中间轻松解构\n- 注意要点：一个事件添加超过10侦听器会报警告\n- 为了处理异常，EeventEmitter对象对error事件进行了特殊对待，如果运行期间的错误触发了error事件，EventEmitter会检查是否对error事件添加过侦听器，如果添加了，侦听器会处理，否则作为异常抛出\n\n## 继承Events模块\n```\nvar events = require('events')\nfunction Stream() {\n\tevents.EventEmitter.call(this)\n}\nutils.inherits(Stream, events.EventEmitter)\n\nNode在util模块中封装了继承的方法\n\n```\n## 利用事件队列解决雪崩的问题\n雪崩：就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时引入数据库中，数据库无法同时承受如此大的查询请求，进而影响到网站整体的响应速度\n- 第一种办法是弄个死锁，但是只有第一次调用是生效的，后续的select是没有数据服务的，这时候要引入事件队列\n```\nvar proxy = new events.EventEmitter()\nvar status = 'ready'\nvar select = function (callback) {\n\tproxy.once('selected', callback)\n\tif(status = 'ready') {\n\t\tstatus = 'pending'\n\t\tdb.select('SQL', function(results) {\n\t\t\tproxy.emit('selected', results)\n\t\t\tstatus = 'ready'\n\t\t})\n\t}\n}\n\n- 利用once()方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每个回调只执行一次，对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。\n- SQL在进行查询的时候，新来的相同调用只需要在队列中等待数据就绪即可，一旦查询结束，得到的结果可以被这些调用共同使用，这种方式节省了重复的数据库调用产生的开销\n- node是单线程的原因，所以不用考虑状态同步的问题\n```\n\n# 流程控制库\n\n## 尾触发与Next\n尾触发主要用于connect的中间件，每个中间件传递请求对象、响应对象和尾触发函数，通过队列形成一个处理流\n- 优点： 可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合\n- 在Connect中，尾触发适合处理网路请求的场景，将处理复杂逻辑拆解为简洁、单一的处理单元，逐层次的处理单元，逐层次的处理请求对象和响应对象\n如果你嫌异步编程复杂，可以用流式处理，这对划分业务逻辑，逐步处理均有效\n\n## async\n- 异步的串行执行\n```\nasync.series([\n\tfunction (callback) {\n\t\tfs.readFile()\n\t},\n\tfunction(callback) {\n\t\tfs.readFile()\n\t}\n], function(err, results) {\n\t//异常\n})\n```\n- 异步的并行执行\n```\nasync.parallel([\n\t\tfunction(callback) {},\n\t\tfunction(callback) {}\n\t], function(err, results) {\n\n\t}\n\n)\n通过async编写的代码没有深度嵌套，也没有复杂的状态判断，诀窍在于自注入的回调函数\n\n//EventProxy方案\nvar Eventproxy = require('eventproxy')\nvar proxy = new EventProxy()\nproxy.all('content', 'data', function(content, data) {\n\tcallback(null, [content, data])\n})\nproxy.fail(callback)\n\nfs.readFile('file1.txt', 'utf-8', proxy.done('content'))\nfs.readFile('file2.txt', 'utf-8', proxy.done('data'))\n\n都是通过特殊的回调函数来隐含返回值的处理，\n所不同的是async的回调函数是有async函数封装后传递出来的，\n而EventProxy则通过done()和fail()方法生成新的回调函数\n但是都是高阶函数的应用\n```\n- 异步调用的依赖处理\nseries()适合无依赖的异步串行执行，但是需要前一个结果是后一个调用的输入时需要用waterfall()\n\n- 自动依赖处理\nasync提供了一个auto()方法实现复杂的业务处理\n```\nvar deps = {\n\treadConfig: function(){},\n\tconnectMongoDB: function() {},\n\tconnectRedis: function() {},\n\tcomplieAsserts: function() {},\n\tuploadAsserts: function(){}，\n\tstartUp: function() {}\n}\nasynct.auto(deps)\n也可以转换到EventProxy来实现\n```\n\n## Step\n\n# Promise/Deffered 模式\n\n\n\n\n\n\n\n","source":"_posts/node/异步编程解决方案.md","raw":"---\ntitle: 异步编程解决方案\ntype: \"categories\"\ncategories: 后端\n---\n\n# 事件订阅/发布方式\n- 订阅事件相当于一个高阶函数的应用，事件与多个回调函数（事件侦听器）的关联，事件侦听器可以灵活删除添加，使得事件和具体处理逻辑中间轻松解构\n- 注意要点：一个事件添加超过10侦听器会报警告\n- 为了处理异常，EeventEmitter对象对error事件进行了特殊对待，如果运行期间的错误触发了error事件，EventEmitter会检查是否对error事件添加过侦听器，如果添加了，侦听器会处理，否则作为异常抛出\n\n## 继承Events模块\n```\nvar events = require('events')\nfunction Stream() {\n\tevents.EventEmitter.call(this)\n}\nutils.inherits(Stream, events.EventEmitter)\n\nNode在util模块中封装了继承的方法\n\n```\n## 利用事件队列解决雪崩的问题\n雪崩：就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时引入数据库中，数据库无法同时承受如此大的查询请求，进而影响到网站整体的响应速度\n- 第一种办法是弄个死锁，但是只有第一次调用是生效的，后续的select是没有数据服务的，这时候要引入事件队列\n```\nvar proxy = new events.EventEmitter()\nvar status = 'ready'\nvar select = function (callback) {\n\tproxy.once('selected', callback)\n\tif(status = 'ready') {\n\t\tstatus = 'pending'\n\t\tdb.select('SQL', function(results) {\n\t\t\tproxy.emit('selected', results)\n\t\t\tstatus = 'ready'\n\t\t})\n\t}\n}\n\n- 利用once()方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每个回调只执行一次，对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。\n- SQL在进行查询的时候，新来的相同调用只需要在队列中等待数据就绪即可，一旦查询结束，得到的结果可以被这些调用共同使用，这种方式节省了重复的数据库调用产生的开销\n- node是单线程的原因，所以不用考虑状态同步的问题\n```\n\n# 流程控制库\n\n## 尾触发与Next\n尾触发主要用于connect的中间件，每个中间件传递请求对象、响应对象和尾触发函数，通过队列形成一个处理流\n- 优点： 可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合\n- 在Connect中，尾触发适合处理网路请求的场景，将处理复杂逻辑拆解为简洁、单一的处理单元，逐层次的处理单元，逐层次的处理请求对象和响应对象\n如果你嫌异步编程复杂，可以用流式处理，这对划分业务逻辑，逐步处理均有效\n\n## async\n- 异步的串行执行\n```\nasync.series([\n\tfunction (callback) {\n\t\tfs.readFile()\n\t},\n\tfunction(callback) {\n\t\tfs.readFile()\n\t}\n], function(err, results) {\n\t//异常\n})\n```\n- 异步的并行执行\n```\nasync.parallel([\n\t\tfunction(callback) {},\n\t\tfunction(callback) {}\n\t], function(err, results) {\n\n\t}\n\n)\n通过async编写的代码没有深度嵌套，也没有复杂的状态判断，诀窍在于自注入的回调函数\n\n//EventProxy方案\nvar Eventproxy = require('eventproxy')\nvar proxy = new EventProxy()\nproxy.all('content', 'data', function(content, data) {\n\tcallback(null, [content, data])\n})\nproxy.fail(callback)\n\nfs.readFile('file1.txt', 'utf-8', proxy.done('content'))\nfs.readFile('file2.txt', 'utf-8', proxy.done('data'))\n\n都是通过特殊的回调函数来隐含返回值的处理，\n所不同的是async的回调函数是有async函数封装后传递出来的，\n而EventProxy则通过done()和fail()方法生成新的回调函数\n但是都是高阶函数的应用\n```\n- 异步调用的依赖处理\nseries()适合无依赖的异步串行执行，但是需要前一个结果是后一个调用的输入时需要用waterfall()\n\n- 自动依赖处理\nasync提供了一个auto()方法实现复杂的业务处理\n```\nvar deps = {\n\treadConfig: function(){},\n\tconnectMongoDB: function() {},\n\tconnectRedis: function() {},\n\tcomplieAsserts: function() {},\n\tuploadAsserts: function(){}，\n\tstartUp: function() {}\n}\nasynct.auto(deps)\n也可以转换到EventProxy来实现\n```\n\n## Step\n\n# Promise/Deffered 模式\n\n\n\n\n\n\n\n","slug":"node-异步编程解决方案","published":1,"date":"2017-07-25T02:41:31.000Z","updated":"2017-07-25T02:41:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccv000vkzy60ejg4ftx","content":"<h1 id=\"事件订阅-发布方式\"><a href=\"#事件订阅-发布方式\" class=\"headerlink\" title=\"事件订阅/发布方式\"></a>事件订阅/发布方式</h1><ul>\n<li>订阅事件相当于一个高阶函数的应用，事件与多个回调函数（事件侦听器）的关联，事件侦听器可以灵活删除添加，使得事件和具体处理逻辑中间轻松解构</li>\n<li>注意要点：一个事件添加超过10侦听器会报警告</li>\n<li>为了处理异常，EeventEmitter对象对error事件进行了特殊对待，如果运行期间的错误触发了error事件，EventEmitter会检查是否对error事件添加过侦听器，如果添加了，侦听器会处理，否则作为异常抛出</li>\n</ul>\n<h2 id=\"继承Events模块\"><a href=\"#继承Events模块\" class=\"headerlink\" title=\"继承Events模块\"></a>继承Events模块</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var events = require(&apos;events&apos;)</div><div class=\"line\">function Stream() &#123;</div><div class=\"line\">\tevents.EventEmitter.call(this)</div><div class=\"line\">&#125;</div><div class=\"line\">utils.inherits(Stream, events.EventEmitter)</div><div class=\"line\"></div><div class=\"line\">Node在util模块中封装了继承的方法</div></pre></td></tr></table></figure>\n<h2 id=\"利用事件队列解决雪崩的问题\"><a href=\"#利用事件队列解决雪崩的问题\" class=\"headerlink\" title=\"利用事件队列解决雪崩的问题\"></a>利用事件队列解决雪崩的问题</h2><p>雪崩：就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时引入数据库中，数据库无法同时承受如此大的查询请求，进而影响到网站整体的响应速度</p>\n<ul>\n<li>第一种办法是弄个死锁，但是只有第一次调用是生效的，后续的select是没有数据服务的，这时候要引入事件队列<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">var proxy = new events.EventEmitter()</div><div class=\"line\">var status = &apos;ready&apos;</div><div class=\"line\">var select = function (callback) &#123;</div><div class=\"line\">\tproxy.once(&apos;selected&apos;, callback)</div><div class=\"line\">\tif(status = &apos;ready&apos;) &#123;</div><div class=\"line\">\t\tstatus = &apos;pending&apos;</div><div class=\"line\">\t\tdb.select(&apos;SQL&apos;, function(results) &#123;</div><div class=\"line\">\t\t\tproxy.emit(&apos;selected&apos;, results)</div><div class=\"line\">\t\t\tstatus = &apos;ready&apos;</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- 利用once()方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每个回调只执行一次，对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。</div><div class=\"line\">- SQL在进行查询的时候，新来的相同调用只需要在队列中等待数据就绪即可，一旦查询结束，得到的结果可以被这些调用共同使用，这种方式节省了重复的数据库调用产生的开销</div><div class=\"line\">- node是单线程的原因，所以不用考虑状态同步的问题</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"流程控制库\"><a href=\"#流程控制库\" class=\"headerlink\" title=\"流程控制库\"></a>流程控制库</h1><h2 id=\"尾触发与Next\"><a href=\"#尾触发与Next\" class=\"headerlink\" title=\"尾触发与Next\"></a>尾触发与Next</h2><p>尾触发主要用于connect的中间件，每个中间件传递请求对象、响应对象和尾触发函数，通过队列形成一个处理流</p>\n<ul>\n<li>优点： 可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合</li>\n<li>在Connect中，尾触发适合处理网路请求的场景，将处理复杂逻辑拆解为简洁、单一的处理单元，逐层次的处理单元，逐层次的处理请求对象和响应对象<br>如果你嫌异步编程复杂，可以用流式处理，这对划分业务逻辑，逐步处理均有效</li>\n</ul>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><ul>\n<li><p>异步的串行执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">async.series([</div><div class=\"line\">\tfunction (callback) &#123;</div><div class=\"line\">\t\tfs.readFile()</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tfunction(callback) &#123;</div><div class=\"line\">\t\tfs.readFile()</div><div class=\"line\">\t&#125;</div><div class=\"line\">], function(err, results) &#123;</div><div class=\"line\">\t//异常</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>异步的并行执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">async.parallel([</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;,</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;</div><div class=\"line\">\t], function(err, results) &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">)</div><div class=\"line\">通过async编写的代码没有深度嵌套，也没有复杂的状态判断，诀窍在于自注入的回调函数</div><div class=\"line\"></div><div class=\"line\">//EventProxy方案</div><div class=\"line\">var Eventproxy = require(&apos;eventproxy&apos;)</div><div class=\"line\">var proxy = new EventProxy()</div><div class=\"line\">proxy.all(&apos;content&apos;, &apos;data&apos;, function(content, data) &#123;</div><div class=\"line\">\tcallback(null, [content, data])</div><div class=\"line\">&#125;)</div><div class=\"line\">proxy.fail(callback)</div><div class=\"line\"></div><div class=\"line\">fs.readFile(&apos;file1.txt&apos;, &apos;utf-8&apos;, proxy.done(&apos;content&apos;))</div><div class=\"line\">fs.readFile(&apos;file2.txt&apos;, &apos;utf-8&apos;, proxy.done(&apos;data&apos;))</div><div class=\"line\"></div><div class=\"line\">都是通过特殊的回调函数来隐含返回值的处理，</div><div class=\"line\">所不同的是async的回调函数是有async函数封装后传递出来的，</div><div class=\"line\">而EventProxy则通过done()和fail()方法生成新的回调函数</div><div class=\"line\">但是都是高阶函数的应用</div></pre></td></tr></table></figure>\n</li>\n<li><p>异步调用的依赖处理<br>series()适合无依赖的异步串行执行，但是需要前一个结果是后一个调用的输入时需要用waterfall()</p>\n</li>\n<li><p>自动依赖处理<br>async提供了一个auto()方法实现复杂的业务处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deps = &#123;</div><div class=\"line\">\treadConfig: function()&#123;&#125;,</div><div class=\"line\">\tconnectMongoDB: function() &#123;&#125;,</div><div class=\"line\">\tconnectRedis: function() &#123;&#125;,</div><div class=\"line\">\tcomplieAsserts: function() &#123;&#125;,</div><div class=\"line\">\tuploadAsserts: function()&#123;&#125;，</div><div class=\"line\">\tstartUp: function() &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">asynct.auto(deps)</div><div class=\"line\">也可以转换到EventProxy来实现</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Step\"><a href=\"#Step\" class=\"headerlink\" title=\"Step\"></a>Step</h2><h1 id=\"Promise-Deffered-模式\"><a href=\"#Promise-Deffered-模式\" class=\"headerlink\" title=\"Promise/Deffered 模式\"></a>Promise/Deffered 模式</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"事件订阅-发布方式\"><a href=\"#事件订阅-发布方式\" class=\"headerlink\" title=\"事件订阅/发布方式\"></a>事件订阅/发布方式</h1><ul>\n<li>订阅事件相当于一个高阶函数的应用，事件与多个回调函数（事件侦听器）的关联，事件侦听器可以灵活删除添加，使得事件和具体处理逻辑中间轻松解构</li>\n<li>注意要点：一个事件添加超过10侦听器会报警告</li>\n<li>为了处理异常，EeventEmitter对象对error事件进行了特殊对待，如果运行期间的错误触发了error事件，EventEmitter会检查是否对error事件添加过侦听器，如果添加了，侦听器会处理，否则作为异常抛出</li>\n</ul>\n<h2 id=\"继承Events模块\"><a href=\"#继承Events模块\" class=\"headerlink\" title=\"继承Events模块\"></a>继承Events模块</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var events = require(&apos;events&apos;)</div><div class=\"line\">function Stream() &#123;</div><div class=\"line\">\tevents.EventEmitter.call(this)</div><div class=\"line\">&#125;</div><div class=\"line\">utils.inherits(Stream, events.EventEmitter)</div><div class=\"line\"></div><div class=\"line\">Node在util模块中封装了继承的方法</div></pre></td></tr></table></figure>\n<h2 id=\"利用事件队列解决雪崩的问题\"><a href=\"#利用事件队列解决雪崩的问题\" class=\"headerlink\" title=\"利用事件队列解决雪崩的问题\"></a>利用事件队列解决雪崩的问题</h2><p>雪崩：就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时引入数据库中，数据库无法同时承受如此大的查询请求，进而影响到网站整体的响应速度</p>\n<ul>\n<li>第一种办法是弄个死锁，但是只有第一次调用是生效的，后续的select是没有数据服务的，这时候要引入事件队列<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">var proxy = new events.EventEmitter()</div><div class=\"line\">var status = &apos;ready&apos;</div><div class=\"line\">var select = function (callback) &#123;</div><div class=\"line\">\tproxy.once(&apos;selected&apos;, callback)</div><div class=\"line\">\tif(status = &apos;ready&apos;) &#123;</div><div class=\"line\">\t\tstatus = &apos;pending&apos;</div><div class=\"line\">\t\tdb.select(&apos;SQL&apos;, function(results) &#123;</div><div class=\"line\">\t\t\tproxy.emit(&apos;selected&apos;, results)</div><div class=\"line\">\t\t\tstatus = &apos;ready&apos;</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- 利用once()方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每个回调只执行一次，对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。</div><div class=\"line\">- SQL在进行查询的时候，新来的相同调用只需要在队列中等待数据就绪即可，一旦查询结束，得到的结果可以被这些调用共同使用，这种方式节省了重复的数据库调用产生的开销</div><div class=\"line\">- node是单线程的原因，所以不用考虑状态同步的问题</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"流程控制库\"><a href=\"#流程控制库\" class=\"headerlink\" title=\"流程控制库\"></a>流程控制库</h1><h2 id=\"尾触发与Next\"><a href=\"#尾触发与Next\" class=\"headerlink\" title=\"尾触发与Next\"></a>尾触发与Next</h2><p>尾触发主要用于connect的中间件，每个中间件传递请求对象、响应对象和尾触发函数，通过队列形成一个处理流</p>\n<ul>\n<li>优点： 可以像面向切面编程一样进行过滤、验证、日志等功能，而不与具体业务逻辑产生关联，以致产生耦合</li>\n<li>在Connect中，尾触发适合处理网路请求的场景，将处理复杂逻辑拆解为简洁、单一的处理单元，逐层次的处理单元，逐层次的处理请求对象和响应对象<br>如果你嫌异步编程复杂，可以用流式处理，这对划分业务逻辑，逐步处理均有效</li>\n</ul>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><ul>\n<li><p>异步的串行执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">async.series([</div><div class=\"line\">\tfunction (callback) &#123;</div><div class=\"line\">\t\tfs.readFile()</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tfunction(callback) &#123;</div><div class=\"line\">\t\tfs.readFile()</div><div class=\"line\">\t&#125;</div><div class=\"line\">], function(err, results) &#123;</div><div class=\"line\">\t//异常</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n<li><p>异步的并行执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">async.parallel([</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;,</div><div class=\"line\">\t\tfunction(callback) &#123;&#125;</div><div class=\"line\">\t], function(err, results) &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">)</div><div class=\"line\">通过async编写的代码没有深度嵌套，也没有复杂的状态判断，诀窍在于自注入的回调函数</div><div class=\"line\"></div><div class=\"line\">//EventProxy方案</div><div class=\"line\">var Eventproxy = require(&apos;eventproxy&apos;)</div><div class=\"line\">var proxy = new EventProxy()</div><div class=\"line\">proxy.all(&apos;content&apos;, &apos;data&apos;, function(content, data) &#123;</div><div class=\"line\">\tcallback(null, [content, data])</div><div class=\"line\">&#125;)</div><div class=\"line\">proxy.fail(callback)</div><div class=\"line\"></div><div class=\"line\">fs.readFile(&apos;file1.txt&apos;, &apos;utf-8&apos;, proxy.done(&apos;content&apos;))</div><div class=\"line\">fs.readFile(&apos;file2.txt&apos;, &apos;utf-8&apos;, proxy.done(&apos;data&apos;))</div><div class=\"line\"></div><div class=\"line\">都是通过特殊的回调函数来隐含返回值的处理，</div><div class=\"line\">所不同的是async的回调函数是有async函数封装后传递出来的，</div><div class=\"line\">而EventProxy则通过done()和fail()方法生成新的回调函数</div><div class=\"line\">但是都是高阶函数的应用</div></pre></td></tr></table></figure>\n</li>\n<li><p>异步调用的依赖处理<br>series()适合无依赖的异步串行执行，但是需要前一个结果是后一个调用的输入时需要用waterfall()</p>\n</li>\n<li><p>自动依赖处理<br>async提供了一个auto()方法实现复杂的业务处理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var deps = &#123;</div><div class=\"line\">\treadConfig: function()&#123;&#125;,</div><div class=\"line\">\tconnectMongoDB: function() &#123;&#125;,</div><div class=\"line\">\tconnectRedis: function() &#123;&#125;,</div><div class=\"line\">\tcomplieAsserts: function() &#123;&#125;,</div><div class=\"line\">\tuploadAsserts: function()&#123;&#125;，</div><div class=\"line\">\tstartUp: function() &#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">asynct.auto(deps)</div><div class=\"line\">也可以转换到EventProxy来实现</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Step\"><a href=\"#Step\" class=\"headerlink\" title=\"Step\"></a>Step</h2><h1 id=\"Promise-Deffered-模式\"><a href=\"#Promise-Deffered-模式\" class=\"headerlink\" title=\"Promise/Deffered 模式\"></a>Promise/Deffered 模式</h1>"},{"title":"构建web应用","type":"categories","_content":"\n# 需求\n1.请求方法的判断\n2.URL路径解析\n3.URL中查询字符串解析\n4.Cookie的解析\n5.Basic的认证\n6.表单数据的解析\n7.任意格式文件的上传处理\n\n## 请求方法\n通过HTTP_Parser解析报文，将报文头抽取出来，设置为req.method\n\n## 路径解析\n通过HTTP_Parser解析成req.url,比如根据路径去找到静态资源\n\n## 查询字符串\nnode提供了querystring模块用于处理这部分数据\n\n\n## cookie\ncookie发送到服务端的几个选项\n- Path，表示这个cookie影响到的路径，当前访问路径不满足该匹配的时候，浏览器不发送Cookie\n- Expire和Max-Age用来告诉浏览器这cookie何时过期，如果不设置，关闭浏览器时候会丢掉这个cookie，后者是个相对时间，优先级更高\n- HttpOnly 告知浏览器不允许通过脚本document.cookie\n- Secure 表示只有https的时候才会传递cookie\n\n### cookie的性能影响\n- 减少cookie的大小，如果在根域名设置cookie，几乎所有子路径下的请求都会带上cookie，但是某些静态页面是不需要的\n- 为静态资源使用不同的域名，不过这会造成一个缺点，将域名转换成IP需要进行DNS查询，多一个域名就多一次DNS查询\n- 减少DNS查询，如今浏览器会对DNS进行缓存\n\n\n","source":"_posts/node/构建web应用.md","raw":"---\ntitle: 构建web应用\ntype: \"categories\"\ncategories: 后端\n---\n\n# 需求\n1.请求方法的判断\n2.URL路径解析\n3.URL中查询字符串解析\n4.Cookie的解析\n5.Basic的认证\n6.表单数据的解析\n7.任意格式文件的上传处理\n\n## 请求方法\n通过HTTP_Parser解析报文，将报文头抽取出来，设置为req.method\n\n## 路径解析\n通过HTTP_Parser解析成req.url,比如根据路径去找到静态资源\n\n## 查询字符串\nnode提供了querystring模块用于处理这部分数据\n\n\n## cookie\ncookie发送到服务端的几个选项\n- Path，表示这个cookie影响到的路径，当前访问路径不满足该匹配的时候，浏览器不发送Cookie\n- Expire和Max-Age用来告诉浏览器这cookie何时过期，如果不设置，关闭浏览器时候会丢掉这个cookie，后者是个相对时间，优先级更高\n- HttpOnly 告知浏览器不允许通过脚本document.cookie\n- Secure 表示只有https的时候才会传递cookie\n\n### cookie的性能影响\n- 减少cookie的大小，如果在根域名设置cookie，几乎所有子路径下的请求都会带上cookie，但是某些静态页面是不需要的\n- 为静态资源使用不同的域名，不过这会造成一个缺点，将域名转换成IP需要进行DNS查询，多一个域名就多一次DNS查询\n- 减少DNS查询，如今浏览器会对DNS进行缓存\n\n\n","slug":"node-构建web应用","published":1,"date":"2017-09-14T10:53:59.000Z","updated":"2017-09-14T10:53:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccw000ykzy6dnhvud5m","content":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>1.请求方法的判断<br>2.URL路径解析<br>3.URL中查询字符串解析<br>4.Cookie的解析<br>5.Basic的认证<br>6.表单数据的解析<br>7.任意格式文件的上传处理</p>\n<h2 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h2><p>通过HTTP_Parser解析报文，将报文头抽取出来，设置为req.method</p>\n<h2 id=\"路径解析\"><a href=\"#路径解析\" class=\"headerlink\" title=\"路径解析\"></a>路径解析</h2><p>通过HTTP_Parser解析成req.url,比如根据路径去找到静态资源</p>\n<h2 id=\"查询字符串\"><a href=\"#查询字符串\" class=\"headerlink\" title=\"查询字符串\"></a>查询字符串</h2><p>node提供了querystring模块用于处理这部分数据</p>\n<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>cookie发送到服务端的几个选项</p>\n<ul>\n<li>Path，表示这个cookie影响到的路径，当前访问路径不满足该匹配的时候，浏览器不发送Cookie</li>\n<li>Expire和Max-Age用来告诉浏览器这cookie何时过期，如果不设置，关闭浏览器时候会丢掉这个cookie，后者是个相对时间，优先级更高</li>\n<li>HttpOnly 告知浏览器不允许通过脚本document.cookie</li>\n<li>Secure 表示只有https的时候才会传递cookie</li>\n</ul>\n<h3 id=\"cookie的性能影响\"><a href=\"#cookie的性能影响\" class=\"headerlink\" title=\"cookie的性能影响\"></a>cookie的性能影响</h3><ul>\n<li>减少cookie的大小，如果在根域名设置cookie，几乎所有子路径下的请求都会带上cookie，但是某些静态页面是不需要的</li>\n<li>为静态资源使用不同的域名，不过这会造成一个缺点，将域名转换成IP需要进行DNS查询，多一个域名就多一次DNS查询</li>\n<li>减少DNS查询，如今浏览器会对DNS进行缓存</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"需求\"><a href=\"#需求\" class=\"headerlink\" title=\"需求\"></a>需求</h1><p>1.请求方法的判断<br>2.URL路径解析<br>3.URL中查询字符串解析<br>4.Cookie的解析<br>5.Basic的认证<br>6.表单数据的解析<br>7.任意格式文件的上传处理</p>\n<h2 id=\"请求方法\"><a href=\"#请求方法\" class=\"headerlink\" title=\"请求方法\"></a>请求方法</h2><p>通过HTTP_Parser解析报文，将报文头抽取出来，设置为req.method</p>\n<h2 id=\"路径解析\"><a href=\"#路径解析\" class=\"headerlink\" title=\"路径解析\"></a>路径解析</h2><p>通过HTTP_Parser解析成req.url,比如根据路径去找到静态资源</p>\n<h2 id=\"查询字符串\"><a href=\"#查询字符串\" class=\"headerlink\" title=\"查询字符串\"></a>查询字符串</h2><p>node提供了querystring模块用于处理这部分数据</p>\n<h2 id=\"cookie\"><a href=\"#cookie\" class=\"headerlink\" title=\"cookie\"></a>cookie</h2><p>cookie发送到服务端的几个选项</p>\n<ul>\n<li>Path，表示这个cookie影响到的路径，当前访问路径不满足该匹配的时候，浏览器不发送Cookie</li>\n<li>Expire和Max-Age用来告诉浏览器这cookie何时过期，如果不设置，关闭浏览器时候会丢掉这个cookie，后者是个相对时间，优先级更高</li>\n<li>HttpOnly 告知浏览器不允许通过脚本document.cookie</li>\n<li>Secure 表示只有https的时候才会传递cookie</li>\n</ul>\n<h3 id=\"cookie的性能影响\"><a href=\"#cookie的性能影响\" class=\"headerlink\" title=\"cookie的性能影响\"></a>cookie的性能影响</h3><ul>\n<li>减少cookie的大小，如果在根域名设置cookie，几乎所有子路径下的请求都会带上cookie，但是某些静态页面是不需要的</li>\n<li>为静态资源使用不同的域名，不过这会造成一个缺点，将域名转换成IP需要进行DNS查询，多一个域名就多一次DNS查询</li>\n<li>减少DNS查询，如今浏览器会对DNS进行缓存</li>\n</ul>\n"},{"title":"模块机制","type":"categories","_content":"\n### CommonJs规范\n>模块定义（exports)，模块标识（路径），模块引用（require）\n\n### 模块的分类和查找顺序\n\n>核心模块=>文件模块=>自定义模块\n\n### 引入模块经历的阶段\n> 1.路径分析，文件定位， 编译执行\n\n### module构造函数\n```\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\nmodule.exports = Module;\nvar module = new Module(filename, parent);\n\n//所有模块都是Module的实例\n\n```\n\n### 模块的实例方法\n\n>每个模块实例都有一个 require 方法（require.resolve('path') ==> 返回一个绝对路径)\n\n```\nModule.prototype.require = function(path) {\n\treturn Module._load(path, this) //调用内部方法\n}\n\nModule._load = function(request, parent, isMain) {\n\n\t//  计算绝对路径\n\tvar filename = Module._resolveFilename(request, parent);\n\n\t//  第一步：如果有缓存，取出缓存\n\tvar cachedModule = Module._cache[filename];\n\tif (cachedModule) {\n\t\treturn cachedModule.exports;\n\t}\n\n\t// 第二步：是否为内置模块\n\tif (NativeModule.exists(filename)) {\n\t\treturn NativeModule.require(filename);\n\t}\n\n\t// 第三步：生成模块实例，存入缓存\n\tvar module = new Module(filename, parent);\n\tModule._cache[filename] = module;\n\n\t// 第四步：加载模块\n\ttry {\n\t\tmodule.load(filename);\n\t\thadException = false;\n\t} finally {\n\t\tif (hadException) {\n\t\t  delete Module._cache[filename];\n\t\t}\n\t}\n\n\t// 第五步：《输出模块的exports属性》\n\treturn module.exports;\n}\n\nModule._resolveFilename = function () {\n\n\t Module._resolveLookupPaths() //查询可能的路径，通常返回一个数组组成的可能路径\n\t Module._findPath() //确定路径是否为真，为真返回，否则false\n}\n\n\nModule.prototype.load = function(filename) {\n\n\t//不同的后缀名对应不同的加载方法\n\tvar extension = path.extname(filename) || '.js';\n\tif (!Module._extensions[extension]) extension = '.js';\n\tModule._extensions[extension](this, filename);\n\tthis.loaded = true;\n};\n\n//js文件读取成字符串，剥离utf8,最后编译该模块\nModule.prototype._compile = function(content, filename) {\n\tvar self = this;\n\tvar args = [self.exports, require, self, filename, dirname];\n\treturn compiledWrapper.apply(self.exports, args);\n};\n\n```\n\n###  总结\n> **模块的加载**实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出\n\n\n```\n(function (exports, require, module, __filename, __dirname) {\n  // 模块源码\n});\n\n```\n\n### 补充：module.exports 与 exports 的区别\n> 1.require操作之前，node环境会自动执行 exports = module.exports\n  2.所以一次看出，exports是module.exports的引用，\n  3.这两者默认都是一个空对象\n\n> 注意事项: require返回的是module.exports\n\n\n\n[参考 http://www.ruanyifeng.com/blog/2015/05/require.html](http://www.ruanyifeng.com/blog/2015/05/require.html)\n\n","source":"_posts/node/模块机制.md","raw":"---\ntitle: 模块机制\ntype: \"categories\"\ncategories: 后端\n---\n\n### CommonJs规范\n>模块定义（exports)，模块标识（路径），模块引用（require）\n\n### 模块的分类和查找顺序\n\n>核心模块=>文件模块=>自定义模块\n\n### 引入模块经历的阶段\n> 1.路径分析，文件定位， 编译执行\n\n### module构造函数\n```\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\nmodule.exports = Module;\nvar module = new Module(filename, parent);\n\n//所有模块都是Module的实例\n\n```\n\n### 模块的实例方法\n\n>每个模块实例都有一个 require 方法（require.resolve('path') ==> 返回一个绝对路径)\n\n```\nModule.prototype.require = function(path) {\n\treturn Module._load(path, this) //调用内部方法\n}\n\nModule._load = function(request, parent, isMain) {\n\n\t//  计算绝对路径\n\tvar filename = Module._resolveFilename(request, parent);\n\n\t//  第一步：如果有缓存，取出缓存\n\tvar cachedModule = Module._cache[filename];\n\tif (cachedModule) {\n\t\treturn cachedModule.exports;\n\t}\n\n\t// 第二步：是否为内置模块\n\tif (NativeModule.exists(filename)) {\n\t\treturn NativeModule.require(filename);\n\t}\n\n\t// 第三步：生成模块实例，存入缓存\n\tvar module = new Module(filename, parent);\n\tModule._cache[filename] = module;\n\n\t// 第四步：加载模块\n\ttry {\n\t\tmodule.load(filename);\n\t\thadException = false;\n\t} finally {\n\t\tif (hadException) {\n\t\t  delete Module._cache[filename];\n\t\t}\n\t}\n\n\t// 第五步：《输出模块的exports属性》\n\treturn module.exports;\n}\n\nModule._resolveFilename = function () {\n\n\t Module._resolveLookupPaths() //查询可能的路径，通常返回一个数组组成的可能路径\n\t Module._findPath() //确定路径是否为真，为真返回，否则false\n}\n\n\nModule.prototype.load = function(filename) {\n\n\t//不同的后缀名对应不同的加载方法\n\tvar extension = path.extname(filename) || '.js';\n\tif (!Module._extensions[extension]) extension = '.js';\n\tModule._extensions[extension](this, filename);\n\tthis.loaded = true;\n};\n\n//js文件读取成字符串，剥离utf8,最后编译该模块\nModule.prototype._compile = function(content, filename) {\n\tvar self = this;\n\tvar args = [self.exports, require, self, filename, dirname];\n\treturn compiledWrapper.apply(self.exports, args);\n};\n\n```\n\n###  总结\n> **模块的加载**实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出\n\n\n```\n(function (exports, require, module, __filename, __dirname) {\n  // 模块源码\n});\n\n```\n\n### 补充：module.exports 与 exports 的区别\n> 1.require操作之前，node环境会自动执行 exports = module.exports\n  2.所以一次看出，exports是module.exports的引用，\n  3.这两者默认都是一个空对象\n\n> 注意事项: require返回的是module.exports\n\n\n\n[参考 http://www.ruanyifeng.com/blog/2015/05/require.html](http://www.ruanyifeng.com/blog/2015/05/require.html)\n\n","slug":"node-模块机制","published":1,"date":"2017-03-04T04:21:40.000Z","updated":"2017-03-04T04:21:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccx000zkzy6f72og3m8","content":"<h3 id=\"CommonJs规范\"><a href=\"#CommonJs规范\" class=\"headerlink\" title=\"CommonJs规范\"></a>CommonJs规范</h3><blockquote>\n<p>模块定义（exports)，模块标识（路径），模块引用（require）</p>\n</blockquote>\n<h3 id=\"模块的分类和查找顺序\"><a href=\"#模块的分类和查找顺序\" class=\"headerlink\" title=\"模块的分类和查找顺序\"></a>模块的分类和查找顺序</h3><blockquote>\n<p>核心模块=&gt;文件模块=&gt;自定义模块</p>\n</blockquote>\n<h3 id=\"引入模块经历的阶段\"><a href=\"#引入模块经历的阶段\" class=\"headerlink\" title=\"引入模块经历的阶段\"></a>引入模块经历的阶段</h3><blockquote>\n<p>1.路径分析，文件定位， 编译执行</p>\n</blockquote>\n<h3 id=\"module构造函数\"><a href=\"#module构造函数\" class=\"headerlink\" title=\"module构造函数\"></a>module构造函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Module(id, parent) &#123;</div><div class=\"line\">  this.id = id;</div><div class=\"line\">  this.exports = &#123;&#125;;</div><div class=\"line\">  this.parent = parent;</div><div class=\"line\">  this.filename = null;</div><div class=\"line\">  this.loaded = false;</div><div class=\"line\">  this.children = [];</div><div class=\"line\">&#125;</div><div class=\"line\">module.exports = Module;</div><div class=\"line\">var module = new Module(filename, parent);</div><div class=\"line\"></div><div class=\"line\">//所有模块都是Module的实例</div></pre></td></tr></table></figure>\n<h3 id=\"模块的实例方法\"><a href=\"#模块的实例方法\" class=\"headerlink\" title=\"模块的实例方法\"></a>模块的实例方法</h3><blockquote>\n<p>每个模块实例都有一个 require 方法（require.resolve(‘path’) ==&gt; 返回一个绝对路径)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">Module.prototype.require = function(path) &#123;</div><div class=\"line\">\treturn Module._load(path, this) //调用内部方法</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Module._load = function(request, parent, isMain) &#123;</div><div class=\"line\"></div><div class=\"line\">\t//  计算绝对路径</div><div class=\"line\">\tvar filename = Module._resolveFilename(request, parent);</div><div class=\"line\"></div><div class=\"line\">\t//  第一步：如果有缓存，取出缓存</div><div class=\"line\">\tvar cachedModule = Module._cache[filename];</div><div class=\"line\">\tif (cachedModule) &#123;</div><div class=\"line\">\t\treturn cachedModule.exports;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 第二步：是否为内置模块</div><div class=\"line\">\tif (NativeModule.exists(filename)) &#123;</div><div class=\"line\">\t\treturn NativeModule.require(filename);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 第三步：生成模块实例，存入缓存</div><div class=\"line\">\tvar module = new Module(filename, parent);</div><div class=\"line\">\tModule._cache[filename] = module;</div><div class=\"line\"></div><div class=\"line\">\t// 第四步：加载模块</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tmodule.load(filename);</div><div class=\"line\">\t\thadException = false;</div><div class=\"line\">\t&#125; finally &#123;</div><div class=\"line\">\t\tif (hadException) &#123;</div><div class=\"line\">\t\t  delete Module._cache[filename];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 第五步：《输出模块的exports属性》</div><div class=\"line\">\treturn module.exports;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Module._resolveFilename = function () &#123;</div><div class=\"line\"></div><div class=\"line\">\t Module._resolveLookupPaths() //查询可能的路径，通常返回一个数组组成的可能路径</div><div class=\"line\">\t Module._findPath() //确定路径是否为真，为真返回，否则false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Module.prototype.load = function(filename) &#123;</div><div class=\"line\"></div><div class=\"line\">\t//不同的后缀名对应不同的加载方法</div><div class=\"line\">\tvar extension = path.extname(filename) || &apos;.js&apos;;</div><div class=\"line\">\tif (!Module._extensions[extension]) extension = &apos;.js&apos;;</div><div class=\"line\">\tModule._extensions[extension](this, filename);</div><div class=\"line\">\tthis.loaded = true;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//js文件读取成字符串，剥离utf8,最后编译该模块</div><div class=\"line\">Module.prototype._compile = function(content, filename) &#123;</div><div class=\"line\">\tvar self = this;</div><div class=\"line\">\tvar args = [self.exports, require, self, filename, dirname];</div><div class=\"line\">\treturn compiledWrapper.apply(self.exports, args);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p><strong>模块的加载</strong>实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (exports, require, module, __filename, __dirname) &#123;</div><div class=\"line\">  // 模块源码</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"补充：module-exports-与-exports-的区别\"><a href=\"#补充：module-exports-与-exports-的区别\" class=\"headerlink\" title=\"补充：module.exports 与 exports 的区别\"></a>补充：module.exports 与 exports 的区别</h3><blockquote>\n<p>1.require操作之前，node环境会自动执行 exports = module.exports<br>  2.所以一次看出，exports是module.exports的引用，<br>  3.这两者默认都是一个空对象</p>\n<p>注意事项: require返回的是module.exports</p>\n</blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/require.html\" target=\"_blank\" rel=\"external\">参考 http://www.ruanyifeng.com/blog/2015/05/require.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CommonJs规范\"><a href=\"#CommonJs规范\" class=\"headerlink\" title=\"CommonJs规范\"></a>CommonJs规范</h3><blockquote>\n<p>模块定义（exports)，模块标识（路径），模块引用（require）</p>\n</blockquote>\n<h3 id=\"模块的分类和查找顺序\"><a href=\"#模块的分类和查找顺序\" class=\"headerlink\" title=\"模块的分类和查找顺序\"></a>模块的分类和查找顺序</h3><blockquote>\n<p>核心模块=&gt;文件模块=&gt;自定义模块</p>\n</blockquote>\n<h3 id=\"引入模块经历的阶段\"><a href=\"#引入模块经历的阶段\" class=\"headerlink\" title=\"引入模块经历的阶段\"></a>引入模块经历的阶段</h3><blockquote>\n<p>1.路径分析，文件定位， 编译执行</p>\n</blockquote>\n<h3 id=\"module构造函数\"><a href=\"#module构造函数\" class=\"headerlink\" title=\"module构造函数\"></a>module构造函数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Module(id, parent) &#123;</div><div class=\"line\">  this.id = id;</div><div class=\"line\">  this.exports = &#123;&#125;;</div><div class=\"line\">  this.parent = parent;</div><div class=\"line\">  this.filename = null;</div><div class=\"line\">  this.loaded = false;</div><div class=\"line\">  this.children = [];</div><div class=\"line\">&#125;</div><div class=\"line\">module.exports = Module;</div><div class=\"line\">var module = new Module(filename, parent);</div><div class=\"line\"></div><div class=\"line\">//所有模块都是Module的实例</div></pre></td></tr></table></figure>\n<h3 id=\"模块的实例方法\"><a href=\"#模块的实例方法\" class=\"headerlink\" title=\"模块的实例方法\"></a>模块的实例方法</h3><blockquote>\n<p>每个模块实例都有一个 require 方法（require.resolve(‘path’) ==&gt; 返回一个绝对路径)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">Module.prototype.require = function(path) &#123;</div><div class=\"line\">\treturn Module._load(path, this) //调用内部方法</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Module._load = function(request, parent, isMain) &#123;</div><div class=\"line\"></div><div class=\"line\">\t//  计算绝对路径</div><div class=\"line\">\tvar filename = Module._resolveFilename(request, parent);</div><div class=\"line\"></div><div class=\"line\">\t//  第一步：如果有缓存，取出缓存</div><div class=\"line\">\tvar cachedModule = Module._cache[filename];</div><div class=\"line\">\tif (cachedModule) &#123;</div><div class=\"line\">\t\treturn cachedModule.exports;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 第二步：是否为内置模块</div><div class=\"line\">\tif (NativeModule.exists(filename)) &#123;</div><div class=\"line\">\t\treturn NativeModule.require(filename);</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 第三步：生成模块实例，存入缓存</div><div class=\"line\">\tvar module = new Module(filename, parent);</div><div class=\"line\">\tModule._cache[filename] = module;</div><div class=\"line\"></div><div class=\"line\">\t// 第四步：加载模块</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tmodule.load(filename);</div><div class=\"line\">\t\thadException = false;</div><div class=\"line\">\t&#125; finally &#123;</div><div class=\"line\">\t\tif (hadException) &#123;</div><div class=\"line\">\t\t  delete Module._cache[filename];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// 第五步：《输出模块的exports属性》</div><div class=\"line\">\treturn module.exports;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Module._resolveFilename = function () &#123;</div><div class=\"line\"></div><div class=\"line\">\t Module._resolveLookupPaths() //查询可能的路径，通常返回一个数组组成的可能路径</div><div class=\"line\">\t Module._findPath() //确定路径是否为真，为真返回，否则false</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Module.prototype.load = function(filename) &#123;</div><div class=\"line\"></div><div class=\"line\">\t//不同的后缀名对应不同的加载方法</div><div class=\"line\">\tvar extension = path.extname(filename) || &apos;.js&apos;;</div><div class=\"line\">\tif (!Module._extensions[extension]) extension = &apos;.js&apos;;</div><div class=\"line\">\tModule._extensions[extension](this, filename);</div><div class=\"line\">\tthis.loaded = true;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//js文件读取成字符串，剥离utf8,最后编译该模块</div><div class=\"line\">Module.prototype._compile = function(content, filename) &#123;</div><div class=\"line\">\tvar self = this;</div><div class=\"line\">\tvar args = [self.exports, require, self, filename, dirname];</div><div class=\"line\">\treturn compiledWrapper.apply(self.exports, args);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p><strong>模块的加载</strong>实质上就是，注入exports、require、module三个全局变量，然后执行模块的源码，然后将模块的 exports 变量的值输出</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function (exports, require, module, __filename, __dirname) &#123;</div><div class=\"line\">  // 模块源码</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"补充：module-exports-与-exports-的区别\"><a href=\"#补充：module-exports-与-exports-的区别\" class=\"headerlink\" title=\"补充：module.exports 与 exports 的区别\"></a>补充：module.exports 与 exports 的区别</h3><blockquote>\n<p>1.require操作之前，node环境会自动执行 exports = module.exports<br>  2.所以一次看出，exports是module.exports的引用，<br>  3.这两者默认都是一个空对象</p>\n<p>注意事项: require返回的是module.exports</p>\n</blockquote>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/require.html\" target=\"_blank\" rel=\"external\">参考 http://www.ruanyifeng.com/blog/2015/05/require.html</a></p>\n"},{"title":"网络编程","type":"categories","_content":"\n# 构建TCP服务\nTCP全名传输控制协议，属于OSI模型的传输层协议，应用层协议基于TCP构建，典型是HTTP、SMTP、IMAP协议，TCP是面向连接的协议，显著的特征，传输之前需要进行三次握手形成会话\n## 创建TCP服务器端\n创建了服务端，可以通过Telnet工具，nc工具作为客户端和net模块自行构造客户端和服务器进行会话交流\n## TCP服务端的事件\n### 服务器事件\n### 连接事件\n\n\n# 构建UDP服务\n用户数据包协议，也属于网络传输层，UDP不是面向连接的，TCP一旦连接建立，所有的会话基于连接完成，TCP通过套接字来完成和客户端的连接，客户端如果要连接另一个TCP服务通信，需要创建一个套接字来完成连接。但是UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网路差的情况下容易丢失包，但是由于他无需连接，资源消耗低，所以适用偶尔丢失一个包不会产生什么影响的场景，比如音频，视频等，DNS服务也是基于UDP实现的\n\n# 构建HTTP服务\n\n# 构建HTTP服务\n# 构建websoket服务\n# 网路服务与安全\n","source":"_posts/node/网络编程.md","raw":"---\ntitle: 网络编程\ntype: \"categories\"\ncategories: 后端\n---\n\n# 构建TCP服务\nTCP全名传输控制协议，属于OSI模型的传输层协议，应用层协议基于TCP构建，典型是HTTP、SMTP、IMAP协议，TCP是面向连接的协议，显著的特征，传输之前需要进行三次握手形成会话\n## 创建TCP服务器端\n创建了服务端，可以通过Telnet工具，nc工具作为客户端和net模块自行构造客户端和服务器进行会话交流\n## TCP服务端的事件\n### 服务器事件\n### 连接事件\n\n\n# 构建UDP服务\n用户数据包协议，也属于网络传输层，UDP不是面向连接的，TCP一旦连接建立，所有的会话基于连接完成，TCP通过套接字来完成和客户端的连接，客户端如果要连接另一个TCP服务通信，需要创建一个套接字来完成连接。但是UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网路差的情况下容易丢失包，但是由于他无需连接，资源消耗低，所以适用偶尔丢失一个包不会产生什么影响的场景，比如音频，视频等，DNS服务也是基于UDP实现的\n\n# 构建HTTP服务\n\n# 构建HTTP服务\n# 构建websoket服务\n# 网路服务与安全\n","slug":"node-网络编程","published":1,"date":"2017-09-14T10:53:59.000Z","updated":"2017-09-14T10:53:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ccz0011kzy60b8f91qn","content":"<h1 id=\"构建TCP服务\"><a href=\"#构建TCP服务\" class=\"headerlink\" title=\"构建TCP服务\"></a>构建TCP服务</h1><p>TCP全名传输控制协议，属于OSI模型的传输层协议，应用层协议基于TCP构建，典型是HTTP、SMTP、IMAP协议，TCP是面向连接的协议，显著的特征，传输之前需要进行三次握手形成会话</p>\n<h2 id=\"创建TCP服务器端\"><a href=\"#创建TCP服务器端\" class=\"headerlink\" title=\"创建TCP服务器端\"></a>创建TCP服务器端</h2><p>创建了服务端，可以通过Telnet工具，nc工具作为客户端和net模块自行构造客户端和服务器进行会话交流</p>\n<h2 id=\"TCP服务端的事件\"><a href=\"#TCP服务端的事件\" class=\"headerlink\" title=\"TCP服务端的事件\"></a>TCP服务端的事件</h2><h3 id=\"服务器事件\"><a href=\"#服务器事件\" class=\"headerlink\" title=\"服务器事件\"></a>服务器事件</h3><h3 id=\"连接事件\"><a href=\"#连接事件\" class=\"headerlink\" title=\"连接事件\"></a>连接事件</h3><h1 id=\"构建UDP服务\"><a href=\"#构建UDP服务\" class=\"headerlink\" title=\"构建UDP服务\"></a>构建UDP服务</h1><p>用户数据包协议，也属于网络传输层，UDP不是面向连接的，TCP一旦连接建立，所有的会话基于连接完成，TCP通过套接字来完成和客户端的连接，客户端如果要连接另一个TCP服务通信，需要创建一个套接字来完成连接。但是UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网路差的情况下容易丢失包，但是由于他无需连接，资源消耗低，所以适用偶尔丢失一个包不会产生什么影响的场景，比如音频，视频等，DNS服务也是基于UDP实现的</p>\n<h1 id=\"构建HTTP服务\"><a href=\"#构建HTTP服务\" class=\"headerlink\" title=\"构建HTTP服务\"></a>构建HTTP服务</h1><h1 id=\"构建HTTP服务-1\"><a href=\"#构建HTTP服务-1\" class=\"headerlink\" title=\"构建HTTP服务\"></a>构建HTTP服务</h1><h1 id=\"构建websoket服务\"><a href=\"#构建websoket服务\" class=\"headerlink\" title=\"构建websoket服务\"></a>构建websoket服务</h1><h1 id=\"网路服务与安全\"><a href=\"#网路服务与安全\" class=\"headerlink\" title=\"网路服务与安全\"></a>网路服务与安全</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"构建TCP服务\"><a href=\"#构建TCP服务\" class=\"headerlink\" title=\"构建TCP服务\"></a>构建TCP服务</h1><p>TCP全名传输控制协议，属于OSI模型的传输层协议，应用层协议基于TCP构建，典型是HTTP、SMTP、IMAP协议，TCP是面向连接的协议，显著的特征，传输之前需要进行三次握手形成会话</p>\n<h2 id=\"创建TCP服务器端\"><a href=\"#创建TCP服务器端\" class=\"headerlink\" title=\"创建TCP服务器端\"></a>创建TCP服务器端</h2><p>创建了服务端，可以通过Telnet工具，nc工具作为客户端和net模块自行构造客户端和服务器进行会话交流</p>\n<h2 id=\"TCP服务端的事件\"><a href=\"#TCP服务端的事件\" class=\"headerlink\" title=\"TCP服务端的事件\"></a>TCP服务端的事件</h2><h3 id=\"服务器事件\"><a href=\"#服务器事件\" class=\"headerlink\" title=\"服务器事件\"></a>服务器事件</h3><h3 id=\"连接事件\"><a href=\"#连接事件\" class=\"headerlink\" title=\"连接事件\"></a>连接事件</h3><h1 id=\"构建UDP服务\"><a href=\"#构建UDP服务\" class=\"headerlink\" title=\"构建UDP服务\"></a>构建UDP服务</h1><p>用户数据包协议，也属于网络传输层，UDP不是面向连接的，TCP一旦连接建立，所有的会话基于连接完成，TCP通过套接字来完成和客户端的连接，客户端如果要连接另一个TCP服务通信，需要创建一个套接字来完成连接。但是UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网路差的情况下容易丢失包，但是由于他无需连接，资源消耗低，所以适用偶尔丢失一个包不会产生什么影响的场景，比如音频，视频等，DNS服务也是基于UDP实现的</p>\n<h1 id=\"构建HTTP服务\"><a href=\"#构建HTTP服务\" class=\"headerlink\" title=\"构建HTTP服务\"></a>构建HTTP服务</h1><h1 id=\"构建HTTP服务-1\"><a href=\"#构建HTTP服务-1\" class=\"headerlink\" title=\"构建HTTP服务\"></a>构建HTTP服务</h1><h1 id=\"构建websoket服务\"><a href=\"#构建websoket服务\" class=\"headerlink\" title=\"构建websoket服务\"></a>构建websoket服务</h1><h1 id=\"网路服务与安全\"><a href=\"#网路服务与安全\" class=\"headerlink\" title=\"网路服务与安全\"></a>网路服务与安全</h1>"},{"title":"进程和线程的关系","type":"categories","_content":"\n# 区别\n进程\n- 有独立的堆栈空间和数据段，所以每当启动一个新的进程需要分配空间，所以比较奢侈，系统开销大，但是因为独立，所以进程安全性高，一个进程、\n- 通信机制上，进程因为独立，通信机制复杂，如，管道、信号、消息队列、共享内存、套接字\n线程\n- 线程拥有独立的堆栈空间，但是共享数据段，彼此之间使用相同的地址空间，开销小，切换速度快，效率快\n- cpu上，线程是cpu的基本单位，线程使cpu更加高效，操作系统会保证当前线程数不大于CPU的数目，不同的线程运行与不同的CPU上\n\n# 联系\n\n当一个进程中有多线程时，我们在其中一个线程fork下，创建新进程，子进程拥有父进程一样的内存和数据，但是**子进程不会像父进程是多线程的**\n\n# 选择\n- 需要频创建和销毁的，优先使用线程\n- 大量计算，频发切换，耗时用线程\n- cpu效率问题，多机分布用进程，多核分布用线程\n- 稳定安全用进程，速度用线程\n\n[参考](http://veaxen.com/?p=360)","source":"_posts/node/进程和线程的关系.md","raw":"---\ntitle: 进程和线程的关系\ntype: \"categories\"\ncategories: 后端\n---\n\n# 区别\n进程\n- 有独立的堆栈空间和数据段，所以每当启动一个新的进程需要分配空间，所以比较奢侈，系统开销大，但是因为独立，所以进程安全性高，一个进程、\n- 通信机制上，进程因为独立，通信机制复杂，如，管道、信号、消息队列、共享内存、套接字\n线程\n- 线程拥有独立的堆栈空间，但是共享数据段，彼此之间使用相同的地址空间，开销小，切换速度快，效率快\n- cpu上，线程是cpu的基本单位，线程使cpu更加高效，操作系统会保证当前线程数不大于CPU的数目，不同的线程运行与不同的CPU上\n\n# 联系\n\n当一个进程中有多线程时，我们在其中一个线程fork下，创建新进程，子进程拥有父进程一样的内存和数据，但是**子进程不会像父进程是多线程的**\n\n# 选择\n- 需要频创建和销毁的，优先使用线程\n- 大量计算，频发切换，耗时用线程\n- cpu效率问题，多机分布用进程，多核分布用线程\n- 稳定安全用进程，速度用线程\n\n[参考](http://veaxen.com/?p=360)","slug":"node-进程和线程的关系","published":1,"date":"2017-09-14T10:55:08.000Z","updated":"2017-09-14T11:35:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cd10014kzy6u1s1ysr5","content":"<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>进程</p>\n<ul>\n<li>有独立的堆栈空间和数据段，所以每当启动一个新的进程需要分配空间，所以比较奢侈，系统开销大，但是因为独立，所以进程安全性高，一个进程、</li>\n<li>通信机制上，进程因为独立，通信机制复杂，如，管道、信号、消息队列、共享内存、套接字<br>线程</li>\n<li>线程拥有独立的堆栈空间，但是共享数据段，彼此之间使用相同的地址空间，开销小，切换速度快，效率快</li>\n<li>cpu上，线程是cpu的基本单位，线程使cpu更加高效，操作系统会保证当前线程数不大于CPU的数目，不同的线程运行与不同的CPU上</li>\n</ul>\n<h1 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h1><p>当一个进程中有多线程时，我们在其中一个线程fork下，创建新进程，子进程拥有父进程一样的内存和数据，但是<strong>子进程不会像父进程是多线程的</strong></p>\n<h1 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h1><ul>\n<li>需要频创建和销毁的，优先使用线程</li>\n<li>大量计算，频发切换，耗时用线程</li>\n<li>cpu效率问题，多机分布用进程，多核分布用线程</li>\n<li>稳定安全用进程，速度用线程</li>\n</ul>\n<p><a href=\"http://veaxen.com/?p=360\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>进程</p>\n<ul>\n<li>有独立的堆栈空间和数据段，所以每当启动一个新的进程需要分配空间，所以比较奢侈，系统开销大，但是因为独立，所以进程安全性高，一个进程、</li>\n<li>通信机制上，进程因为独立，通信机制复杂，如，管道、信号、消息队列、共享内存、套接字<br>线程</li>\n<li>线程拥有独立的堆栈空间，但是共享数据段，彼此之间使用相同的地址空间，开销小，切换速度快，效率快</li>\n<li>cpu上，线程是cpu的基本单位，线程使cpu更加高效，操作系统会保证当前线程数不大于CPU的数目，不同的线程运行与不同的CPU上</li>\n</ul>\n<h1 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h1><p>当一个进程中有多线程时，我们在其中一个线程fork下，创建新进程，子进程拥有父进程一样的内存和数据，但是<strong>子进程不会像父进程是多线程的</strong></p>\n<h1 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h1><ul>\n<li>需要频创建和销毁的，优先使用线程</li>\n<li>大量计算，频发切换，耗时用线程</li>\n<li>cpu效率问题，多机分布用进程，多核分布用线程</li>\n<li>稳定安全用进程，速度用线程</li>\n</ul>\n<p><a href=\"http://veaxen.com/?p=360\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"进程","type":"categories","_content":"\n# 配置\n定义配置文件、环境变量\n\n# Child Process\nchild_process模块来将 .js 代码以子进程的方式启动，有以下方式：\n- spawn()\n- spawnSync()\n- exec()\n- execSync()\n- execFile()\n- execFileSync()\n- fork() 加强版spawn，返回的ChildProcess 对象可以与子进程交互\n\n## child.kill 与 child.send\n一个是基于信号系统, 一个是基于 IPC\n- 父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?\n子进程死亡不会影响父进程的，但是子进程是线程组里的最后一个的时候会发死亡信号通知父进程\n父进程死亡的话，一般情况子进程也会死掉，但是恰巧如果子进程正在运行时，子进程会被收养变成孤儿进程\n如果子进程死亡的时候，父进程没有及时调用wait()或者waitpid()返回进程的相关信息，被称为僵尸进程\n\n# Cluster\nCluster 是常见的 Node.js 利用多核的办法. 是基于child_process实现的，cluster产生的进程之间是通过IPC来通信的，可以通过 IPC 在主进程和子进程之间相互传递服务器句柄，并没有拷贝父进程，通过cluster.isMaster 标识\n\n## cluster 模块提供了两种分发连接的方式.\n- 轮询法，句柄发送与还原\n- 端口共同监听\n\n# 进程间通信\n应用层上，主进程之间通过onmessage()和postMessage()进行通信，子进程对象由send()方法实现主进程向子进程发送数据，message事件则实现收听子进程发来的数据\n实现进程之间的通信技术：\n- 命名管道、匿名管道、socket、信号量、共享内存、消息队列等\nnode实现IPC通道通过管道（pipe)技术，细节实现有libuv提供，以下是大体过程：\n父进程在创造子进程之前，会**创建IPC通道并且监听它**，然后再创建子进程，并通过**环境变量（NODE_CHANNEL_FD)**告诉子进程这个IPC通道的**文件描述符**。子进程在启动的过程中通过这个文件描述符去连接这个已经存在的的IPC通道，从而完成父子进程之间的连接\n\n# 守护进程\n简单的说就是不会因为用户退出终端而停止运行的进程.","source":"_posts/node/进程.md","raw":"---\ntitle: 进程\ntype: \"categories\"\ncategories: 后端\n---\n\n# 配置\n定义配置文件、环境变量\n\n# Child Process\nchild_process模块来将 .js 代码以子进程的方式启动，有以下方式：\n- spawn()\n- spawnSync()\n- exec()\n- execSync()\n- execFile()\n- execFileSync()\n- fork() 加强版spawn，返回的ChildProcess 对象可以与子进程交互\n\n## child.kill 与 child.send\n一个是基于信号系统, 一个是基于 IPC\n- 父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?\n子进程死亡不会影响父进程的，但是子进程是线程组里的最后一个的时候会发死亡信号通知父进程\n父进程死亡的话，一般情况子进程也会死掉，但是恰巧如果子进程正在运行时，子进程会被收养变成孤儿进程\n如果子进程死亡的时候，父进程没有及时调用wait()或者waitpid()返回进程的相关信息，被称为僵尸进程\n\n# Cluster\nCluster 是常见的 Node.js 利用多核的办法. 是基于child_process实现的，cluster产生的进程之间是通过IPC来通信的，可以通过 IPC 在主进程和子进程之间相互传递服务器句柄，并没有拷贝父进程，通过cluster.isMaster 标识\n\n## cluster 模块提供了两种分发连接的方式.\n- 轮询法，句柄发送与还原\n- 端口共同监听\n\n# 进程间通信\n应用层上，主进程之间通过onmessage()和postMessage()进行通信，子进程对象由send()方法实现主进程向子进程发送数据，message事件则实现收听子进程发来的数据\n实现进程之间的通信技术：\n- 命名管道、匿名管道、socket、信号量、共享内存、消息队列等\nnode实现IPC通道通过管道（pipe)技术，细节实现有libuv提供，以下是大体过程：\n父进程在创造子进程之前，会**创建IPC通道并且监听它**，然后再创建子进程，并通过**环境变量（NODE_CHANNEL_FD)**告诉子进程这个IPC通道的**文件描述符**。子进程在启动的过程中通过这个文件描述符去连接这个已经存在的的IPC通道，从而完成父子进程之间的连接\n\n# 守护进程\n简单的说就是不会因为用户退出终端而停止运行的进程.","slug":"node-进程","published":1,"date":"2017-09-14T10:53:59.000Z","updated":"2017-09-14T10:53:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cd20016kzy6p6d3jztv","content":"<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>定义配置文件、环境变量</p>\n<h1 id=\"Child-Process\"><a href=\"#Child-Process\" class=\"headerlink\" title=\"Child Process\"></a>Child Process</h1><p>child_process模块来将 .js 代码以子进程的方式启动，有以下方式：</p>\n<ul>\n<li>spawn()</li>\n<li>spawnSync()</li>\n<li>exec()</li>\n<li>execSync()</li>\n<li>execFile()</li>\n<li>execFileSync()</li>\n<li>fork() 加强版spawn，返回的ChildProcess 对象可以与子进程交互</li>\n</ul>\n<h2 id=\"child-kill-与-child-send\"><a href=\"#child-kill-与-child-send\" class=\"headerlink\" title=\"child.kill 与 child.send\"></a>child.kill 与 child.send</h2><p>一个是基于信号系统, 一个是基于 IPC</p>\n<ul>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?<br>子进程死亡不会影响父进程的，但是子进程是线程组里的最后一个的时候会发死亡信号通知父进程<br>父进程死亡的话，一般情况子进程也会死掉，但是恰巧如果子进程正在运行时，子进程会被收养变成孤儿进程<br>如果子进程死亡的时候，父进程没有及时调用wait()或者waitpid()返回进程的相关信息，被称为僵尸进程</li>\n</ul>\n<h1 id=\"Cluster\"><a href=\"#Cluster\" class=\"headerlink\" title=\"Cluster\"></a>Cluster</h1><p>Cluster 是常见的 Node.js 利用多核的办法. 是基于child_process实现的，cluster产生的进程之间是通过IPC来通信的，可以通过 IPC 在主进程和子进程之间相互传递服务器句柄，并没有拷贝父进程，通过cluster.isMaster 标识</p>\n<h2 id=\"cluster-模块提供了两种分发连接的方式\"><a href=\"#cluster-模块提供了两种分发连接的方式\" class=\"headerlink\" title=\"cluster 模块提供了两种分发连接的方式.\"></a>cluster 模块提供了两种分发连接的方式.</h2><ul>\n<li>轮询法，句柄发送与还原</li>\n<li>端口共同监听</li>\n</ul>\n<h1 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h1><p>应用层上，主进程之间通过onmessage()和postMessage()进行通信，子进程对象由send()方法实现主进程向子进程发送数据，message事件则实现收听子进程发来的数据<br>实现进程之间的通信技术：</p>\n<ul>\n<li>命名管道、匿名管道、socket、信号量、共享内存、消息队列等<br>node实现IPC通道通过管道（pipe)技术，细节实现有libuv提供，以下是大体过程：<br>父进程在创造子进程之前，会<strong>创建IPC通道并且监听它</strong>，然后再创建子进程，并通过<strong>环境变量（NODE_CHANNEL_FD)</strong>告诉子进程这个IPC通道的<strong>文件描述符</strong>。子进程在启动的过程中通过这个文件描述符去连接这个已经存在的的IPC通道，从而完成父子进程之间的连接</li>\n</ul>\n<h1 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h1><p>简单的说就是不会因为用户退出终端而停止运行的进程.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>定义配置文件、环境变量</p>\n<h1 id=\"Child-Process\"><a href=\"#Child-Process\" class=\"headerlink\" title=\"Child Process\"></a>Child Process</h1><p>child_process模块来将 .js 代码以子进程的方式启动，有以下方式：</p>\n<ul>\n<li>spawn()</li>\n<li>spawnSync()</li>\n<li>exec()</li>\n<li>execSync()</li>\n<li>execFile()</li>\n<li>execFileSync()</li>\n<li>fork() 加强版spawn，返回的ChildProcess 对象可以与子进程交互</li>\n</ul>\n<h2 id=\"child-kill-与-child-send\"><a href=\"#child-kill-与-child-send\" class=\"headerlink\" title=\"child.kill 与 child.send\"></a>child.kill 与 child.send</h2><p>一个是基于信号系统, 一个是基于 IPC</p>\n<ul>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程?<br>子进程死亡不会影响父进程的，但是子进程是线程组里的最后一个的时候会发死亡信号通知父进程<br>父进程死亡的话，一般情况子进程也会死掉，但是恰巧如果子进程正在运行时，子进程会被收养变成孤儿进程<br>如果子进程死亡的时候，父进程没有及时调用wait()或者waitpid()返回进程的相关信息，被称为僵尸进程</li>\n</ul>\n<h1 id=\"Cluster\"><a href=\"#Cluster\" class=\"headerlink\" title=\"Cluster\"></a>Cluster</h1><p>Cluster 是常见的 Node.js 利用多核的办法. 是基于child_process实现的，cluster产生的进程之间是通过IPC来通信的，可以通过 IPC 在主进程和子进程之间相互传递服务器句柄，并没有拷贝父进程，通过cluster.isMaster 标识</p>\n<h2 id=\"cluster-模块提供了两种分发连接的方式\"><a href=\"#cluster-模块提供了两种分发连接的方式\" class=\"headerlink\" title=\"cluster 模块提供了两种分发连接的方式.\"></a>cluster 模块提供了两种分发连接的方式.</h2><ul>\n<li>轮询法，句柄发送与还原</li>\n<li>端口共同监听</li>\n</ul>\n<h1 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h1><p>应用层上，主进程之间通过onmessage()和postMessage()进行通信，子进程对象由send()方法实现主进程向子进程发送数据，message事件则实现收听子进程发来的数据<br>实现进程之间的通信技术：</p>\n<ul>\n<li>命名管道、匿名管道、socket、信号量、共享内存、消息队列等<br>node实现IPC通道通过管道（pipe)技术，细节实现有libuv提供，以下是大体过程：<br>父进程在创造子进程之前，会<strong>创建IPC通道并且监听它</strong>，然后再创建子进程，并通过<strong>环境变量（NODE_CHANNEL_FD)</strong>告诉子进程这个IPC通道的<strong>文件描述符</strong>。子进程在启动的过程中通过这个文件描述符去连接这个已经存在的的IPC通道，从而完成父子进程之间的连接</li>\n</ul>\n<h1 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h1><p>简单的说就是不会因为用户退出终端而停止运行的进程.</p>\n"},{"title":"高效利用内存","type":"categories","_content":"\n# 高效利用内存\n前面已经介绍了内存限制和垃圾回收机制，了解了高效的使用内存的重要性，那么在V8中，开发者如何让垃圾回收机制更高效的工作\n\n## 作用域\n首先，如何触发垃圾回收呢，我们先来介绍作用域，在js中能形成作用域的有函数调用，with以及全局作用域\n\n```\nvar foo = function() {\n\tvar local = {}\n}\n```\nfoo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域被销毁，同时作用域中声明的局部变量分配在该作用域上，随着作用域的销毁而销毁。只是被局部变量引用的对象存活周期短。在上面的例子中，由于对象非常小，将会被分配到新生代的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放，以上就是最基本的垃圾回收过程\n\n## 标识符查找\n**与作用域相关的就是标识符的查找，所谓标识符，可以把它看做变量名，**在下面的代码中，执行bar()函数时，将会遇到local变量\n```\nvar bar = function() {\n\tconsole.log(local)\n}\n```\njavascript执行的时候会去查找该变量定义在哪里，最先查找的是当前作用域，若无，则往上层作用域找\n\n## 作用域链\n由于标识符的查找方向是向上的，所以变量只能向外访问\n\n## 变量的主动释放\n由于全局变量驻扎在全局作用域中，需要退出进程才能释放，此时会导致常驻在内存（老生代）中，如果需要删除，通过delete删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理过程中，会被回收释放。但是最好通过赋值方式解除最好，delete删除对象的属性会干扰V8的优化\n\n## 闭包\n在javascript中，**实现外部作用域访问内部作用域中变量的方法叫做闭包**\n```\nvar foo = function() {\n\tvar bar = function() {\n\t\tvar local = '局部变量'\n\t\treturn function() {\n\t\t\treturn local\n\t\t}\n\t}\n\tvar baz = bar()\n\treturn baz\n}\n```\n- 一般来说bar函数执行完毕local会随着作用域的销毁而销毁，但是这里返回值是一个匿名函数，且这个函数具备了访问local的条件。这得益于高阶函数的特性，函数可以作为参数和返回值\n- 外部作用域可以通过这个中间函数稍作周转就可以访问到内部作用域的变量\n- 一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放，除非不在有引用才会释放。\n\n# 总结\n在正常的javascript中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存的限制，要十分小心此类变量是否无限制增加，因为会导致老生代中的对象增多\n\n","source":"_posts/node/高效利用内存.md","raw":"---\ntitle: 高效利用内存\ntype: \"categories\"\ncategories: 后端\n---\n\n# 高效利用内存\n前面已经介绍了内存限制和垃圾回收机制，了解了高效的使用内存的重要性，那么在V8中，开发者如何让垃圾回收机制更高效的工作\n\n## 作用域\n首先，如何触发垃圾回收呢，我们先来介绍作用域，在js中能形成作用域的有函数调用，with以及全局作用域\n\n```\nvar foo = function() {\n\tvar local = {}\n}\n```\nfoo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域被销毁，同时作用域中声明的局部变量分配在该作用域上，随着作用域的销毁而销毁。只是被局部变量引用的对象存活周期短。在上面的例子中，由于对象非常小，将会被分配到新生代的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放，以上就是最基本的垃圾回收过程\n\n## 标识符查找\n**与作用域相关的就是标识符的查找，所谓标识符，可以把它看做变量名，**在下面的代码中，执行bar()函数时，将会遇到local变量\n```\nvar bar = function() {\n\tconsole.log(local)\n}\n```\njavascript执行的时候会去查找该变量定义在哪里，最先查找的是当前作用域，若无，则往上层作用域找\n\n## 作用域链\n由于标识符的查找方向是向上的，所以变量只能向外访问\n\n## 变量的主动释放\n由于全局变量驻扎在全局作用域中，需要退出进程才能释放，此时会导致常驻在内存（老生代）中，如果需要删除，通过delete删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理过程中，会被回收释放。但是最好通过赋值方式解除最好，delete删除对象的属性会干扰V8的优化\n\n## 闭包\n在javascript中，**实现外部作用域访问内部作用域中变量的方法叫做闭包**\n```\nvar foo = function() {\n\tvar bar = function() {\n\t\tvar local = '局部变量'\n\t\treturn function() {\n\t\t\treturn local\n\t\t}\n\t}\n\tvar baz = bar()\n\treturn baz\n}\n```\n- 一般来说bar函数执行完毕local会随着作用域的销毁而销毁，但是这里返回值是一个匿名函数，且这个函数具备了访问local的条件。这得益于高阶函数的特性，函数可以作为参数和返回值\n- 外部作用域可以通过这个中间函数稍作周转就可以访问到内部作用域的变量\n- 一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放，除非不在有引用才会释放。\n\n# 总结\n在正常的javascript中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存的限制，要十分小心此类变量是否无限制增加，因为会导致老生代中的对象增多\n\n","slug":"node-高效利用内存","published":1,"date":"2017-07-25T02:41:31.000Z","updated":"2017-07-25T02:41:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cd90019kzy6dn79boxr","content":"<h1 id=\"高效利用内存\"><a href=\"#高效利用内存\" class=\"headerlink\" title=\"高效利用内存\"></a>高效利用内存</h1><p>前面已经介绍了内存限制和垃圾回收机制，了解了高效的使用内存的重要性，那么在V8中，开发者如何让垃圾回收机制更高效的工作</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>首先，如何触发垃圾回收呢，我们先来介绍作用域，在js中能形成作用域的有函数调用，with以及全局作用域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function() &#123;</div><div class=\"line\">\tvar local = &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>foo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域被销毁，同时作用域中声明的局部变量分配在该作用域上，随着作用域的销毁而销毁。只是被局部变量引用的对象存活周期短。在上面的例子中，由于对象非常小，将会被分配到新生代的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放，以上就是最基本的垃圾回收过程</p>\n<h2 id=\"标识符查找\"><a href=\"#标识符查找\" class=\"headerlink\" title=\"标识符查找\"></a>标识符查找</h2><p><strong>与作用域相关的就是标识符的查找，所谓标识符，可以把它看做变量名，</strong>在下面的代码中，执行bar()函数时，将会遇到local变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var bar = function() &#123;</div><div class=\"line\">\tconsole.log(local)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>javascript执行的时候会去查找该变量定义在哪里，最先查找的是当前作用域，若无，则往上层作用域找</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>由于标识符的查找方向是向上的，所以变量只能向外访问</p>\n<h2 id=\"变量的主动释放\"><a href=\"#变量的主动释放\" class=\"headerlink\" title=\"变量的主动释放\"></a>变量的主动释放</h2><p>由于全局变量驻扎在全局作用域中，需要退出进程才能释放，此时会导致常驻在内存（老生代）中，如果需要删除，通过delete删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理过程中，会被回收释放。但是最好通过赋值方式解除最好，delete删除对象的属性会干扰V8的优化</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在javascript中，<strong>实现外部作用域访问内部作用域中变量的方法叫做闭包</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function() &#123;</div><div class=\"line\">\tvar bar = function() &#123;</div><div class=\"line\">\t\tvar local = &apos;局部变量&apos;</div><div class=\"line\">\t\treturn function() &#123;</div><div class=\"line\">\t\t\treturn local</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tvar baz = bar()</div><div class=\"line\">\treturn baz</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>一般来说bar函数执行完毕local会随着作用域的销毁而销毁，但是这里返回值是一个匿名函数，且这个函数具备了访问local的条件。这得益于高阶函数的特性，函数可以作为参数和返回值</li>\n<li>外部作用域可以通过这个中间函数稍作周转就可以访问到内部作用域的变量</li>\n<li>一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放，除非不在有引用才会释放。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在正常的javascript中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存的限制，要十分小心此类变量是否无限制增加，因为会导致老生代中的对象增多</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"高效利用内存\"><a href=\"#高效利用内存\" class=\"headerlink\" title=\"高效利用内存\"></a>高效利用内存</h1><p>前面已经介绍了内存限制和垃圾回收机制，了解了高效的使用内存的重要性，那么在V8中，开发者如何让垃圾回收机制更高效的工作</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>首先，如何触发垃圾回收呢，我们先来介绍作用域，在js中能形成作用域的有函数调用，with以及全局作用域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function() &#123;</div><div class=\"line\">\tvar local = &#123;&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>foo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域被销毁，同时作用域中声明的局部变量分配在该作用域上，随着作用域的销毁而销毁。只是被局部变量引用的对象存活周期短。在上面的例子中，由于对象非常小，将会被分配到新生代的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放，以上就是最基本的垃圾回收过程</p>\n<h2 id=\"标识符查找\"><a href=\"#标识符查找\" class=\"headerlink\" title=\"标识符查找\"></a>标识符查找</h2><p><strong>与作用域相关的就是标识符的查找，所谓标识符，可以把它看做变量名，</strong>在下面的代码中，执行bar()函数时，将会遇到local变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">var bar = function() &#123;</div><div class=\"line\">\tconsole.log(local)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>javascript执行的时候会去查找该变量定义在哪里，最先查找的是当前作用域，若无，则往上层作用域找</p>\n<h2 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h2><p>由于标识符的查找方向是向上的，所以变量只能向外访问</p>\n<h2 id=\"变量的主动释放\"><a href=\"#变量的主动释放\" class=\"headerlink\" title=\"变量的主动释放\"></a>变量的主动释放</h2><p>由于全局变量驻扎在全局作用域中，需要退出进程才能释放，此时会导致常驻在内存（老生代）中，如果需要删除，通过delete删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理过程中，会被回收释放。但是最好通过赋值方式解除最好，delete删除对象的属性会干扰V8的优化</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>在javascript中，<strong>实现外部作用域访问内部作用域中变量的方法叫做闭包</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var foo = function() &#123;</div><div class=\"line\">\tvar bar = function() &#123;</div><div class=\"line\">\t\tvar local = &apos;局部变量&apos;</div><div class=\"line\">\t\treturn function() &#123;</div><div class=\"line\">\t\t\treturn local</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tvar baz = bar()</div><div class=\"line\">\treturn baz</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>一般来说bar函数执行完毕local会随着作用域的销毁而销毁，但是这里返回值是一个匿名函数，且这个函数具备了访问local的条件。这得益于高阶函数的特性，函数可以作为参数和返回值</li>\n<li>外部作用域可以通过这个中间函数稍作周转就可以访问到内部作用域的变量</li>\n<li>一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放，除非不在有引用才会释放。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在正常的javascript中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存的限制，要十分小心此类变量是否无限制增加，因为会导致老生代中的对象增多</p>\n"},{"title":"二叉树遍历","type":"categories","_content":"\n### 广度遍历（一层一层的遍历)\n\n```\n\tfunction levelOrderTraversal(tree) {\n\t\tif(!tree) throw new Error()\n\t\tlet que = []\n\t\tque.push(node)\n\t\tif(que.length > 0) {\n\t\t\tlet node  = que.shift()\n\t\t\tif(node.left) que.push(node.left)\n\t\t\tif(node.right) que.push(node.right)\n\t\t}\n\t}\n```\n### 递归遍历\n\n#### 1.先序遍历 DLR\n```\n\tfunction deepOrder(tree) {\n\t\tconsole.log(tree.value)\n\t\tdeepOrder(tree.left)\n\t\tdeepOrder(tree.right)\n\t}\n```\n#### 2.中序遍历 LDR\n```\n\tfunction deepOrder(tree) {\n\t\tdeepOrder(tree.left)\n\t\tconsole.log(tree.value)\n\t\tdeepOrder(tree.right)\n\t}\n```\n#### 3.后序遍历 LRD\n```\n\tfunction deepOrder(tree) {\n\t\tdeepOrder(tree.left)\n\t\tdeepOrder(tree.right)\n\t\tconsole.log(tree.value)\n\t}\n```\n","source":"_posts/structures/二叉树遍历.md","raw":"---\ntitle: 二叉树遍历\ntype: \"categories\"\ncategories: 数据结构和算法\n---\n\n### 广度遍历（一层一层的遍历)\n\n```\n\tfunction levelOrderTraversal(tree) {\n\t\tif(!tree) throw new Error()\n\t\tlet que = []\n\t\tque.push(node)\n\t\tif(que.length > 0) {\n\t\t\tlet node  = que.shift()\n\t\t\tif(node.left) que.push(node.left)\n\t\t\tif(node.right) que.push(node.right)\n\t\t}\n\t}\n```\n### 递归遍历\n\n#### 1.先序遍历 DLR\n```\n\tfunction deepOrder(tree) {\n\t\tconsole.log(tree.value)\n\t\tdeepOrder(tree.left)\n\t\tdeepOrder(tree.right)\n\t}\n```\n#### 2.中序遍历 LDR\n```\n\tfunction deepOrder(tree) {\n\t\tdeepOrder(tree.left)\n\t\tconsole.log(tree.value)\n\t\tdeepOrder(tree.right)\n\t}\n```\n#### 3.后序遍历 LRD\n```\n\tfunction deepOrder(tree) {\n\t\tdeepOrder(tree.left)\n\t\tdeepOrder(tree.right)\n\t\tconsole.log(tree.value)\n\t}\n```\n","slug":"structures-二叉树遍历","published":1,"date":"2017-02-27T05:54:45.000Z","updated":"2017-02-27T05:54:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cda001bkzy6ej9ug8kg","content":"<h3 id=\"广度遍历（一层一层的遍历\"><a href=\"#广度遍历（一层一层的遍历\" class=\"headerlink\" title=\"广度遍历（一层一层的遍历)\"></a>广度遍历（一层一层的遍历)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function levelOrderTraversal(tree) &#123;</div><div class=\"line\">\tif(!tree) throw new Error()</div><div class=\"line\">\tlet que = []</div><div class=\"line\">\tque.push(node)</div><div class=\"line\">\tif(que.length &gt; 0) &#123;</div><div class=\"line\">\t\tlet node  = que.shift()</div><div class=\"line\">\t\tif(node.left) que.push(node.left)</div><div class=\"line\">\t\tif(node.right) que.push(node.right)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"递归遍历\"><a href=\"#递归遍历\" class=\"headerlink\" title=\"递归遍历\"></a>递归遍历</h3><h4 id=\"1-先序遍历-DLR\"><a href=\"#1-先序遍历-DLR\" class=\"headerlink\" title=\"1.先序遍历 DLR\"></a>1.先序遍历 DLR</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function deepOrder(tree) &#123;</div><div class=\"line\">\tconsole.log(tree.value)</div><div class=\"line\">\tdeepOrder(tree.left)</div><div class=\"line\">\tdeepOrder(tree.right)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-中序遍历-LDR\"><a href=\"#2-中序遍历-LDR\" class=\"headerlink\" title=\"2.中序遍历 LDR\"></a>2.中序遍历 LDR</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function deepOrder(tree) &#123;</div><div class=\"line\">\tdeepOrder(tree.left)</div><div class=\"line\">\tconsole.log(tree.value)</div><div class=\"line\">\tdeepOrder(tree.right)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-后序遍历-LRD\"><a href=\"#3-后序遍历-LRD\" class=\"headerlink\" title=\"3.后序遍历 LRD\"></a>3.后序遍历 LRD</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function deepOrder(tree) &#123;</div><div class=\"line\">\tdeepOrder(tree.left)</div><div class=\"line\">\tdeepOrder(tree.right)</div><div class=\"line\">\tconsole.log(tree.value)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"广度遍历（一层一层的遍历\"><a href=\"#广度遍历（一层一层的遍历\" class=\"headerlink\" title=\"广度遍历（一层一层的遍历)\"></a>广度遍历（一层一层的遍历)</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">function levelOrderTraversal(tree) &#123;</div><div class=\"line\">\tif(!tree) throw new Error()</div><div class=\"line\">\tlet que = []</div><div class=\"line\">\tque.push(node)</div><div class=\"line\">\tif(que.length &gt; 0) &#123;</div><div class=\"line\">\t\tlet node  = que.shift()</div><div class=\"line\">\t\tif(node.left) que.push(node.left)</div><div class=\"line\">\t\tif(node.right) que.push(node.right)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"递归遍历\"><a href=\"#递归遍历\" class=\"headerlink\" title=\"递归遍历\"></a>递归遍历</h3><h4 id=\"1-先序遍历-DLR\"><a href=\"#1-先序遍历-DLR\" class=\"headerlink\" title=\"1.先序遍历 DLR\"></a>1.先序遍历 DLR</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function deepOrder(tree) &#123;</div><div class=\"line\">\tconsole.log(tree.value)</div><div class=\"line\">\tdeepOrder(tree.left)</div><div class=\"line\">\tdeepOrder(tree.right)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-中序遍历-LDR\"><a href=\"#2-中序遍历-LDR\" class=\"headerlink\" title=\"2.中序遍历 LDR\"></a>2.中序遍历 LDR</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function deepOrder(tree) &#123;</div><div class=\"line\">\tdeepOrder(tree.left)</div><div class=\"line\">\tconsole.log(tree.value)</div><div class=\"line\">\tdeepOrder(tree.right)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-后序遍历-LRD\"><a href=\"#3-后序遍历-LRD\" class=\"headerlink\" title=\"3.后序遍历 LRD\"></a>3.后序遍历 LRD</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function deepOrder(tree) &#123;</div><div class=\"line\">\tdeepOrder(tree.left)</div><div class=\"line\">\tdeepOrder(tree.right)</div><div class=\"line\">\tconsole.log(tree.value)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"排序算法比较","type":"categories","_content":"\n## 二分法排序\n随便取数组里面的一个数作为基准，，然后再把其它的数与之相对比，小的放左边的集合里，大的放右边的集合里，再通过递归不断重复该步骤\n\n```\nfunction quikSort(arr) {\n\tif(arr.length <= 1) return arr\n\tlet left = []\n\tlet right = []\n\tlet btw = math.random(arr.length/2)\n\tlet baseNum = arr.splice(btw, 1)\n\n\tarr.forEach(num => {\n\t\tif(num < baseNum) {\n\t\t\tleft.push(num)\n\t\t} else {\n\t\t\tright.push(num)\n\t\t}\n\t})\n\n\treturn quikSort(left).concat(baseNum, quikSort(right))\n\n}\n\n```\n## Array.sort排序\n```\nfunction compare(num1, num2) {\n\treturn num1 - num2 //若返回负数，说明前面的数小于后面的数\n}\n```\n## 总结： 通过比较，sort排序比二分法查找快多了\n","source":"_posts/structures/常用排序算法的比较.md","raw":"---\ntitle: 排序算法比较\ntype: \"categories\"\ncategories: 数据结构和算法\n---\n\n## 二分法排序\n随便取数组里面的一个数作为基准，，然后再把其它的数与之相对比，小的放左边的集合里，大的放右边的集合里，再通过递归不断重复该步骤\n\n```\nfunction quikSort(arr) {\n\tif(arr.length <= 1) return arr\n\tlet left = []\n\tlet right = []\n\tlet btw = math.random(arr.length/2)\n\tlet baseNum = arr.splice(btw, 1)\n\n\tarr.forEach(num => {\n\t\tif(num < baseNum) {\n\t\t\tleft.push(num)\n\t\t} else {\n\t\t\tright.push(num)\n\t\t}\n\t})\n\n\treturn quikSort(left).concat(baseNum, quikSort(right))\n\n}\n\n```\n## Array.sort排序\n```\nfunction compare(num1, num2) {\n\treturn num1 - num2 //若返回负数，说明前面的数小于后面的数\n}\n```\n## 总结： 通过比较，sort排序比二分法查找快多了\n","slug":"structures-常用排序算法的比较","published":1,"date":"2017-04-06T15:49:10.000Z","updated":"2017-04-06T15:49:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdc001ekzy6u2462dcr","content":"<h2 id=\"二分法排序\"><a href=\"#二分法排序\" class=\"headerlink\" title=\"二分法排序\"></a>二分法排序</h2><p>随便取数组里面的一个数作为基准，，然后再把其它的数与之相对比，小的放左边的集合里，大的放右边的集合里，再通过递归不断重复该步骤</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function quikSort(arr) &#123;</div><div class=\"line\">\tif(arr.length &lt;= 1) return arr</div><div class=\"line\">\tlet left = []</div><div class=\"line\">\tlet right = []</div><div class=\"line\">\tlet btw = math.random(arr.length/2)</div><div class=\"line\">\tlet baseNum = arr.splice(btw, 1)</div><div class=\"line\"></div><div class=\"line\">\tarr.forEach(num =&gt; &#123;</div><div class=\"line\">\t\tif(num &lt; baseNum) &#123;</div><div class=\"line\">\t\t\tleft.push(num)</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tright.push(num)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\treturn quikSort(left).concat(baseNum, quikSort(right))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Array-sort排序\"><a href=\"#Array-sort排序\" class=\"headerlink\" title=\"Array.sort排序\"></a>Array.sort排序</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(num1, num2) &#123;</div><div class=\"line\">\treturn num1 - num2 //若返回负数，说明前面的数小于后面的数</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结：-通过比较，sort排序比二分法查找快多了\"><a href=\"#总结：-通过比较，sort排序比二分法查找快多了\" class=\"headerlink\" title=\"总结： 通过比较，sort排序比二分法查找快多了\"></a>总结： 通过比较，sort排序比二分法查找快多了</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"二分法排序\"><a href=\"#二分法排序\" class=\"headerlink\" title=\"二分法排序\"></a>二分法排序</h2><p>随便取数组里面的一个数作为基准，，然后再把其它的数与之相对比，小的放左边的集合里，大的放右边的集合里，再通过递归不断重复该步骤</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function quikSort(arr) &#123;</div><div class=\"line\">\tif(arr.length &lt;= 1) return arr</div><div class=\"line\">\tlet left = []</div><div class=\"line\">\tlet right = []</div><div class=\"line\">\tlet btw = math.random(arr.length/2)</div><div class=\"line\">\tlet baseNum = arr.splice(btw, 1)</div><div class=\"line\"></div><div class=\"line\">\tarr.forEach(num =&gt; &#123;</div><div class=\"line\">\t\tif(num &lt; baseNum) &#123;</div><div class=\"line\">\t\t\tleft.push(num)</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tright.push(num)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\"></div><div class=\"line\">\treturn quikSort(left).concat(baseNum, quikSort(right))</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Array-sort排序\"><a href=\"#Array-sort排序\" class=\"headerlink\" title=\"Array.sort排序\"></a>Array.sort排序</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">function compare(num1, num2) &#123;</div><div class=\"line\">\treturn num1 - num2 //若返回负数，说明前面的数小于后面的数</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"总结：-通过比较，sort排序比二分法查找快多了\"><a href=\"#总结：-通过比较，sort排序比二分法查找快多了\" class=\"headerlink\" title=\"总结： 通过比较，sort排序比二分法查找快多了\"></a>总结： 通过比较，sort排序比二分法查找快多了</h2>"},{"title":"linux部署","type":"categories","_content":"\n# 部署node\n## Ubuntu内核\n```\ncurl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -\nsudo apt-get install -y nodejs\n```\n\nsudo apt-get install -y nodejs\n## 非Ubuntu内核\nOn RHEL, CentOS or Fedora, for Node.js v6 LTS:\n```\ncurl --silent --location https://rpm.nodesource.com/setup_6.x | sudo bash -\n```\nAlternatively for Node.js 8:\n```\ncurl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -\n```\nThen install:\n```\nsudo yum -y install nodejs\n```\n\n# 如何在后台启动服务\nlinux下， 使用yum install mongodb-server及service mongod start，可以启动，但mongodb默认属于低版本，启动的mongodb配置文件需另外指定。\n\n# mongod 安装\n```\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载\ntar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压\n\nmv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb \n\nMongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：\nexport PATH=<mongodb-install-directory>/bin:$PATH\n<mongodb-install-directory> 为你 MongoDB 的安装路径。如本文的 /usr/local/mongodb\n```\n# 创建数据库目录\n\nmkdir -p /data/db\n./mongod --dbpath=/data/db --rest\n\n# MongoDB后台管理 Shell\n```\n$ cd /usr/local/mongodb/bin\n$ ./mongo\n```\n\n# pm2\npm2 start app.js  用pm2来守护进程","source":"_posts/other/linux部署.md","raw":"---\ntitle: linux部署\ntype: \"categories\"\ncategories: 其他\n---\n\n# 部署node\n## Ubuntu内核\n```\ncurl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -\nsudo apt-get install -y nodejs\n```\n\nsudo apt-get install -y nodejs\n## 非Ubuntu内核\nOn RHEL, CentOS or Fedora, for Node.js v6 LTS:\n```\ncurl --silent --location https://rpm.nodesource.com/setup_6.x | sudo bash -\n```\nAlternatively for Node.js 8:\n```\ncurl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -\n```\nThen install:\n```\nsudo yum -y install nodejs\n```\n\n# 如何在后台启动服务\nlinux下， 使用yum install mongodb-server及service mongod start，可以启动，但mongodb默认属于低版本，启动的mongodb配置文件需另外指定。\n\n# mongod 安装\n```\ncurl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载\ntar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压\n\nmv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb \n\nMongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：\nexport PATH=<mongodb-install-directory>/bin:$PATH\n<mongodb-install-directory> 为你 MongoDB 的安装路径。如本文的 /usr/local/mongodb\n```\n# 创建数据库目录\n\nmkdir -p /data/db\n./mongod --dbpath=/data/db --rest\n\n# MongoDB后台管理 Shell\n```\n$ cd /usr/local/mongodb/bin\n$ ./mongo\n```\n\n# pm2\npm2 start app.js  用pm2来守护进程","slug":"other-linux部署","published":1,"date":"2017-09-26T08:35:10.000Z","updated":"2017-09-26T08:35:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cde001gkzy6h09xic3i","content":"<h1 id=\"部署node\"><a href=\"#部署node\" class=\"headerlink\" title=\"部署node\"></a>部署node</h1><h2 id=\"Ubuntu内核\"><a href=\"#Ubuntu内核\" class=\"headerlink\" title=\"Ubuntu内核\"></a>Ubuntu内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</div><div class=\"line\">sudo apt-get install -y nodejs</div></pre></td></tr></table></figure>\n<p>sudo apt-get install -y nodejs</p>\n<h2 id=\"非Ubuntu内核\"><a href=\"#非Ubuntu内核\" class=\"headerlink\" title=\"非Ubuntu内核\"></a>非Ubuntu内核</h2><p>On RHEL, CentOS or Fedora, for Node.js v6 LTS:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl --silent --location https://rpm.nodesource.com/setup_6.x | sudo bash -</div></pre></td></tr></table></figure></p>\n<p>Alternatively for Node.js 8:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</div></pre></td></tr></table></figure></p>\n<p>Then install:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum -y install nodejs</div></pre></td></tr></table></figure></p>\n<h1 id=\"如何在后台启动服务\"><a href=\"#如何在后台启动服务\" class=\"headerlink\" title=\"如何在后台启动服务\"></a>如何在后台启动服务</h1><p>linux下， 使用yum install mongodb-server及service mongod start，可以启动，但mongodb默认属于低版本，启动的mongodb配置文件需另外指定。</p>\n<h1 id=\"mongod-安装\"><a href=\"#mongod-安装\" class=\"headerlink\" title=\"mongod 安装\"></a>mongod 安装</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载</div><div class=\"line\">tar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压</div><div class=\"line\"></div><div class=\"line\">mv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb </div><div class=\"line\"></div><div class=\"line\">MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：</div><div class=\"line\">export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH</div><div class=\"line\">&lt;mongodb-install-directory&gt; 为你 MongoDB 的安装路径。如本文的 /usr/local/mongodb</div></pre></td></tr></table></figure>\n<h1 id=\"创建数据库目录\"><a href=\"#创建数据库目录\" class=\"headerlink\" title=\"创建数据库目录\"></a>创建数据库目录</h1><p>mkdir -p /data/db<br>./mongod –dbpath=/data/db –rest</p>\n<h1 id=\"MongoDB后台管理-Shell\"><a href=\"#MongoDB后台管理-Shell\" class=\"headerlink\" title=\"MongoDB后台管理 Shell\"></a>MongoDB后台管理 Shell</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd /usr/local/mongodb/bin</div><div class=\"line\">$ ./mongo</div></pre></td></tr></table></figure>\n<h1 id=\"pm2\"><a href=\"#pm2\" class=\"headerlink\" title=\"pm2\"></a>pm2</h1><p>pm2 start app.js  用pm2来守护进程</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"部署node\"><a href=\"#部署node\" class=\"headerlink\" title=\"部署node\"></a>部署node</h1><h2 id=\"Ubuntu内核\"><a href=\"#Ubuntu内核\" class=\"headerlink\" title=\"Ubuntu内核\"></a>Ubuntu内核</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</div><div class=\"line\">sudo apt-get install -y nodejs</div></pre></td></tr></table></figure>\n<p>sudo apt-get install -y nodejs</p>\n<h2 id=\"非Ubuntu内核\"><a href=\"#非Ubuntu内核\" class=\"headerlink\" title=\"非Ubuntu内核\"></a>非Ubuntu内核</h2><p>On RHEL, CentOS or Fedora, for Node.js v6 LTS:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl --silent --location https://rpm.nodesource.com/setup_6.x | sudo bash -</div></pre></td></tr></table></figure></p>\n<p>Alternatively for Node.js 8:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl --silent --location https://rpm.nodesource.com/setup_8.x | sudo bash -</div></pre></td></tr></table></figure></p>\n<p>Then install:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo yum -y install nodejs</div></pre></td></tr></table></figure></p>\n<h1 id=\"如何在后台启动服务\"><a href=\"#如何在后台启动服务\" class=\"headerlink\" title=\"如何在后台启动服务\"></a>如何在后台启动服务</h1><p>linux下， 使用yum install mongodb-server及service mongod start，可以启动，但mongodb默认属于低版本，启动的mongodb配置文件需另外指定。</p>\n<h1 id=\"mongod-安装\"><a href=\"#mongod-安装\" class=\"headerlink\" title=\"mongod 安装\"></a>mongod 安装</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">curl -O https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz    # 下载</div><div class=\"line\">tar -zxvf mongodb-linux-x86_64-3.0.6.tgz                                   # 解压</div><div class=\"line\"></div><div class=\"line\">mv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb </div><div class=\"line\"></div><div class=\"line\">MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中：</div><div class=\"line\">export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH</div><div class=\"line\">&lt;mongodb-install-directory&gt; 为你 MongoDB 的安装路径。如本文的 /usr/local/mongodb</div></pre></td></tr></table></figure>\n<h1 id=\"创建数据库目录\"><a href=\"#创建数据库目录\" class=\"headerlink\" title=\"创建数据库目录\"></a>创建数据库目录</h1><p>mkdir -p /data/db<br>./mongod –dbpath=/data/db –rest</p>\n<h1 id=\"MongoDB后台管理-Shell\"><a href=\"#MongoDB后台管理-Shell\" class=\"headerlink\" title=\"MongoDB后台管理 Shell\"></a>MongoDB后台管理 Shell</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd /usr/local/mongodb/bin</div><div class=\"line\">$ ./mongo</div></pre></td></tr></table></figure>\n<h1 id=\"pm2\"><a href=\"#pm2\" class=\"headerlink\" title=\"pm2\"></a>pm2</h1><p>pm2 start app.js  用pm2来守护进程</p>\n"},{"title":"用PC的chrome浏览器调试手机的Safari页面","type":"categories","_content":"\n## 背景\n在Mac上用safari调试手机页面，有个弊端，就是第一次的console.log和其他的记录是捕捉不到的，而且习惯用chrome调试的同学对safari无感，所以 [ios-webkit-debug-proxy](https://github.com/google/ios-webkit-debug-proxy)诞生了\n\n### 安装\n> brew install ios-webkit-debug-proxy\n> brew uninstall --force libimobiledevice ios-webkit-debug-proxy\n> brew install --HEAD libimobiledevice ios-webkit-debug-proxy\n\n### 连接手机\n> 设置 > Safari > 高级 > Web 检查器 > 打开\n\n### 启动代理\n\nterminal执行\n\n> ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html\n\n### pc的chrome浏览器启动\n\n查看终端连接的设备\n```\nhttp:／／localhost:9221\n```\n查看可以调试的页面\n```\nhttp://localhost:9222 \n```\n进行调试你所指定的页面\n\n```\nchrome-devtools://devtools/bundled/inspector.html?ws=localhost:9222/devtools/page/1 //这个1代表的是localhost:9222中页面的排列序号\n```\n\n如果你要调试debug模式\n```\nios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html --debug //在terminal执行\n\nhttps://chrome-devtools-frontend.appspot.com/static/33.0.1722.0/devtools.html?ws=localhost:9222/devtools/page/1 //浏览器输入\n\n```","source":"_posts/utils/chrome-inspector.md","raw":"---\ntitle: 用PC的chrome浏览器调试手机的Safari页面\ntype: \"categories\"\ncategories: 工具\n---\n\n## 背景\n在Mac上用safari调试手机页面，有个弊端，就是第一次的console.log和其他的记录是捕捉不到的，而且习惯用chrome调试的同学对safari无感，所以 [ios-webkit-debug-proxy](https://github.com/google/ios-webkit-debug-proxy)诞生了\n\n### 安装\n> brew install ios-webkit-debug-proxy\n> brew uninstall --force libimobiledevice ios-webkit-debug-proxy\n> brew install --HEAD libimobiledevice ios-webkit-debug-proxy\n\n### 连接手机\n> 设置 > Safari > 高级 > Web 检查器 > 打开\n\n### 启动代理\n\nterminal执行\n\n> ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html\n\n### pc的chrome浏览器启动\n\n查看终端连接的设备\n```\nhttp:／／localhost:9221\n```\n查看可以调试的页面\n```\nhttp://localhost:9222 \n```\n进行调试你所指定的页面\n\n```\nchrome-devtools://devtools/bundled/inspector.html?ws=localhost:9222/devtools/page/1 //这个1代表的是localhost:9222中页面的排列序号\n```\n\n如果你要调试debug模式\n```\nios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html --debug //在terminal执行\n\nhttps://chrome-devtools-frontend.appspot.com/static/33.0.1722.0/devtools.html?ws=localhost:9222/devtools/page/1 //浏览器输入\n\n```","slug":"utils-chrome-inspector","published":1,"date":"2017-03-07T05:54:10.000Z","updated":"2017-03-07T05:54:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdf001jkzy6jcxwv61l","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在Mac上用safari调试手机页面，有个弊端，就是第一次的console.log和其他的记录是捕捉不到的，而且习惯用chrome调试的同学对safari无感，所以 <a href=\"https://github.com/google/ios-webkit-debug-proxy\" target=\"_blank\" rel=\"external\">ios-webkit-debug-proxy</a>诞生了</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><blockquote>\n<p>brew install ios-webkit-debug-proxy<br>brew uninstall –force libimobiledevice ios-webkit-debug-proxy<br>brew install –HEAD libimobiledevice ios-webkit-debug-proxy</p>\n</blockquote>\n<h3 id=\"连接手机\"><a href=\"#连接手机\" class=\"headerlink\" title=\"连接手机\"></a>连接手机</h3><blockquote>\n<p>设置 &gt; Safari &gt; 高级 &gt; Web 检查器 &gt; 打开</p>\n</blockquote>\n<h3 id=\"启动代理\"><a href=\"#启动代理\" class=\"headerlink\" title=\"启动代理\"></a>启动代理</h3><p>terminal执行</p>\n<blockquote>\n<p>ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html</p>\n</blockquote>\n<h3 id=\"pc的chrome浏览器启动\"><a href=\"#pc的chrome浏览器启动\" class=\"headerlink\" title=\"pc的chrome浏览器启动\"></a>pc的chrome浏览器启动</h3><p>查看终端连接的设备<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http:／／localhost:9221</div></pre></td></tr></table></figure></p>\n<p>查看可以调试的页面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:9222</div></pre></td></tr></table></figure></p>\n<p>进行调试你所指定的页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chrome-devtools://devtools/bundled/inspector.html?ws=localhost:9222/devtools/page/1 //这个1代表的是localhost:9222中页面的排列序号</div></pre></td></tr></table></figure>\n<p>如果你要调试debug模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html --debug //在terminal执行</div><div class=\"line\"></div><div class=\"line\">https://chrome-devtools-frontend.appspot.com/static/33.0.1722.0/devtools.html?ws=localhost:9222/devtools/page/1 //浏览器输入</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>在Mac上用safari调试手机页面，有个弊端，就是第一次的console.log和其他的记录是捕捉不到的，而且习惯用chrome调试的同学对safari无感，所以 <a href=\"https://github.com/google/ios-webkit-debug-proxy\" target=\"_blank\" rel=\"external\">ios-webkit-debug-proxy</a>诞生了</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><blockquote>\n<p>brew install ios-webkit-debug-proxy<br>brew uninstall –force libimobiledevice ios-webkit-debug-proxy<br>brew install –HEAD libimobiledevice ios-webkit-debug-proxy</p>\n</blockquote>\n<h3 id=\"连接手机\"><a href=\"#连接手机\" class=\"headerlink\" title=\"连接手机\"></a>连接手机</h3><blockquote>\n<p>设置 &gt; Safari &gt; 高级 &gt; Web 检查器 &gt; 打开</p>\n</blockquote>\n<h3 id=\"启动代理\"><a href=\"#启动代理\" class=\"headerlink\" title=\"启动代理\"></a>启动代理</h3><p>terminal执行</p>\n<blockquote>\n<p>ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html</p>\n</blockquote>\n<h3 id=\"pc的chrome浏览器启动\"><a href=\"#pc的chrome浏览器启动\" class=\"headerlink\" title=\"pc的chrome浏览器启动\"></a>pc的chrome浏览器启动</h3><p>查看终端连接的设备<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http:／／localhost:9221</div></pre></td></tr></table></figure></p>\n<p>查看可以调试的页面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">http://localhost:9222</div></pre></td></tr></table></figure></p>\n<p>进行调试你所指定的页面</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">chrome-devtools://devtools/bundled/inspector.html?ws=localhost:9222/devtools/page/1 //这个1代表的是localhost:9222中页面的排列序号</div></pre></td></tr></table></figure>\n<p>如果你要调试debug模式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ios_webkit_debug_proxy -f chrome-devtools://devtools/bundled/inspector.html --debug //在terminal执行</div><div class=\"line\"></div><div class=\"line\">https://chrome-devtools-frontend.appspot.com/static/33.0.1722.0/devtools.html?ws=localhost:9222/devtools/page/1 //浏览器输入</div></pre></td></tr></table></figure></p>\n"},{"title":"redis","type":"categories","_content":"# 安装\nbrew install redis\n# 启动\nredis-server\n# 切换端口\nredis-server --port 6380\n# 停止\nredis-cli shutdown\n","source":"_posts/utils/redis.md","raw":"---\ntitle: redis\ntype: \"categories\"\ncategories: 工具\n---\n# 安装\nbrew install redis\n# 启动\nredis-server\n# 切换端口\nredis-server --port 6380\n# 停止\nredis-cli shutdown\n","slug":"utils-redis","published":1,"date":"2017-09-26T08:33:34.000Z","updated":"2017-09-26T08:34:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdf001lkzy65i657udq","content":"<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>brew install redis</p>\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><p>redis-server</p>\n<h1 id=\"切换端口\"><a href=\"#切换端口\" class=\"headerlink\" title=\"切换端口\"></a>切换端口</h1><p>redis-server –port 6380</p>\n<h1 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a>停止</h1><p>redis-cli shutdown</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p>brew install redis</p>\n<h1 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h1><p>redis-server</p>\n<h1 id=\"切换端口\"><a href=\"#切换端口\" class=\"headerlink\" title=\"切换端口\"></a>切换端口</h1><p>redis-server –port 6380</p>\n<h1 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a>停止</h1><p>redis-cli shutdown</p>\n"},{"title":"git rebase 合并","type":"categories","_content":"\n## git rebase 合并\n\n### 1.取消上一次的提交：\n>   git revert HEAD\n\n### 2.删除最近的两个提交：\n>   git reset --hard HEAD~~ //可以是commit的序号\n    回滚刚才误删掉的git reset --hard ORIG_HEAD\n\n### 3.只将某一次分支的修改进行提交合并到master\n>   1.先切换到最终合并后的分支\n    2.git cherry-pick 99daed2 //如果要从某一个分支的所有提交合并到master：git merge --squash issue1（分支）\n\n### 4.用rebase -i 汇合过去的提交\n>   git rebase -i HAED~~\n    后一个pick改为squash，再wq\n    \n### 5.用 rebase -i 修改提交\n>   git rebase -i HEAD~~ //可以是commit的序号\n    将pick改为edit\n    打开编辑器进行修改\n    修改完了之后 git add .\n    git commit --amend\n    git rebase --continue //如果发生冲突，解决冲突，然后再循环add....continue操作\n\n### 6.把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\n>   git add .\n    git commit\n\n### 7.和上次的提交一并提交\n>\tgit commit --amend\n","source":"_posts/utils/git-rebase.md","raw":"---\ntitle: git rebase 合并\ntype: \"categories\"\ncategories: 工具\n---\n\n## git rebase 合并\n\n### 1.取消上一次的提交：\n>   git revert HEAD\n\n### 2.删除最近的两个提交：\n>   git reset --hard HEAD~~ //可以是commit的序号\n    回滚刚才误删掉的git reset --hard ORIG_HEAD\n\n### 3.只将某一次分支的修改进行提交合并到master\n>   1.先切换到最终合并后的分支\n    2.git cherry-pick 99daed2 //如果要从某一个分支的所有提交合并到master：git merge --squash issue1（分支）\n\n### 4.用rebase -i 汇合过去的提交\n>   git rebase -i HAED~~\n    后一个pick改为squash，再wq\n    \n### 5.用 rebase -i 修改提交\n>   git rebase -i HEAD~~ //可以是commit的序号\n    将pick改为edit\n    打开编辑器进行修改\n    修改完了之后 git add .\n    git commit --amend\n    git rebase --continue //如果发生冲突，解决冲突，然后再循环add....continue操作\n\n### 6.把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\n>   git add .\n    git commit\n\n### 7.和上次的提交一并提交\n>\tgit commit --amend\n","slug":"utils-git-rebase","published":1,"date":"2017-03-01T02:51:36.000Z","updated":"2017-03-01T02:51:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdh001okzy6u8zk8yli","content":"<h2 id=\"git-rebase-合并\"><a href=\"#git-rebase-合并\" class=\"headerlink\" title=\"git rebase 合并\"></a>git rebase 合并</h2><h3 id=\"1-取消上一次的提交：\"><a href=\"#1-取消上一次的提交：\" class=\"headerlink\" title=\"1.取消上一次的提交：\"></a>1.取消上一次的提交：</h3><blockquote>\n<p>  git revert HEAD</p>\n</blockquote>\n<h3 id=\"2-删除最近的两个提交：\"><a href=\"#2-删除最近的两个提交：\" class=\"headerlink\" title=\"2.删除最近的两个提交：\"></a>2.删除最近的两个提交：</h3><blockquote>\n<p>  git reset –hard HEAD~~ //可以是commit的序号<br>    回滚刚才误删掉的git reset –hard ORIG_HEAD</p>\n</blockquote>\n<h3 id=\"3-只将某一次分支的修改进行提交合并到master\"><a href=\"#3-只将某一次分支的修改进行提交合并到master\" class=\"headerlink\" title=\"3.只将某一次分支的修改进行提交合并到master\"></a>3.只将某一次分支的修改进行提交合并到master</h3><blockquote>\n<p>  1.先切换到最终合并后的分支<br>    2.git cherry-pick 99daed2 //如果要从某一个分支的所有提交合并到master：git merge –squash issue1（分支）</p>\n</blockquote>\n<h3 id=\"4-用rebase-i-汇合过去的提交\"><a href=\"#4-用rebase-i-汇合过去的提交\" class=\"headerlink\" title=\"4.用rebase -i 汇合过去的提交\"></a>4.用rebase -i 汇合过去的提交</h3><blockquote>\n<p>  git rebase -i HAED~~<br>    后一个pick改为squash，再wq</p>\n</blockquote>\n<h3 id=\"5-用-rebase-i-修改提交\"><a href=\"#5-用-rebase-i-修改提交\" class=\"headerlink\" title=\"5.用 rebase -i 修改提交\"></a>5.用 rebase -i 修改提交</h3><blockquote>\n<p>  git rebase -i HEAD~~ //可以是commit的序号<br>    将pick改为edit<br>    打开编辑器进行修改<br>    修改完了之后 git add .<br>    git commit –amend<br>    git rebase –continue //如果发生冲突，解决冲突，然后再循环add….continue操作</p>\n</blockquote>\n<h3 id=\"6-把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\"><a href=\"#6-把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\" class=\"headerlink\" title=\"6.把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\"></a>6.把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：</h3><blockquote>\n<p>  git add .<br>    git commit</p>\n</blockquote>\n<h3 id=\"7-和上次的提交一并提交\"><a href=\"#7-和上次的提交一并提交\" class=\"headerlink\" title=\"7.和上次的提交一并提交\"></a>7.和上次的提交一并提交</h3><blockquote>\n<p>   git commit –amend</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"git-rebase-合并\"><a href=\"#git-rebase-合并\" class=\"headerlink\" title=\"git rebase 合并\"></a>git rebase 合并</h2><h3 id=\"1-取消上一次的提交：\"><a href=\"#1-取消上一次的提交：\" class=\"headerlink\" title=\"1.取消上一次的提交：\"></a>1.取消上一次的提交：</h3><blockquote>\n<p>  git revert HEAD</p>\n</blockquote>\n<h3 id=\"2-删除最近的两个提交：\"><a href=\"#2-删除最近的两个提交：\" class=\"headerlink\" title=\"2.删除最近的两个提交：\"></a>2.删除最近的两个提交：</h3><blockquote>\n<p>  git reset –hard HEAD~~ //可以是commit的序号<br>    回滚刚才误删掉的git reset –hard ORIG_HEAD</p>\n</blockquote>\n<h3 id=\"3-只将某一次分支的修改进行提交合并到master\"><a href=\"#3-只将某一次分支的修改进行提交合并到master\" class=\"headerlink\" title=\"3.只将某一次分支的修改进行提交合并到master\"></a>3.只将某一次分支的修改进行提交合并到master</h3><blockquote>\n<p>  1.先切换到最终合并后的分支<br>    2.git cherry-pick 99daed2 //如果要从某一个分支的所有提交合并到master：git merge –squash issue1（分支）</p>\n</blockquote>\n<h3 id=\"4-用rebase-i-汇合过去的提交\"><a href=\"#4-用rebase-i-汇合过去的提交\" class=\"headerlink\" title=\"4.用rebase -i 汇合过去的提交\"></a>4.用rebase -i 汇合过去的提交</h3><blockquote>\n<p>  git rebase -i HAED~~<br>    后一个pick改为squash，再wq</p>\n</blockquote>\n<h3 id=\"5-用-rebase-i-修改提交\"><a href=\"#5-用-rebase-i-修改提交\" class=\"headerlink\" title=\"5.用 rebase -i 修改提交\"></a>5.用 rebase -i 修改提交</h3><blockquote>\n<p>  git rebase -i HEAD~~ //可以是commit的序号<br>    将pick改为edit<br>    打开编辑器进行修改<br>    修改完了之后 git add .<br>    git commit –amend<br>    git rebase –continue //如果发生冲突，解决冲突，然后再循环add….continue操作</p>\n</blockquote>\n<h3 id=\"6-把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\"><a href=\"#6-把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\" class=\"headerlink\" title=\"6.把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：\"></a>6.把所有test分支的所有提交合并成一个提交，导入master分支，解决冲突后，在：</h3><blockquote>\n<p>  git add .<br>    git commit</p>\n</blockquote>\n<h3 id=\"7-和上次的提交一并提交\"><a href=\"#7-和上次的提交一并提交\" class=\"headerlink\" title=\"7.和上次的提交一并提交\"></a>7.和上次的提交一并提交</h3><blockquote>\n<p>   git commit –amend</p>\n</blockquote>\n"},{"title":"前端求职简历","type":"categories","_content":"\n## 基本信息\n\n> 姓名： \n> 性别： 男\n> 籍贯： \n> 年龄： \n> 电话： \n> 专业：计算机科学与技术\n> 学历： 本科\n> 英语水平： CET-6\n> 邮箱： jijiehao92@gmail.com\n\n## 求职意向\n\n> 期望职位 : 前端开发工程师\n> 期望地点 : 上海\n> 入职时间 : 尽快\n\n## 专业技能\n\n> 扎实的计算机基础以及HTML、CSS、JavaScript，有良好的代码规范\n\n> 熟练使用ES6新特性和Vue开发H5单页应用，深入体会模块化开发的思想，并且配合移动客户端完成Hybrid开发\n\n> 熟练使用Npm、Gulp和Webpack对项目进行构建\n\n> 熟悉Javascript原型、闭包、面向对象的编程，并且使用面向对象的思想进行组件化开发\n\n> 熟悉linux常用命令，git流程、H5相关调试工具\n\n> js的异步编程，以及Node、Php、Mysql、MongoDB相关技术\n\n## 工作经历\n\n> 淘旅行网络科技有限公司\n> 职位名称：前端开发工程师\n> 工作时间：2016/01 - 至今\n> 工作描述:\n&nbsp;&nbsp;&nbsp;&nbsp;1.参与项目组件的开发，配合完成基本框架的搭建，以及一些PC端旧项目的重构\n&nbsp;&nbsp;&nbsp;&nbsp;2.配合产品和测试完成代码的编写任务，并按时上线，并维护后期工作\n&nbsp;&nbsp;&nbsp;&nbsp;3.公司的一些自动化构建工具的开发\n\n\n> 江苏微悦信息技术有限公司\n> 职位名称：前端开发工程师\n> 工作时间：2015/04 - 2016/01\n> 工作描述：\n&nbsp;&nbsp;&nbsp;&nbsp;1.参与公司的切图工 作,并且用SASS编写可维护的CSS代码，让模块的样式更加颗粒化\n&nbsp;&nbsp;&nbsp;&nbsp;2.用Jquery库编写常用页面效果\n&nbsp;&nbsp;&nbsp;&nbsp;3.用angular1版本配合bootstrap开发后台管理系统交互的相关页面\n\n## 项目介绍\n\n### Hybrid、H5公司产品\n1. 前端架构： jquery + Vue + 基础框架\n2. 开发周期： 2016/01 - 至今\n3. 项目描述： 为用户提供可选，如何进行打包，如何进行项目的构建，并且独自一人使用vue进行业务开发，运用了相关的vuex，vue-router等技术\n4. <a href=\"https://wbcz.github.io/2017/03/11/js-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/\" style=\"color:red;\">简要介绍地址，一睹为快哟</a>\n\n### 公司PC端项目的重构\n1. 开发周期： 2016/01 - 2016/04\n2. 项目描述： 为用户提供可选择的旅游产品，单机，单酒，酒景，机酒，自由行等服务\n3. 责任描述:  （背景：为了使项目更加的容易维护并且提升网站的性能，对原有的开发模式进行大幅度调整，是项目更加自动化，PC端项目刚开始是页面是在后端绑定数据，然后前端提供静态页面和交互效果，但是随着项目的复杂加大，每个页面引入的css和js越来越多，并且页面的样式也在不断升级，css也造成不断的冗余，并且样式也没使用sass这些技术。）\n我负责对项目自动化构建，首先启动sass，和同事进行协商，并且把common.css抽离成模块化的样式，并且把插件的css样式抽离出来，然后每个页面只有一个css文件，其他的模块样式通过sass直接引入即可。那么接下来我用gulp写个脚本，分别对样html，css，img进行编译打包压缩到build目录，另外我会把相对路径通过正则匹配到然后替换测试环境的地址，这样子当我们把代码发送到测试服务器上的时候，后端也能够直接看到静态页面的效果。\n\n","source":"_posts/utils/resume.md","raw":"---\ntitle: 前端求职简历\ntype: \"categories\"\ncategories: 工具\n---\n\n## 基本信息\n\n> 姓名： \n> 性别： 男\n> 籍贯： \n> 年龄： \n> 电话： \n> 专业：计算机科学与技术\n> 学历： 本科\n> 英语水平： CET-6\n> 邮箱： jijiehao92@gmail.com\n\n## 求职意向\n\n> 期望职位 : 前端开发工程师\n> 期望地点 : 上海\n> 入职时间 : 尽快\n\n## 专业技能\n\n> 扎实的计算机基础以及HTML、CSS、JavaScript，有良好的代码规范\n\n> 熟练使用ES6新特性和Vue开发H5单页应用，深入体会模块化开发的思想，并且配合移动客户端完成Hybrid开发\n\n> 熟练使用Npm、Gulp和Webpack对项目进行构建\n\n> 熟悉Javascript原型、闭包、面向对象的编程，并且使用面向对象的思想进行组件化开发\n\n> 熟悉linux常用命令，git流程、H5相关调试工具\n\n> js的异步编程，以及Node、Php、Mysql、MongoDB相关技术\n\n## 工作经历\n\n> 淘旅行网络科技有限公司\n> 职位名称：前端开发工程师\n> 工作时间：2016/01 - 至今\n> 工作描述:\n&nbsp;&nbsp;&nbsp;&nbsp;1.参与项目组件的开发，配合完成基本框架的搭建，以及一些PC端旧项目的重构\n&nbsp;&nbsp;&nbsp;&nbsp;2.配合产品和测试完成代码的编写任务，并按时上线，并维护后期工作\n&nbsp;&nbsp;&nbsp;&nbsp;3.公司的一些自动化构建工具的开发\n\n\n> 江苏微悦信息技术有限公司\n> 职位名称：前端开发工程师\n> 工作时间：2015/04 - 2016/01\n> 工作描述：\n&nbsp;&nbsp;&nbsp;&nbsp;1.参与公司的切图工 作,并且用SASS编写可维护的CSS代码，让模块的样式更加颗粒化\n&nbsp;&nbsp;&nbsp;&nbsp;2.用Jquery库编写常用页面效果\n&nbsp;&nbsp;&nbsp;&nbsp;3.用angular1版本配合bootstrap开发后台管理系统交互的相关页面\n\n## 项目介绍\n\n### Hybrid、H5公司产品\n1. 前端架构： jquery + Vue + 基础框架\n2. 开发周期： 2016/01 - 至今\n3. 项目描述： 为用户提供可选，如何进行打包，如何进行项目的构建，并且独自一人使用vue进行业务开发，运用了相关的vuex，vue-router等技术\n4. <a href=\"https://wbcz.github.io/2017/03/11/js-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/\" style=\"color:red;\">简要介绍地址，一睹为快哟</a>\n\n### 公司PC端项目的重构\n1. 开发周期： 2016/01 - 2016/04\n2. 项目描述： 为用户提供可选择的旅游产品，单机，单酒，酒景，机酒，自由行等服务\n3. 责任描述:  （背景：为了使项目更加的容易维护并且提升网站的性能，对原有的开发模式进行大幅度调整，是项目更加自动化，PC端项目刚开始是页面是在后端绑定数据，然后前端提供静态页面和交互效果，但是随着项目的复杂加大，每个页面引入的css和js越来越多，并且页面的样式也在不断升级，css也造成不断的冗余，并且样式也没使用sass这些技术。）\n我负责对项目自动化构建，首先启动sass，和同事进行协商，并且把common.css抽离成模块化的样式，并且把插件的css样式抽离出来，然后每个页面只有一个css文件，其他的模块样式通过sass直接引入即可。那么接下来我用gulp写个脚本，分别对样html，css，img进行编译打包压缩到build目录，另外我会把相对路径通过正则匹配到然后替换测试环境的地址，这样子当我们把代码发送到测试服务器上的时候，后端也能够直接看到静态页面的效果。\n\n","slug":"utils-resume","published":1,"date":"2017-04-01T02:08:17.000Z","updated":"2017-04-01T02:08:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdk001qkzy6uqypanag","content":"<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><blockquote>\n<p>姓名：<br>性别： 男<br>籍贯：<br>年龄：<br>电话：<br>专业：计算机科学与技术<br>学历： 本科<br>英语水平： CET-6<br>邮箱： jijiehao92@gmail.com</p>\n</blockquote>\n<h2 id=\"求职意向\"><a href=\"#求职意向\" class=\"headerlink\" title=\"求职意向\"></a>求职意向</h2><blockquote>\n<p>期望职位 : 前端开发工程师<br>期望地点 : 上海<br>入职时间 : 尽快</p>\n</blockquote>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><blockquote>\n<p>扎实的计算机基础以及HTML、CSS、JavaScript，有良好的代码规范</p>\n<p>熟练使用ES6新特性和Vue开发H5单页应用，深入体会模块化开发的思想，并且配合移动客户端完成Hybrid开发</p>\n<p>熟练使用Npm、Gulp和Webpack对项目进行构建</p>\n<p>熟悉Javascript原型、闭包、面向对象的编程，并且使用面向对象的思想进行组件化开发</p>\n<p>熟悉linux常用命令，git流程、H5相关调试工具</p>\n<p>js的异步编程，以及Node、Php、Mysql、MongoDB相关技术</p>\n</blockquote>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><blockquote>\n<p>淘旅行网络科技有限公司<br>职位名称：前端开发工程师<br>工作时间：2016/01 - 至今<br>工作描述:<br>&nbsp;&nbsp;&nbsp;&nbsp;1.参与项目组件的开发，配合完成基本框架的搭建，以及一些PC端旧项目的重构<br>&nbsp;&nbsp;&nbsp;&nbsp;2.配合产品和测试完成代码的编写任务，并按时上线，并维护后期工作<br>&nbsp;&nbsp;&nbsp;&nbsp;3.公司的一些自动化构建工具的开发</p>\n<p>江苏微悦信息技术有限公司<br>职位名称：前端开发工程师<br>工作时间：2015/04 - 2016/01<br>工作描述：<br>&nbsp;&nbsp;&nbsp;&nbsp;1.参与公司的切图工 作,并且用SASS编写可维护的CSS代码，让模块的样式更加颗粒化<br>&nbsp;&nbsp;&nbsp;&nbsp;2.用Jquery库编写常用页面效果<br>&nbsp;&nbsp;&nbsp;&nbsp;3.用angular1版本配合bootstrap开发后台管理系统交互的相关页面</p>\n</blockquote>\n<h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><h3 id=\"Hybrid、H5公司产品\"><a href=\"#Hybrid、H5公司产品\" class=\"headerlink\" title=\"Hybrid、H5公司产品\"></a>Hybrid、H5公司产品</h3><ol>\n<li>前端架构： jquery + Vue + 基础框架</li>\n<li>开发周期： 2016/01 - 至今</li>\n<li>项目描述： 为用户提供可选，如何进行打包，如何进行项目的构建，并且独自一人使用vue进行业务开发，运用了相关的vuex，vue-router等技术</li>\n<li><a href=\"https://wbcz.github.io/2017/03/11/js-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/\" style=\"color:red;\" target=\"_blank\" rel=\"external\">简要介绍地址，一睹为快哟</a></li>\n</ol>\n<h3 id=\"公司PC端项目的重构\"><a href=\"#公司PC端项目的重构\" class=\"headerlink\" title=\"公司PC端项目的重构\"></a>公司PC端项目的重构</h3><ol>\n<li>开发周期： 2016/01 - 2016/04</li>\n<li>项目描述： 为用户提供可选择的旅游产品，单机，单酒，酒景，机酒，自由行等服务</li>\n<li>责任描述:  （背景：为了使项目更加的容易维护并且提升网站的性能，对原有的开发模式进行大幅度调整，是项目更加自动化，PC端项目刚开始是页面是在后端绑定数据，然后前端提供静态页面和交互效果，但是随着项目的复杂加大，每个页面引入的css和js越来越多，并且页面的样式也在不断升级，css也造成不断的冗余，并且样式也没使用sass这些技术。）<br>我负责对项目自动化构建，首先启动sass，和同事进行协商，并且把common.css抽离成模块化的样式，并且把插件的css样式抽离出来，然后每个页面只有一个css文件，其他的模块样式通过sass直接引入即可。那么接下来我用gulp写个脚本，分别对样html，css，img进行编译打包压缩到build目录，另外我会把相对路径通过正则匹配到然后替换测试环境的地址，这样子当我们把代码发送到测试服务器上的时候，后端也能够直接看到静态页面的效果。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><blockquote>\n<p>姓名：<br>性别： 男<br>籍贯：<br>年龄：<br>电话：<br>专业：计算机科学与技术<br>学历： 本科<br>英语水平： CET-6<br>邮箱： jijiehao92@gmail.com</p>\n</blockquote>\n<h2 id=\"求职意向\"><a href=\"#求职意向\" class=\"headerlink\" title=\"求职意向\"></a>求职意向</h2><blockquote>\n<p>期望职位 : 前端开发工程师<br>期望地点 : 上海<br>入职时间 : 尽快</p>\n</blockquote>\n<h2 id=\"专业技能\"><a href=\"#专业技能\" class=\"headerlink\" title=\"专业技能\"></a>专业技能</h2><blockquote>\n<p>扎实的计算机基础以及HTML、CSS、JavaScript，有良好的代码规范</p>\n<p>熟练使用ES6新特性和Vue开发H5单页应用，深入体会模块化开发的思想，并且配合移动客户端完成Hybrid开发</p>\n<p>熟练使用Npm、Gulp和Webpack对项目进行构建</p>\n<p>熟悉Javascript原型、闭包、面向对象的编程，并且使用面向对象的思想进行组件化开发</p>\n<p>熟悉linux常用命令，git流程、H5相关调试工具</p>\n<p>js的异步编程，以及Node、Php、Mysql、MongoDB相关技术</p>\n</blockquote>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2><blockquote>\n<p>淘旅行网络科技有限公司<br>职位名称：前端开发工程师<br>工作时间：2016/01 - 至今<br>工作描述:<br>&nbsp;&nbsp;&nbsp;&nbsp;1.参与项目组件的开发，配合完成基本框架的搭建，以及一些PC端旧项目的重构<br>&nbsp;&nbsp;&nbsp;&nbsp;2.配合产品和测试完成代码的编写任务，并按时上线，并维护后期工作<br>&nbsp;&nbsp;&nbsp;&nbsp;3.公司的一些自动化构建工具的开发</p>\n<p>江苏微悦信息技术有限公司<br>职位名称：前端开发工程师<br>工作时间：2015/04 - 2016/01<br>工作描述：<br>&nbsp;&nbsp;&nbsp;&nbsp;1.参与公司的切图工 作,并且用SASS编写可维护的CSS代码，让模块的样式更加颗粒化<br>&nbsp;&nbsp;&nbsp;&nbsp;2.用Jquery库编写常用页面效果<br>&nbsp;&nbsp;&nbsp;&nbsp;3.用angular1版本配合bootstrap开发后台管理系统交互的相关页面</p>\n</blockquote>\n<h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><h3 id=\"Hybrid、H5公司产品\"><a href=\"#Hybrid、H5公司产品\" class=\"headerlink\" title=\"Hybrid、H5公司产品\"></a>Hybrid、H5公司产品</h3><ol>\n<li>前端架构： jquery + Vue + 基础框架</li>\n<li>开发周期： 2016/01 - 至今</li>\n<li>项目描述： 为用户提供可选，如何进行打包，如何进行项目的构建，并且独自一人使用vue进行业务开发，运用了相关的vuex，vue-router等技术</li>\n<li><a href=\"https://wbcz.github.io/2017/03/11/js-%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/\" style=\"color:red;\" target=\"_blank\" rel=\"external\">简要介绍地址，一睹为快哟</a></li>\n</ol>\n<h3 id=\"公司PC端项目的重构\"><a href=\"#公司PC端项目的重构\" class=\"headerlink\" title=\"公司PC端项目的重构\"></a>公司PC端项目的重构</h3><ol>\n<li>开发周期： 2016/01 - 2016/04</li>\n<li>项目描述： 为用户提供可选择的旅游产品，单机，单酒，酒景，机酒，自由行等服务</li>\n<li>责任描述:  （背景：为了使项目更加的容易维护并且提升网站的性能，对原有的开发模式进行大幅度调整，是项目更加自动化，PC端项目刚开始是页面是在后端绑定数据，然后前端提供静态页面和交互效果，但是随着项目的复杂加大，每个页面引入的css和js越来越多，并且页面的样式也在不断升级，css也造成不断的冗余，并且样式也没使用sass这些技术。）<br>我负责对项目自动化构建，首先启动sass，和同事进行协商，并且把common.css抽离成模块化的样式，并且把插件的css样式抽离出来，然后每个页面只有一个css文件，其他的模块样式通过sass直接引入即可。那么接下来我用gulp写个脚本，分别对样html，css，img进行编译打包压缩到build目录，另外我会把相对路径通过正则匹配到然后替换测试环境的地址，这样子当我们把代码发送到测试服务器上的时候，后端也能够直接看到静态页面的效果。</li>\n</ol>\n"},{"title":"好用的npm包","type":"categories","_content":"\n## minist\n 把node命令行的参数转为对象的形式\n## shelljs\nhttps://github.com/shelljs/shelljs\n执行shell命令，比如可以把不常用的包编译一次，然后每次只需要用cp()移动进去即可，在webpack减少了编译时间\n## ora\n显示命令行状态图标的\n## 同步获取所有路径\nglob库，通过正则匹配到所有路径\n\n## NProgress\n实现进度条，一般用在ajax请求数据的时候\n\n## qs\n格式化url传递参数","source":"_posts/utils/好用的npm包.md","raw":"---\ntitle: 好用的npm包\ntype: \"categories\"\ncategories: 工具\n---\n\n## minist\n 把node命令行的参数转为对象的形式\n## shelljs\nhttps://github.com/shelljs/shelljs\n执行shell命令，比如可以把不常用的包编译一次，然后每次只需要用cp()移动进去即可，在webpack减少了编译时间\n## ora\n显示命令行状态图标的\n## 同步获取所有路径\nglob库，通过正则匹配到所有路径\n\n## NProgress\n实现进度条，一般用在ajax请求数据的时候\n\n## qs\n格式化url传递参数","slug":"utils-好用的npm包","published":1,"date":"2017-05-01T02:41:15.000Z","updated":"2017-05-01T02:41:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdl001tkzy61a57kawb","content":"<h2 id=\"minist\"><a href=\"#minist\" class=\"headerlink\" title=\"minist\"></a>minist</h2><p> 把node命令行的参数转为对象的形式</p>\n<h2 id=\"shelljs\"><a href=\"#shelljs\" class=\"headerlink\" title=\"shelljs\"></a>shelljs</h2><p><a href=\"https://github.com/shelljs/shelljs\" target=\"_blank\" rel=\"external\">https://github.com/shelljs/shelljs</a><br>执行shell命令，比如可以把不常用的包编译一次，然后每次只需要用cp()移动进去即可，在webpack减少了编译时间</p>\n<h2 id=\"ora\"><a href=\"#ora\" class=\"headerlink\" title=\"ora\"></a>ora</h2><p>显示命令行状态图标的</p>\n<h2 id=\"同步获取所有路径\"><a href=\"#同步获取所有路径\" class=\"headerlink\" title=\"同步获取所有路径\"></a>同步获取所有路径</h2><p>glob库，通过正则匹配到所有路径</p>\n<h2 id=\"NProgress\"><a href=\"#NProgress\" class=\"headerlink\" title=\"NProgress\"></a>NProgress</h2><p>实现进度条，一般用在ajax请求数据的时候</p>\n<h2 id=\"qs\"><a href=\"#qs\" class=\"headerlink\" title=\"qs\"></a>qs</h2><p>格式化url传递参数</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"minist\"><a href=\"#minist\" class=\"headerlink\" title=\"minist\"></a>minist</h2><p> 把node命令行的参数转为对象的形式</p>\n<h2 id=\"shelljs\"><a href=\"#shelljs\" class=\"headerlink\" title=\"shelljs\"></a>shelljs</h2><p><a href=\"https://github.com/shelljs/shelljs\" target=\"_blank\" rel=\"external\">https://github.com/shelljs/shelljs</a><br>执行shell命令，比如可以把不常用的包编译一次，然后每次只需要用cp()移动进去即可，在webpack减少了编译时间</p>\n<h2 id=\"ora\"><a href=\"#ora\" class=\"headerlink\" title=\"ora\"></a>ora</h2><p>显示命令行状态图标的</p>\n<h2 id=\"同步获取所有路径\"><a href=\"#同步获取所有路径\" class=\"headerlink\" title=\"同步获取所有路径\"></a>同步获取所有路径</h2><p>glob库，通过正则匹配到所有路径</p>\n<h2 id=\"NProgress\"><a href=\"#NProgress\" class=\"headerlink\" title=\"NProgress\"></a>NProgress</h2><p>实现进度条，一般用在ajax请求数据的时候</p>\n<h2 id=\"qs\"><a href=\"#qs\" class=\"headerlink\" title=\"qs\"></a>qs</h2><p>格式化url传递参数</p>\n"},{"title":"webpack2进阶","type":"categories","_content":"\n### 指定静态资源的url路径前缀\n\n现在我们的资源文件的url直接在根目录, 比如http://127.0.0.1:8100/index.js, 这样做缓存控制和CDN都不方便, 我们需要给资源文件的url加一个前缀, 比如 http://127.0.0.1:8100/assets/index.js这样. 我们来修改一下webpack配置:\n```\n{\n  output: {\n    publicPath: '/assets/'\n  },\n\n  devServer: {\n    // 指定index.html文件的url路径\n    historyApiFallback: {\n      index: '/assets/'\n    }\n  }\n}\n```\n\n### 常用库单独打包\ndllPlugin()\n\n### 简化import路径\n```\nresolve: {\n  alias: {\n    '~': resolve(__dirname, 'src')\n  }\n}\n```\n\n## 开发环境允许其他电脑访问\n\nwebpack配置devServer.host为'0.0.0.0'即可.\n\n## 打包时自定义部分参数\n\ndefault.js\n```\nmodule.exports = {\n  publicPath: 'http://cdn.example.com/assets/'\n}\n```\n\ndev.js: 默认开发环境\n```\nmodule.exports = {\n  publicPath: '/assets/',\n\n  devServer: {\n    port: 8100,\n    proxy: {\n      '/api/auth/': {\n        target: 'http://api.example.dev',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' }\n      },\n\n      '/api/pay/': {\n        target: 'http://pay.example.dev',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' }\n      }\n    }\n  }\n}\n```\nlocal.js  个人本地环境, 在dev.js基础上修改部分参数.\n```\nconst config = require('./dev')\nconfig.devServer.port = 8200\nmodule.exports = config\n```\npackage.json修改scripts:\n\n```\n{\n  \"scripts\": {\n    \"local\": \"npm run dev --config=local\",\n    \"dev\": \"webpack-dev-server -d --hot --env.dev --env.config dev\",\n    \"build\": \"rimraf dist && webpack -p\"\n  }\n}\n\n```\n\n这里的关键是npm run传进来的自定义参数可以通过process.env.npm_config_*获得. 参数中如果有-会被转成_\n--env.*传进来的参数可以通过options.*获得. 我们优先使用npm run指定的配置文件. 这样我们可以在命令行覆盖scripts中指定的配置文件:\n\n```\nnpm run dev --config=CONFIG_NAME\n```\n\nconfig.devServer.proxy用来配置后端api的反向代理\n\nconfig.devServer.proxy用来配置后端api的反向代理, ajax /api/auth/*的请求会被转发到 http://api.example.dev/auth/*, /api/pay/*的请求会被转发到 http://api.example.dev/pay/*.\n\nchangeOrigin会修改HTTP请求头中的Host为target的域名, 这里会被改为api.example.dev\n\npathRewrite用来改写URL, 这里我们把/api前缀去掉.\n\n\n## 代码中插入环境变量\n```\nconst pkgInfo = require('./package.json')\n\nmodule.exports = (options = {}) => {\n  const config = require('./conf/' + (process.env.npm_config_config || options.config || 'default')).default\n\n  return {\n    // ...\n    plugins: [\n      new webpack.DefinePlugin({\n        DEBUG: Boolean(options.dev),\n        VERSION: JSON.stringify(pkgInfo.version),\n        CONFIG: JSON.stringify(config.runtimeConfig)\n      })\n    ]\n  }\n}\n```\nDefinePlugin插件的原理很简单, 如果我们在代码中写:\n```\nconsole.log(DEBUG) ==> console.log(true)\n\n//代码压缩的时候进行判断\nif (DEBUG) {\n  console.log('debug mode')\n} else {\n  console.log('production mode')\n}\n```\n\n## 编译前清空dist目录\n本来可以采用rm -rf 目录，但是考虑到跨平台需要安装一个包**rimraf**\n```\n{\n  \"scripts\": {\n    \"build\": \"rimraf dist && webpack -p --env.config production\"\n  },\n}\n```\n\n## 在 Webpack 中使用公用 CDN\nWebpack 是如此的强大，用其打包的脚本可以运行在多种环境下，Web 环境只是其默认的一种，也是最常用的一种。考虑到 Web 上有很多的公用 CDN 服务，那么 怎么将 Webpack 和公用的 CDN 结合使用呢？方法是使用 externals 声明一个外部依赖,这样指定的依赖不会被webpack解析，但会成为bundle里的依赖\n```\n externals: {\n    moment: true\n  }\n```\n当然了 HTML 代码里需要加上一行\n```\n<script src=\"//apps.bdimg.com/libs/moment/2.8.3/moment-with-locales.min.js\"></script>\n```\n[参考](https://segmentfault.com/a/1190000007914129#articleHeader24)","source":"_posts/utils/webpack2进阶.md","raw":"---\ntitle: webpack2进阶\ntype: \"categories\"\ncategories: 工具\n---\n\n### 指定静态资源的url路径前缀\n\n现在我们的资源文件的url直接在根目录, 比如http://127.0.0.1:8100/index.js, 这样做缓存控制和CDN都不方便, 我们需要给资源文件的url加一个前缀, 比如 http://127.0.0.1:8100/assets/index.js这样. 我们来修改一下webpack配置:\n```\n{\n  output: {\n    publicPath: '/assets/'\n  },\n\n  devServer: {\n    // 指定index.html文件的url路径\n    historyApiFallback: {\n      index: '/assets/'\n    }\n  }\n}\n```\n\n### 常用库单独打包\ndllPlugin()\n\n### 简化import路径\n```\nresolve: {\n  alias: {\n    '~': resolve(__dirname, 'src')\n  }\n}\n```\n\n## 开发环境允许其他电脑访问\n\nwebpack配置devServer.host为'0.0.0.0'即可.\n\n## 打包时自定义部分参数\n\ndefault.js\n```\nmodule.exports = {\n  publicPath: 'http://cdn.example.com/assets/'\n}\n```\n\ndev.js: 默认开发环境\n```\nmodule.exports = {\n  publicPath: '/assets/',\n\n  devServer: {\n    port: 8100,\n    proxy: {\n      '/api/auth/': {\n        target: 'http://api.example.dev',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' }\n      },\n\n      '/api/pay/': {\n        target: 'http://pay.example.dev',\n        changeOrigin: true,\n        pathRewrite: { '^/api': '' }\n      }\n    }\n  }\n}\n```\nlocal.js  个人本地环境, 在dev.js基础上修改部分参数.\n```\nconst config = require('./dev')\nconfig.devServer.port = 8200\nmodule.exports = config\n```\npackage.json修改scripts:\n\n```\n{\n  \"scripts\": {\n    \"local\": \"npm run dev --config=local\",\n    \"dev\": \"webpack-dev-server -d --hot --env.dev --env.config dev\",\n    \"build\": \"rimraf dist && webpack -p\"\n  }\n}\n\n```\n\n这里的关键是npm run传进来的自定义参数可以通过process.env.npm_config_*获得. 参数中如果有-会被转成_\n--env.*传进来的参数可以通过options.*获得. 我们优先使用npm run指定的配置文件. 这样我们可以在命令行覆盖scripts中指定的配置文件:\n\n```\nnpm run dev --config=CONFIG_NAME\n```\n\nconfig.devServer.proxy用来配置后端api的反向代理\n\nconfig.devServer.proxy用来配置后端api的反向代理, ajax /api/auth/*的请求会被转发到 http://api.example.dev/auth/*, /api/pay/*的请求会被转发到 http://api.example.dev/pay/*.\n\nchangeOrigin会修改HTTP请求头中的Host为target的域名, 这里会被改为api.example.dev\n\npathRewrite用来改写URL, 这里我们把/api前缀去掉.\n\n\n## 代码中插入环境变量\n```\nconst pkgInfo = require('./package.json')\n\nmodule.exports = (options = {}) => {\n  const config = require('./conf/' + (process.env.npm_config_config || options.config || 'default')).default\n\n  return {\n    // ...\n    plugins: [\n      new webpack.DefinePlugin({\n        DEBUG: Boolean(options.dev),\n        VERSION: JSON.stringify(pkgInfo.version),\n        CONFIG: JSON.stringify(config.runtimeConfig)\n      })\n    ]\n  }\n}\n```\nDefinePlugin插件的原理很简单, 如果我们在代码中写:\n```\nconsole.log(DEBUG) ==> console.log(true)\n\n//代码压缩的时候进行判断\nif (DEBUG) {\n  console.log('debug mode')\n} else {\n  console.log('production mode')\n}\n```\n\n## 编译前清空dist目录\n本来可以采用rm -rf 目录，但是考虑到跨平台需要安装一个包**rimraf**\n```\n{\n  \"scripts\": {\n    \"build\": \"rimraf dist && webpack -p --env.config production\"\n  },\n}\n```\n\n## 在 Webpack 中使用公用 CDN\nWebpack 是如此的强大，用其打包的脚本可以运行在多种环境下，Web 环境只是其默认的一种，也是最常用的一种。考虑到 Web 上有很多的公用 CDN 服务，那么 怎么将 Webpack 和公用的 CDN 结合使用呢？方法是使用 externals 声明一个外部依赖,这样指定的依赖不会被webpack解析，但会成为bundle里的依赖\n```\n externals: {\n    moment: true\n  }\n```\n当然了 HTML 代码里需要加上一行\n```\n<script src=\"//apps.bdimg.com/libs/moment/2.8.3/moment-with-locales.min.js\"></script>\n```\n[参考](https://segmentfault.com/a/1190000007914129#articleHeader24)","slug":"utils-webpack2进阶","published":1,"date":"2017-03-16T07:14:30.000Z","updated":"2017-03-16T07:14:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdn001vkzy6brjczbu9","content":"<h3 id=\"指定静态资源的url路径前缀\"><a href=\"#指定静态资源的url路径前缀\" class=\"headerlink\" title=\"指定静态资源的url路径前缀\"></a>指定静态资源的url路径前缀</h3><p>现在我们的资源文件的url直接在根目录, 比如<a href=\"http://127.0.0.1:8100/index.js\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8100/index.js</a>, 这样做缓存控制和CDN都不方便, 我们需要给资源文件的url加一个前缀, 比如 <a href=\"http://127.0.0.1:8100/assets/index.js这样\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8100/assets/index.js这样</a>. 我们来修改一下webpack配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    publicPath: &apos;/assets/&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  devServer: &#123;</div><div class=\"line\">    // 指定index.html文件的url路径</div><div class=\"line\">    historyApiFallback: &#123;</div><div class=\"line\">      index: &apos;/assets/&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"常用库单独打包\"><a href=\"#常用库单独打包\" class=\"headerlink\" title=\"常用库单独打包\"></a>常用库单独打包</h3><p>dllPlugin()</p>\n<h3 id=\"简化import路径\"><a href=\"#简化import路径\" class=\"headerlink\" title=\"简化import路径\"></a>简化import路径</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">resolve: &#123;</div><div class=\"line\">  alias: &#123;</div><div class=\"line\">    &apos;~&apos;: resolve(__dirname, &apos;src&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"开发环境允许其他电脑访问\"><a href=\"#开发环境允许其他电脑访问\" class=\"headerlink\" title=\"开发环境允许其他电脑访问\"></a>开发环境允许其他电脑访问</h2><p>webpack配置devServer.host为’0.0.0.0’即可.</p>\n<h2 id=\"打包时自定义部分参数\"><a href=\"#打包时自定义部分参数\" class=\"headerlink\" title=\"打包时自定义部分参数\"></a>打包时自定义部分参数</h2><p>default.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  publicPath: &apos;http://cdn.example.com/assets/&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>dev.js: 默认开发环境<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  publicPath: &apos;/assets/&apos;,</div><div class=\"line\"></div><div class=\"line\">  devServer: &#123;</div><div class=\"line\">    port: 8100,</div><div class=\"line\">    proxy: &#123;</div><div class=\"line\">      &apos;/api/auth/&apos;: &#123;</div><div class=\"line\">        target: &apos;http://api.example.dev&apos;,</div><div class=\"line\">        changeOrigin: true,</div><div class=\"line\">        pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &apos;/api/pay/&apos;: &#123;</div><div class=\"line\">        target: &apos;http://pay.example.dev&apos;,</div><div class=\"line\">        changeOrigin: true,</div><div class=\"line\">        pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>local.js  个人本地环境, 在dev.js基础上修改部分参数.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const config = require(&apos;./dev&apos;)</div><div class=\"line\">config.devServer.port = 8200</div><div class=\"line\">module.exports = config</div></pre></td></tr></table></figure></p>\n<p>package.json修改scripts:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;local&quot;: &quot;npm run dev --config=local&quot;,</div><div class=\"line\">    &quot;dev&quot;: &quot;webpack-dev-server -d --hot --env.dev --env.config dev&quot;,</div><div class=\"line\">    &quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack -p&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的关键是npm run传进来的自定义参数可以通过process.env.npm<em>config</em><em>获得. 参数中如果有-会被转成_<br>–env.</em>传进来的参数可以通过options.*获得. 我们优先使用npm run指定的配置文件. 这样我们可以在命令行覆盖scripts中指定的配置文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm run dev --config=CONFIG_NAME</div></pre></td></tr></table></figure>\n<p>config.devServer.proxy用来配置后端api的反向代理</p>\n<p>config.devServer.proxy用来配置后端api的反向代理, ajax /api/auth/<em>的请求会被转发到 <a href=\"http://api.example.dev/auth/\" target=\"_blank\" rel=\"external\">http://api.example.dev/auth/</a></em>, /api/pay/<em>的请求会被转发到 <a href=\"http://api.example.dev/pay/\" target=\"_blank\" rel=\"external\">http://api.example.dev/pay/</a></em>.</p>\n<p>changeOrigin会修改HTTP请求头中的Host为target的域名, 这里会被改为api.example.dev</p>\n<p>pathRewrite用来改写URL, 这里我们把/api前缀去掉.</p>\n<h2 id=\"代码中插入环境变量\"><a href=\"#代码中插入环境变量\" class=\"headerlink\" title=\"代码中插入环境变量\"></a>代码中插入环境变量</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">const pkgInfo = require(&apos;./package.json&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = (options = &#123;&#125;) =&gt; &#123;</div><div class=\"line\">  const config = require(&apos;./conf/&apos; + (process.env.npm_config_config || options.config || &apos;default&apos;)).default</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">    plugins: [</div><div class=\"line\">      new webpack.DefinePlugin(&#123;</div><div class=\"line\">        DEBUG: Boolean(options.dev),</div><div class=\"line\">        VERSION: JSON.stringify(pkgInfo.version),</div><div class=\"line\">        CONFIG: JSON.stringify(config.runtimeConfig)</div><div class=\"line\">      &#125;)</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DefinePlugin插件的原理很简单, 如果我们在代码中写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(DEBUG) ==&gt; console.log(true)</div><div class=\"line\"></div><div class=\"line\">//代码压缩的时候进行判断</div><div class=\"line\">if (DEBUG) &#123;</div><div class=\"line\">  console.log(&apos;debug mode&apos;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  console.log(&apos;production mode&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"编译前清空dist目录\"><a href=\"#编译前清空dist目录\" class=\"headerlink\" title=\"编译前清空dist目录\"></a>编译前清空dist目录</h2><p>本来可以采用rm -rf 目录，但是考虑到跨平台需要安装一个包<strong>rimraf</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack -p --env.config production&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"在-Webpack-中使用公用-CDN\"><a href=\"#在-Webpack-中使用公用-CDN\" class=\"headerlink\" title=\"在 Webpack 中使用公用 CDN\"></a>在 Webpack 中使用公用 CDN</h2><p>Webpack 是如此的强大，用其打包的脚本可以运行在多种环境下，Web 环境只是其默认的一种，也是最常用的一种。考虑到 Web 上有很多的公用 CDN 服务，那么 怎么将 Webpack 和公用的 CDN 结合使用呢？方法是使用 externals 声明一个外部依赖,这样指定的依赖不会被webpack解析，但会成为bundle里的依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals: &#123;</div><div class=\"line\">   moment: true</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>当然了 HTML 代码里需要加上一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;//apps.bdimg.com/libs/moment/2.8.3/moment-with-locales.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://segmentfault.com/a/1190000007914129#articleHeader24\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"指定静态资源的url路径前缀\"><a href=\"#指定静态资源的url路径前缀\" class=\"headerlink\" title=\"指定静态资源的url路径前缀\"></a>指定静态资源的url路径前缀</h3><p>现在我们的资源文件的url直接在根目录, 比如<a href=\"http://127.0.0.1:8100/index.js\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8100/index.js</a>, 这样做缓存控制和CDN都不方便, 我们需要给资源文件的url加一个前缀, 比如 <a href=\"http://127.0.0.1:8100/assets/index.js这样\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8100/assets/index.js这样</a>. 我们来修改一下webpack配置:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    publicPath: &apos;/assets/&apos;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  devServer: &#123;</div><div class=\"line\">    // 指定index.html文件的url路径</div><div class=\"line\">    historyApiFallback: &#123;</div><div class=\"line\">      index: &apos;/assets/&apos;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"常用库单独打包\"><a href=\"#常用库单独打包\" class=\"headerlink\" title=\"常用库单独打包\"></a>常用库单独打包</h3><p>dllPlugin()</p>\n<h3 id=\"简化import路径\"><a href=\"#简化import路径\" class=\"headerlink\" title=\"简化import路径\"></a>简化import路径</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">resolve: &#123;</div><div class=\"line\">  alias: &#123;</div><div class=\"line\">    &apos;~&apos;: resolve(__dirname, &apos;src&apos;)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"开发环境允许其他电脑访问\"><a href=\"#开发环境允许其他电脑访问\" class=\"headerlink\" title=\"开发环境允许其他电脑访问\"></a>开发环境允许其他电脑访问</h2><p>webpack配置devServer.host为’0.0.0.0’即可.</p>\n<h2 id=\"打包时自定义部分参数\"><a href=\"#打包时自定义部分参数\" class=\"headerlink\" title=\"打包时自定义部分参数\"></a>打包时自定义部分参数</h2><p>default.js<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  publicPath: &apos;http://cdn.example.com/assets/&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>dev.js: 默认开发环境<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  publicPath: &apos;/assets/&apos;,</div><div class=\"line\"></div><div class=\"line\">  devServer: &#123;</div><div class=\"line\">    port: 8100,</div><div class=\"line\">    proxy: &#123;</div><div class=\"line\">      &apos;/api/auth/&apos;: &#123;</div><div class=\"line\">        target: &apos;http://api.example.dev&apos;,</div><div class=\"line\">        changeOrigin: true,</div><div class=\"line\">        pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &apos;/api/pay/&apos;: &#123;</div><div class=\"line\">        target: &apos;http://pay.example.dev&apos;,</div><div class=\"line\">        changeOrigin: true,</div><div class=\"line\">        pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos; &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>local.js  个人本地环境, 在dev.js基础上修改部分参数.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const config = require(&apos;./dev&apos;)</div><div class=\"line\">config.devServer.port = 8200</div><div class=\"line\">module.exports = config</div></pre></td></tr></table></figure></p>\n<p>package.json修改scripts:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;local&quot;: &quot;npm run dev --config=local&quot;,</div><div class=\"line\">    &quot;dev&quot;: &quot;webpack-dev-server -d --hot --env.dev --env.config dev&quot;,</div><div class=\"line\">    &quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack -p&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里的关键是npm run传进来的自定义参数可以通过process.env.npm<em>config</em><em>获得. 参数中如果有-会被转成_<br>–env.</em>传进来的参数可以通过options.*获得. 我们优先使用npm run指定的配置文件. 这样我们可以在命令行覆盖scripts中指定的配置文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm run dev --config=CONFIG_NAME</div></pre></td></tr></table></figure>\n<p>config.devServer.proxy用来配置后端api的反向代理</p>\n<p>config.devServer.proxy用来配置后端api的反向代理, ajax /api/auth/<em>的请求会被转发到 <a href=\"http://api.example.dev/auth/\" target=\"_blank\" rel=\"external\">http://api.example.dev/auth/</a></em>, /api/pay/<em>的请求会被转发到 <a href=\"http://api.example.dev/pay/\" target=\"_blank\" rel=\"external\">http://api.example.dev/pay/</a></em>.</p>\n<p>changeOrigin会修改HTTP请求头中的Host为target的域名, 这里会被改为api.example.dev</p>\n<p>pathRewrite用来改写URL, 这里我们把/api前缀去掉.</p>\n<h2 id=\"代码中插入环境变量\"><a href=\"#代码中插入环境变量\" class=\"headerlink\" title=\"代码中插入环境变量\"></a>代码中插入环境变量</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">const pkgInfo = require(&apos;./package.json&apos;)</div><div class=\"line\"></div><div class=\"line\">module.exports = (options = &#123;&#125;) =&gt; &#123;</div><div class=\"line\">  const config = require(&apos;./conf/&apos; + (process.env.npm_config_config || options.config || &apos;default&apos;)).default</div><div class=\"line\"></div><div class=\"line\">  return &#123;</div><div class=\"line\">    // ...</div><div class=\"line\">    plugins: [</div><div class=\"line\">      new webpack.DefinePlugin(&#123;</div><div class=\"line\">        DEBUG: Boolean(options.dev),</div><div class=\"line\">        VERSION: JSON.stringify(pkgInfo.version),</div><div class=\"line\">        CONFIG: JSON.stringify(config.runtimeConfig)</div><div class=\"line\">      &#125;)</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>DefinePlugin插件的原理很简单, 如果我们在代码中写:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">console.log(DEBUG) ==&gt; console.log(true)</div><div class=\"line\"></div><div class=\"line\">//代码压缩的时候进行判断</div><div class=\"line\">if (DEBUG) &#123;</div><div class=\"line\">  console.log(&apos;debug mode&apos;)</div><div class=\"line\">&#125; else &#123;</div><div class=\"line\">  console.log(&apos;production mode&apos;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"编译前清空dist目录\"><a href=\"#编译前清空dist目录\" class=\"headerlink\" title=\"编译前清空dist目录\"></a>编译前清空dist目录</h2><p>本来可以采用rm -rf 目录，但是考虑到跨平台需要安装一个包<strong>rimraf</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack -p --env.config production&quot;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"在-Webpack-中使用公用-CDN\"><a href=\"#在-Webpack-中使用公用-CDN\" class=\"headerlink\" title=\"在 Webpack 中使用公用 CDN\"></a>在 Webpack 中使用公用 CDN</h2><p>Webpack 是如此的强大，用其打包的脚本可以运行在多种环境下，Web 环境只是其默认的一种，也是最常用的一种。考虑到 Web 上有很多的公用 CDN 服务，那么 怎么将 Webpack 和公用的 CDN 结合使用呢？方法是使用 externals 声明一个外部依赖,这样指定的依赖不会被webpack解析，但会成为bundle里的依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">externals: &#123;</div><div class=\"line\">   moment: true</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>当然了 HTML 代码里需要加上一行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;//apps.bdimg.com/libs/moment/2.8.3/moment-with-locales.min.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://segmentfault.com/a/1190000007914129#articleHeader24\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"webpack2","type":"categories","_content":"\n\n## 为什么要有webpack\n- 依赖加载混乱\n- 引用重复的代码\n- 等等\n本来他是个打包工具，但是现在它俨然成了一个管理工具\n\n## webpack2如何运行\n- 从context 文件夹\n- 查找entry对应文件\n- 找到文件夹，执行该文件的所有的依赖\n- 输出到对应的目录\n```\nconst path = require('path');\nconst webpack = require('webpack');\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    app: './app.js',\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].bundle.js',\n    libraryTarget: 'umd' //以什么样的模式导出代码\n  },\n};\n```\n## 命令行输入 webpack 命令,发生了什么\n- 首先npm会把包的可执行文件安装到./node_modules/.bin/目录下, 所以我们要在这个目录下执行命令.\n- 执行 bin 目录下的 webpack.js 脚本，解析命令行参数以及开始执行编译。\n- 调用 lib 目录下的 webpack.js 文件的核心函数 webpack ，实例化一个 Compiler，继承 Tapable 插件框架，实现注册和调用一系列插件。\n- 调用 lib 目录下的 /WebpackOptionsApply.js 模块的 process 方法，使用各种各样的插件来逐一编译 webpack 编译对象的各项。\n- 在3中调用的各种插件编译并输出新文件。\n\n## 打包方式\n- webpack -p //生产打包\n- webpack -d --hot//开发打包\n-d参数是开发环境(Development)的意思, 它会在我们的配置文件中插入调试相关的选项, 比如打开debug, 打开sourceMap, 代码中插入源文件路径注释.\n--hot开启热更新功能, 参数会帮我们往配置里添加HotModuleReplacementPlugin插件, 虽然可以在配置里自己写, 但有点麻烦, 用命令行参数方便很多.\n\n运行命令之后, Webpack 会输出一个 dist/app.bundle.js 文件, 同时在控制台输出当前日期. 需要注意的是, Webpack 会自动找到 moment 的指向(即使你有一个 moment.js 存在于目录中, 但 Webpack 默认会优先去寻找 moment 的Node模块).\n\n\n## 多文件\n- 多个入口文件打包出一个出口文件\n```\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    app: ['./home.js', './events.js', './vendor.js'],\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].bundle.js',\n  },\n};\n\n```\n\n- 多个入口文件打包出多个出口文件\n\n```\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    home: './home.js',\n    events: './events.js',\n    contact: './contact.js',\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].bundle.js',\n  },\n};\n```\n\n## 自动打包\n\n如果你将应用分开打包到多个 output 文件里(如果你的应用有非常多的 JavaScript 文件不需要在前期加载, 这样做是非常有效的), 有可能会出现很多冗余的代码, 因为 Webpack 是独立解析每个文件的依赖的. 幸运的是, Webpack 已经内置了 CommonsChunk 插件来处理这个问题:\n\n```\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'commons',\n      filename: 'commons.js',\n      minChunks: 2,\n    }),\n```\n\n加上 CommonsChunk 插件后, 任何一个模块在你的 output 文件中被加载 2 次(该值由 minChunks 设置)及以上, 该模块就会被打包在 common.js 中, 你可以在客户端缓存这些模块. 虽然这会增加额外的请求, 但这能防止客户端多次下载同一个模块.\n\n## 开发环境\n为启动服务器, 仅需要在 webpack.config.js 中添加一个 devServer 对象:\n```\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    app: './app.js',\n  },\n  output: {\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, './dist/assets'),\n    publicPath: '/assets',                          // New\n  },\n  devServer: {\n    contentBase: path.resolve(__dirname, './src'),  // New\n    //historyApiFallback用来配置页面的重定向\n    //配置为true, 当访问的文件不存在时, 返回根目录下的index.html文件\n    historyApiFallback: true\n  },\n};\n```\n在 src 目录下创建一个带如下标签的 index.html 文件:\n\n```\n<script src=\"/assets/app.bundle.js\"></script>\n```\n在终端运行如下命令:\n```\n\twebpack-dev-server\n```\n## 全局方法调用\n需要使用在全局作用域下的函数? 只需在 output.library 进行简单的设置就行:\n```\nmodule.exports = {\n output: {\n   library: 'myClassName',\n }\n};\n```\n它会把你的打包文件捆绑在 window.myClassName 实例上. 设置了作用域之后, 你可以在文件的入口处进行调用\n\n## 总结1\n到目前为止, 我只介绍了怎么使用 Webpack 处理 JavaScript 文件. 从处理 JavaScript 文件开始是非常重要的, 因为这是 Webpack 唯一能识别的语言. 实际上, Webpack 可以使用 Loaders 来处理各种通过 JavaScript 传递的任何类型的文件。\n\n## Loaders\nloader 可以是像 Sass 这样的预处理器, 也可以是像 Babel 这样的编译器. 在 NPM 里, 它们通常被命名为 *-loader, 例如: sass-loader 或者 babel-loader.\n- 先安装包 yarn install\n- 通过正则匹配文件路径，然后进行编译加载处理\n### Babel+ES6\n### CSS+Style Loader\n```\nmodule.exports = {\n  // …\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      // …\n    ],\n  },\n};\n```\nLoaders会按照数组的逆序运行, 也就是说, 会先运行 css-loader, 后运行 style-loader.\n\n你可能会注意到, 在生产环境下, CSS 会被打包到 JavaScript 文件里, style-loader 则会把样式写在 style 标签中. 此外, Webpack 通过将这些文件打包成一个文件来自动地解析所有的 @import 查询(而不是依赖 CSS 的默认 import 功能, 这会导致额外的 header 请求, 并且加载资源非常慢).\n\n从 JavaScript 中加载 CSS 是非常神奇的, 因为这样你可以用新的方式将 CSS 模块化. 也就是说, 可以仅通过 button.js 来加载 button.css, 这意味着如果 button.js 没有用到, 其对应的 CSS 也不会被构建到生产环境中.\n\n### CSS+Node 模块\n我们可以使用 Webpack 里的 ~ 前缀来引入 Node 模块\n```\n@import \"~normalize.css\";\n```\n这样就可以充分利用 NPM 管理第三方样式库的优点---版本更新和避免复制和粘贴. 更近一步, 和 CSS 默认的 import 功能相比, 用 Webpack 打包 CSS 有明显的优势, 因为它可以为客户端减少头部请求以及缓慢的加载时间.\n\n### 将 CSS 分开打包\n\n你可能需要处理渐进增强的情况, 也可能因某些原因需要分离 CSS 文件. 这个也很简单, 只需将配置文件中的 style-loader 用 extract-text-webpack-plugin 代替就行.\n```\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n  // …\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        loader:  ExtractTextPlugin.extract({\n          loader: 'css-loader?importLoaders=1',\n        }),\n      },\n    \n      // …\n    ],\n    noParse: /node_modules\\/(jquey|moment|chart\\.js)/   //这些库没有必要去解析他们的依赖\n  },\n  plugins: [\n    new ExtractTextPlugin({\n      filename: '[name].bundle.css',\n      allChunks: true,\n    }),\n  ],\n};\n```\n运行 webpack -p 之后, 你会发现在 output 指定的目录中会有一个 app.bundle.css 文件. 最后, 在 HTML 文件中通过 <link> 标签正常引用.\n\n## 实现ES6的模块加载\n可以用import,export，不需要把他们转成CommonJS模块的格式\n\n### 代码分割\n\n- ES6 Loader 规范定义了 System.import 方法，用于在运行时动态加载 ES6 模块。\n- Webpack 把 System.import 作为拆分点，然后把被请求的模块放入一个单独的 “块”（chunk）中。\n- System.import 接受模块名作为参数，然后返回一个 Promise。\n- chunk 加载失败产生的错误现在可以被捕获了。\n```\n\tSystem.import(\"./module\").then(module => {\n\t\tmodule.default;\n\t}).catch(err => {\n\t\tconsole.log(\"Chunk loading failed\");\n\t});\n```\n开发服务器会运行在 localhost:8080(打开你的浏览器访问该地址就能看到你的页面). 需要注意的是 script 标签里的 /assets 是和 output.publicPath 匹配的--你可以把它命名成任何你想要的名字(如果你使用CDN, 这会很有用).\nWebpack 提供了热加载功能. 当你修改了 JavaScript 文件后, Webpack 会自动重新加载资源, 而不需要你手动去刷新浏览器. 但是, 任何对 webpack.config.js 文件的改变都需要重启服务器才会生效.\n\n**动态表达式**\n还可以把一个表达式作为参数传给 System.import。表达式的处理方式类似于 CommonJS（Webpack 为每个可能的文件创建一个独立的上下文）。\nSystem.import 会令每个可能的模块都产生一个独立的 chunk。所以就可以用循环产生多个 chunk，感觉简写了有木有\n\n```\nfunction route(path, query) {\n\treturn System.import(\"./routes/\" + path + \"/route\")\n\t\t.then(route => new route.Route(query));\n}\n// 这会为每种可能的路径组合都创建一个对应的 chunk。\n```\n\n### Babel 与 Webpack\n\n在默认情况下，Babel 的 es2015 预设方案（preset）会把 ES6 模块转换为 CommonJS 格式。如果你想让 Webpack 来处理 ES6 模块，那你应该换用 es2015-webpack 这个预设方案。\n\n## 配置\n在过去的环境中，变量通常用来在配置文件中处理不同的环境。Webpack 2 引入了一种新方法，可以将选项传给配置。\n配置文件可以导出一个函数，这个函数返回配置。这个函数会被 CLI（命令行界面）调用，而通过 --env 参数传过来的值会被传递给这个配置函数。\n\n```\non the terminal : --env dev //string\n\non the terminal : --env.minimize true --env.server localhost //object\n\n//配置\n// webpack.config.babel.js\nexports default function(options) {\n\t//string  => dev\n\t//object  => {minimize: true, server: \"localhost\"}\n\treturn {\n\t\t// ...\n\t\tdevtool: options.dev ? \"cheap-module-eval-source-map\" : \"hidden-source-map\"\n\t};\n}\n```\n\n## 解析选项\n\n{\n\tmodules: [path.resolve(__dirname, \"app\"), \"node_modules\"]\n\t// （以前这个选项分散在 `root`、`modulesDirectories` 和 `fallback` 三处。）\n\t// 模块查找路径：指定解析器查找模块的目录。\n\t// 相对路径会在每一层父级目录中查找（类似 node_modules）。\n\t// 绝对路径会直接查找。\n\t// 将按你指定的顺序查找。\n\n\tdescriptionFiles: [\"package.json\", \"bower.json\"],\n\t// 描述文件：这些 JSON 文件将在目录中被读取。\n\n\tmainFields: [\"main\", \"browser\"],\n\t// 入口字段：在解析一个包目录时，描述文件中的这些字段所指定的文件将被视为包的入口文件。\n\n\tmainFiles: [\"index\"]\n\t// 入口文件：在解析一个目录时，这些文件将被视为目录的入口文件。\n\n\taliasFields: [\"browser\"],\n\t// 别名字段：描述文件中的这些字段提供了该包的别名对照关系。\n\t// 这些字段的内容是一个对象，每当请求某个键名时，就会映射到对应的键值。\n\n\textensions: [\".js\", \".json\"],\n\t// 扩展名\n\n\tmoduleExtensions: [\"-loader\"],\n\t//模块后缀名：在解析一个模块名时，将会尝试附加这些后缀名\n\n\tenforceModuleExtension: false,\n\t// If false it's also try to use no module extension from above\n\n\talias: {\n\t\tjquery: path.resolve(__dirname, \"vendor/jquery-2.0.0.js\")\n\t}\n\t// 请求重定向，在解析一个模块名时，会使用这个别名映射表\n\n## Minor breaking changes\n\n### Promise polyfill\n\n分块加载机制现在是依赖于 Promise 的。这表示你需要在旧版浏览器下提供一个 Promise 的 polyfill。\n\n### other polyfills\n- 你需要一个 Object.defineProperty 的 polyfill 来实现 ES6 的模块特性。或者在以（除了 module.exports、module.id、module.loaded 或 module.hot 之外的）其它方式使用 module 对象时，这个 polyfill 也是需要的。\n- 为了实现 ES6 的模块特性，你还需要一个 Function.prototype.bind 的 polyfill\n- 你需要一个 Object.keys 的 polyfill 来运行 require.context().keys()\n\n## Loaders configuration\n```\nloaders: [\n\t{\n\t\ttest: /\\.css$/,\n\t\tloaders: [\n\t\t\t\"style-loader\",\n\t\t\t{ loader: \"css-loader\", query: { modules: true } },\n\t\t\t{\n\t\t\t\tloader: \"sass-loader\",\n\t\t\t\tquery: {\n\t\t\t\t\tincludePaths: [\n\t\t\t\t\t\tpath.resolve(__dirname, \"some-folder\")\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n]\n```\n\n### Loader 选项以及代码压缩\nUglifyJsPlugin 将不再把所有 loader 都切到代码压缩模式。debug 选项已经被移除。Loader 不应该再从 Webpack 的配置那里读取自己选项了。取而代之的是，你需要通过 LoaderOptionsPlugin 来提供这些选项。\n```\nnew webpack.LoaderOptionsPlugin({\n\ttest: /\\.css$/, // optionally pass test, include and exclude, default affects all loaders\n\t                // 可以传入 test、include 和 exclude，默认会影响所有的 loader\n\tminimize: true,\n\tdebug: false,\n\toptions: {\n\t\t// pass stuff to the loader\n\t\t// 这里的选项会传给 loader\n\t}\n})\n```\n\n## Plugins\n\n现在许多插件将可以接受一个选项对象，而不是以前多个参数的形式,\n\n```\n/*\n配置webpack插件\nplugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,\n而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.\n简而言之： loader关注文件名，plugin关注事件\n*/\n module: {\n    /*\n    配置各种类型文件的加载器, 称之为loader\n    webpack当遇到import ... 时, 会调用这里配置的loader对引用的文件进行编译\n    */\n    rules: [\n      {\n        /*\n        使用babel编译ES6/ES7/ES8为ES5代码\n        使用正则表达式匹配后缀名为.js的文件\n        */\n        test: /\\.js$/,\n\n        // 排除node_modules目录下的文件, npm安装的包不需要编译\n        exclude: /node_modules/,\n\n        /*\n        use指定该文件的loader, 值可以是字符串或者数组.\n        这里先使用eslint-loader处理, 返回的结果交给babel-loader处理. loader的处理顺序是从最后一个到第一个.\n        eslint-loader用来检查代码, 如果有错误, 编译的时候会报错.\n        babel-loader用来编译js文件.\n        */\n        use: ['babel-loader', 'eslint-loader']\n      },\n\n      {\n        // 匹配.html文件\n        test: /\\.html$/,\n        /*\n        使用html-loader, 将html内容存为js字符串, 比如当遇到\n        import htmlString from './template.html'\n        template.html的文件内容会被转成一个js字符串, 合并到js文件里.\n        */\n        use: 'html-loader'\n      },\n\n      {\n        // 匹配.css文件\n        test: /\\.css$/,\n\n        /*\n        先使用css-loader处理, 返回的结果交给style-loader处理.\n        css-loader将css内容存为js字符串, 并且会把background, @font-face等引用的图片,\n        字体文件交给指定的loader打包, 类似上面的html-loader, 用什么loader同样在loaders对象中定义, 等会下面就会看到.\n        */\n        use: ['style-loader', 'css-loader']\n      },\n\n      {\n        /*\n        匹配各种格式的图片和字体文件\n        上面html-loader会把html中<img>标签的图片解析出来, 文件名匹配到这里的test的正则表达式,\n        css-loader引用的图片和字体同样会匹配到这里的test条件\n        */\n        test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/,\n\n        /*\n        使用url-loader, 它接受一个limit参数, 单位为字节(byte)\n\n        当文件体积小于limit时, url-loader把文件转为Data URI的格式内联到引用的地方\n        当文件大于limit时, url-loader会调用file-loader, 把文件储存到输出目录, 并把引用的文件路径改写成输出后的路径\n\n        比如 views/foo/index.html中\n        <img src=\"smallpic.png\">\n        会被编译成\n        <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...\">\n\n        而\n        <img src=\"largepic.png\">\n        会被编译成\n        <img src=\"/f78661bef717cf2cc2c2e5158f196384.png\">\n        */\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000\n            }\n          }\n        ]\n      }\n    ]\n  },\n\n  /*\n  配置webpack插件\n  plugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,\n  而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.\n  */\n  plugins: [\n    /*\n    html-webpack-plugin用来打包入口html文件\n    entry配置的入口是js文件, webpack以js文件为入口, 遇到import, 用配置的loader加载引入文件\n    但作为浏览器打开的入口html, 是引用入口js的文件, 它在整个编译过程的外面,\n    所以, 我们需要html-webpack-plugin来打包作为入口的html文件\n    */\n    new HtmlWebpackPlugin({\n      /*\n      template参数指定入口html文件路径, 插件会把这个文件交给webpack去编译,\n      webpack按照正常流程, 找到loaders中test条件匹配的loader来编译, 那么这里html-loader就是匹配的loader\n      html-loader编译后产生的字符串, 会由html-webpack-plugin储存为html文件到输出目录, 默认文件名为index.html\n      可以通过filename参数指定输出的文件名\n      html-webpack-plugin也可以不指定template参数, 它会使用默认的html模板.\n      */\n      template: './src/index.html'\n    }),\n    new webpack.ProvidePlugin({$: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery'}),\n  ],\n\n```\n\n[参考](https://github.com/dwqs/blog/issues/46)\n[参考](https://github.com/cssmagic/blog/issues/58)\n","source":"_posts/utils/webpack2.md","raw":"---\ntitle: webpack2\ntype: \"categories\"\ncategories: 工具\n---\n\n\n## 为什么要有webpack\n- 依赖加载混乱\n- 引用重复的代码\n- 等等\n本来他是个打包工具，但是现在它俨然成了一个管理工具\n\n## webpack2如何运行\n- 从context 文件夹\n- 查找entry对应文件\n- 找到文件夹，执行该文件的所有的依赖\n- 输出到对应的目录\n```\nconst path = require('path');\nconst webpack = require('webpack');\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    app: './app.js',\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].bundle.js',\n    libraryTarget: 'umd' //以什么样的模式导出代码\n  },\n};\n```\n## 命令行输入 webpack 命令,发生了什么\n- 首先npm会把包的可执行文件安装到./node_modules/.bin/目录下, 所以我们要在这个目录下执行命令.\n- 执行 bin 目录下的 webpack.js 脚本，解析命令行参数以及开始执行编译。\n- 调用 lib 目录下的 webpack.js 文件的核心函数 webpack ，实例化一个 Compiler，继承 Tapable 插件框架，实现注册和调用一系列插件。\n- 调用 lib 目录下的 /WebpackOptionsApply.js 模块的 process 方法，使用各种各样的插件来逐一编译 webpack 编译对象的各项。\n- 在3中调用的各种插件编译并输出新文件。\n\n## 打包方式\n- webpack -p //生产打包\n- webpack -d --hot//开发打包\n-d参数是开发环境(Development)的意思, 它会在我们的配置文件中插入调试相关的选项, 比如打开debug, 打开sourceMap, 代码中插入源文件路径注释.\n--hot开启热更新功能, 参数会帮我们往配置里添加HotModuleReplacementPlugin插件, 虽然可以在配置里自己写, 但有点麻烦, 用命令行参数方便很多.\n\n运行命令之后, Webpack 会输出一个 dist/app.bundle.js 文件, 同时在控制台输出当前日期. 需要注意的是, Webpack 会自动找到 moment 的指向(即使你有一个 moment.js 存在于目录中, 但 Webpack 默认会优先去寻找 moment 的Node模块).\n\n\n## 多文件\n- 多个入口文件打包出一个出口文件\n```\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    app: ['./home.js', './events.js', './vendor.js'],\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].bundle.js',\n  },\n};\n\n```\n\n- 多个入口文件打包出多个出口文件\n\n```\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    home: './home.js',\n    events: './events.js',\n    contact: './contact.js',\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].bundle.js',\n  },\n};\n```\n\n## 自动打包\n\n如果你将应用分开打包到多个 output 文件里(如果你的应用有非常多的 JavaScript 文件不需要在前期加载, 这样做是非常有效的), 有可能会出现很多冗余的代码, 因为 Webpack 是独立解析每个文件的依赖的. 幸运的是, Webpack 已经内置了 CommonsChunk 插件来处理这个问题:\n\n```\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'commons',\n      filename: 'commons.js',\n      minChunks: 2,\n    }),\n```\n\n加上 CommonsChunk 插件后, 任何一个模块在你的 output 文件中被加载 2 次(该值由 minChunks 设置)及以上, 该模块就会被打包在 common.js 中, 你可以在客户端缓存这些模块. 虽然这会增加额外的请求, 但这能防止客户端多次下载同一个模块.\n\n## 开发环境\n为启动服务器, 仅需要在 webpack.config.js 中添加一个 devServer 对象:\n```\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  entry: {\n    app: './app.js',\n  },\n  output: {\n    filename: '[name].bundle.js',\n    path: path.resolve(__dirname, './dist/assets'),\n    publicPath: '/assets',                          // New\n  },\n  devServer: {\n    contentBase: path.resolve(__dirname, './src'),  // New\n    //historyApiFallback用来配置页面的重定向\n    //配置为true, 当访问的文件不存在时, 返回根目录下的index.html文件\n    historyApiFallback: true\n  },\n};\n```\n在 src 目录下创建一个带如下标签的 index.html 文件:\n\n```\n<script src=\"/assets/app.bundle.js\"></script>\n```\n在终端运行如下命令:\n```\n\twebpack-dev-server\n```\n## 全局方法调用\n需要使用在全局作用域下的函数? 只需在 output.library 进行简单的设置就行:\n```\nmodule.exports = {\n output: {\n   library: 'myClassName',\n }\n};\n```\n它会把你的打包文件捆绑在 window.myClassName 实例上. 设置了作用域之后, 你可以在文件的入口处进行调用\n\n## 总结1\n到目前为止, 我只介绍了怎么使用 Webpack 处理 JavaScript 文件. 从处理 JavaScript 文件开始是非常重要的, 因为这是 Webpack 唯一能识别的语言. 实际上, Webpack 可以使用 Loaders 来处理各种通过 JavaScript 传递的任何类型的文件。\n\n## Loaders\nloader 可以是像 Sass 这样的预处理器, 也可以是像 Babel 这样的编译器. 在 NPM 里, 它们通常被命名为 *-loader, 例如: sass-loader 或者 babel-loader.\n- 先安装包 yarn install\n- 通过正则匹配文件路径，然后进行编译加载处理\n### Babel+ES6\n### CSS+Style Loader\n```\nmodule.exports = {\n  // …\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      // …\n    ],\n  },\n};\n```\nLoaders会按照数组的逆序运行, 也就是说, 会先运行 css-loader, 后运行 style-loader.\n\n你可能会注意到, 在生产环境下, CSS 会被打包到 JavaScript 文件里, style-loader 则会把样式写在 style 标签中. 此外, Webpack 通过将这些文件打包成一个文件来自动地解析所有的 @import 查询(而不是依赖 CSS 的默认 import 功能, 这会导致额外的 header 请求, 并且加载资源非常慢).\n\n从 JavaScript 中加载 CSS 是非常神奇的, 因为这样你可以用新的方式将 CSS 模块化. 也就是说, 可以仅通过 button.js 来加载 button.css, 这意味着如果 button.js 没有用到, 其对应的 CSS 也不会被构建到生产环境中.\n\n### CSS+Node 模块\n我们可以使用 Webpack 里的 ~ 前缀来引入 Node 模块\n```\n@import \"~normalize.css\";\n```\n这样就可以充分利用 NPM 管理第三方样式库的优点---版本更新和避免复制和粘贴. 更近一步, 和 CSS 默认的 import 功能相比, 用 Webpack 打包 CSS 有明显的优势, 因为它可以为客户端减少头部请求以及缓慢的加载时间.\n\n### 将 CSS 分开打包\n\n你可能需要处理渐进增强的情况, 也可能因某些原因需要分离 CSS 文件. 这个也很简单, 只需将配置文件中的 style-loader 用 extract-text-webpack-plugin 代替就行.\n```\nconst ExtractTextPlugin = require('extract-text-webpack-plugin');\nmodule.exports = {\n  // …\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        loader:  ExtractTextPlugin.extract({\n          loader: 'css-loader?importLoaders=1',\n        }),\n      },\n    \n      // …\n    ],\n    noParse: /node_modules\\/(jquey|moment|chart\\.js)/   //这些库没有必要去解析他们的依赖\n  },\n  plugins: [\n    new ExtractTextPlugin({\n      filename: '[name].bundle.css',\n      allChunks: true,\n    }),\n  ],\n};\n```\n运行 webpack -p 之后, 你会发现在 output 指定的目录中会有一个 app.bundle.css 文件. 最后, 在 HTML 文件中通过 <link> 标签正常引用.\n\n## 实现ES6的模块加载\n可以用import,export，不需要把他们转成CommonJS模块的格式\n\n### 代码分割\n\n- ES6 Loader 规范定义了 System.import 方法，用于在运行时动态加载 ES6 模块。\n- Webpack 把 System.import 作为拆分点，然后把被请求的模块放入一个单独的 “块”（chunk）中。\n- System.import 接受模块名作为参数，然后返回一个 Promise。\n- chunk 加载失败产生的错误现在可以被捕获了。\n```\n\tSystem.import(\"./module\").then(module => {\n\t\tmodule.default;\n\t}).catch(err => {\n\t\tconsole.log(\"Chunk loading failed\");\n\t});\n```\n开发服务器会运行在 localhost:8080(打开你的浏览器访问该地址就能看到你的页面). 需要注意的是 script 标签里的 /assets 是和 output.publicPath 匹配的--你可以把它命名成任何你想要的名字(如果你使用CDN, 这会很有用).\nWebpack 提供了热加载功能. 当你修改了 JavaScript 文件后, Webpack 会自动重新加载资源, 而不需要你手动去刷新浏览器. 但是, 任何对 webpack.config.js 文件的改变都需要重启服务器才会生效.\n\n**动态表达式**\n还可以把一个表达式作为参数传给 System.import。表达式的处理方式类似于 CommonJS（Webpack 为每个可能的文件创建一个独立的上下文）。\nSystem.import 会令每个可能的模块都产生一个独立的 chunk。所以就可以用循环产生多个 chunk，感觉简写了有木有\n\n```\nfunction route(path, query) {\n\treturn System.import(\"./routes/\" + path + \"/route\")\n\t\t.then(route => new route.Route(query));\n}\n// 这会为每种可能的路径组合都创建一个对应的 chunk。\n```\n\n### Babel 与 Webpack\n\n在默认情况下，Babel 的 es2015 预设方案（preset）会把 ES6 模块转换为 CommonJS 格式。如果你想让 Webpack 来处理 ES6 模块，那你应该换用 es2015-webpack 这个预设方案。\n\n## 配置\n在过去的环境中，变量通常用来在配置文件中处理不同的环境。Webpack 2 引入了一种新方法，可以将选项传给配置。\n配置文件可以导出一个函数，这个函数返回配置。这个函数会被 CLI（命令行界面）调用，而通过 --env 参数传过来的值会被传递给这个配置函数。\n\n```\non the terminal : --env dev //string\n\non the terminal : --env.minimize true --env.server localhost //object\n\n//配置\n// webpack.config.babel.js\nexports default function(options) {\n\t//string  => dev\n\t//object  => {minimize: true, server: \"localhost\"}\n\treturn {\n\t\t// ...\n\t\tdevtool: options.dev ? \"cheap-module-eval-source-map\" : \"hidden-source-map\"\n\t};\n}\n```\n\n## 解析选项\n\n{\n\tmodules: [path.resolve(__dirname, \"app\"), \"node_modules\"]\n\t// （以前这个选项分散在 `root`、`modulesDirectories` 和 `fallback` 三处。）\n\t// 模块查找路径：指定解析器查找模块的目录。\n\t// 相对路径会在每一层父级目录中查找（类似 node_modules）。\n\t// 绝对路径会直接查找。\n\t// 将按你指定的顺序查找。\n\n\tdescriptionFiles: [\"package.json\", \"bower.json\"],\n\t// 描述文件：这些 JSON 文件将在目录中被读取。\n\n\tmainFields: [\"main\", \"browser\"],\n\t// 入口字段：在解析一个包目录时，描述文件中的这些字段所指定的文件将被视为包的入口文件。\n\n\tmainFiles: [\"index\"]\n\t// 入口文件：在解析一个目录时，这些文件将被视为目录的入口文件。\n\n\taliasFields: [\"browser\"],\n\t// 别名字段：描述文件中的这些字段提供了该包的别名对照关系。\n\t// 这些字段的内容是一个对象，每当请求某个键名时，就会映射到对应的键值。\n\n\textensions: [\".js\", \".json\"],\n\t// 扩展名\n\n\tmoduleExtensions: [\"-loader\"],\n\t//模块后缀名：在解析一个模块名时，将会尝试附加这些后缀名\n\n\tenforceModuleExtension: false,\n\t// If false it's also try to use no module extension from above\n\n\talias: {\n\t\tjquery: path.resolve(__dirname, \"vendor/jquery-2.0.0.js\")\n\t}\n\t// 请求重定向，在解析一个模块名时，会使用这个别名映射表\n\n## Minor breaking changes\n\n### Promise polyfill\n\n分块加载机制现在是依赖于 Promise 的。这表示你需要在旧版浏览器下提供一个 Promise 的 polyfill。\n\n### other polyfills\n- 你需要一个 Object.defineProperty 的 polyfill 来实现 ES6 的模块特性。或者在以（除了 module.exports、module.id、module.loaded 或 module.hot 之外的）其它方式使用 module 对象时，这个 polyfill 也是需要的。\n- 为了实现 ES6 的模块特性，你还需要一个 Function.prototype.bind 的 polyfill\n- 你需要一个 Object.keys 的 polyfill 来运行 require.context().keys()\n\n## Loaders configuration\n```\nloaders: [\n\t{\n\t\ttest: /\\.css$/,\n\t\tloaders: [\n\t\t\t\"style-loader\",\n\t\t\t{ loader: \"css-loader\", query: { modules: true } },\n\t\t\t{\n\t\t\t\tloader: \"sass-loader\",\n\t\t\t\tquery: {\n\t\t\t\t\tincludePaths: [\n\t\t\t\t\t\tpath.resolve(__dirname, \"some-folder\")\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t}\n]\n```\n\n### Loader 选项以及代码压缩\nUglifyJsPlugin 将不再把所有 loader 都切到代码压缩模式。debug 选项已经被移除。Loader 不应该再从 Webpack 的配置那里读取自己选项了。取而代之的是，你需要通过 LoaderOptionsPlugin 来提供这些选项。\n```\nnew webpack.LoaderOptionsPlugin({\n\ttest: /\\.css$/, // optionally pass test, include and exclude, default affects all loaders\n\t                // 可以传入 test、include 和 exclude，默认会影响所有的 loader\n\tminimize: true,\n\tdebug: false,\n\toptions: {\n\t\t// pass stuff to the loader\n\t\t// 这里的选项会传给 loader\n\t}\n})\n```\n\n## Plugins\n\n现在许多插件将可以接受一个选项对象，而不是以前多个参数的形式,\n\n```\n/*\n配置webpack插件\nplugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,\n而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.\n简而言之： loader关注文件名，plugin关注事件\n*/\n module: {\n    /*\n    配置各种类型文件的加载器, 称之为loader\n    webpack当遇到import ... 时, 会调用这里配置的loader对引用的文件进行编译\n    */\n    rules: [\n      {\n        /*\n        使用babel编译ES6/ES7/ES8为ES5代码\n        使用正则表达式匹配后缀名为.js的文件\n        */\n        test: /\\.js$/,\n\n        // 排除node_modules目录下的文件, npm安装的包不需要编译\n        exclude: /node_modules/,\n\n        /*\n        use指定该文件的loader, 值可以是字符串或者数组.\n        这里先使用eslint-loader处理, 返回的结果交给babel-loader处理. loader的处理顺序是从最后一个到第一个.\n        eslint-loader用来检查代码, 如果有错误, 编译的时候会报错.\n        babel-loader用来编译js文件.\n        */\n        use: ['babel-loader', 'eslint-loader']\n      },\n\n      {\n        // 匹配.html文件\n        test: /\\.html$/,\n        /*\n        使用html-loader, 将html内容存为js字符串, 比如当遇到\n        import htmlString from './template.html'\n        template.html的文件内容会被转成一个js字符串, 合并到js文件里.\n        */\n        use: 'html-loader'\n      },\n\n      {\n        // 匹配.css文件\n        test: /\\.css$/,\n\n        /*\n        先使用css-loader处理, 返回的结果交给style-loader处理.\n        css-loader将css内容存为js字符串, 并且会把background, @font-face等引用的图片,\n        字体文件交给指定的loader打包, 类似上面的html-loader, 用什么loader同样在loaders对象中定义, 等会下面就会看到.\n        */\n        use: ['style-loader', 'css-loader']\n      },\n\n      {\n        /*\n        匹配各种格式的图片和字体文件\n        上面html-loader会把html中<img>标签的图片解析出来, 文件名匹配到这里的test的正则表达式,\n        css-loader引用的图片和字体同样会匹配到这里的test条件\n        */\n        test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/,\n\n        /*\n        使用url-loader, 它接受一个limit参数, 单位为字节(byte)\n\n        当文件体积小于limit时, url-loader把文件转为Data URI的格式内联到引用的地方\n        当文件大于limit时, url-loader会调用file-loader, 把文件储存到输出目录, 并把引用的文件路径改写成输出后的路径\n\n        比如 views/foo/index.html中\n        <img src=\"smallpic.png\">\n        会被编译成\n        <img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...\">\n\n        而\n        <img src=\"largepic.png\">\n        会被编译成\n        <img src=\"/f78661bef717cf2cc2c2e5158f196384.png\">\n        */\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              limit: 10000\n            }\n          }\n        ]\n      }\n    ]\n  },\n\n  /*\n  配置webpack插件\n  plugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,\n  而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.\n  */\n  plugins: [\n    /*\n    html-webpack-plugin用来打包入口html文件\n    entry配置的入口是js文件, webpack以js文件为入口, 遇到import, 用配置的loader加载引入文件\n    但作为浏览器打开的入口html, 是引用入口js的文件, 它在整个编译过程的外面,\n    所以, 我们需要html-webpack-plugin来打包作为入口的html文件\n    */\n    new HtmlWebpackPlugin({\n      /*\n      template参数指定入口html文件路径, 插件会把这个文件交给webpack去编译,\n      webpack按照正常流程, 找到loaders中test条件匹配的loader来编译, 那么这里html-loader就是匹配的loader\n      html-loader编译后产生的字符串, 会由html-webpack-plugin储存为html文件到输出目录, 默认文件名为index.html\n      可以通过filename参数指定输出的文件名\n      html-webpack-plugin也可以不指定template参数, 它会使用默认的html模板.\n      */\n      template: './src/index.html'\n    }),\n    new webpack.ProvidePlugin({$: 'jquery', jQuery: 'jquery', 'window.jQuery': 'jquery'}),\n  ],\n\n```\n\n[参考](https://github.com/dwqs/blog/issues/46)\n[参考](https://github.com/cssmagic/blog/issues/58)\n","slug":"utils-webpack2","published":1,"date":"2017-03-16T05:25:26.000Z","updated":"2017-03-16T05:25:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cdp001ykzy6po6puodw","content":"<h2 id=\"为什么要有webpack\"><a href=\"#为什么要有webpack\" class=\"headerlink\" title=\"为什么要有webpack\"></a>为什么要有webpack</h2><ul>\n<li>依赖加载混乱</li>\n<li>引用重复的代码</li>\n<li>等等<br>本来他是个打包工具，但是现在它俨然成了一个管理工具</li>\n</ul>\n<h2 id=\"webpack2如何运行\"><a href=\"#webpack2如何运行\" class=\"headerlink\" title=\"webpack2如何运行\"></a>webpack2如何运行</h2><ul>\n<li>从context 文件夹</li>\n<li>查找entry对应文件</li>\n<li>找到文件夹，执行该文件的所有的依赖</li>\n<li>输出到对应的目录<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">const path = require(&apos;path&apos;);</div><div class=\"line\">const webpack = require(&apos;webpack&apos;);</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    app: &apos;./app.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">    libraryTarget: &apos;umd&apos; //以什么样的模式导出代码</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"命令行输入-webpack-命令-发生了什么\"><a href=\"#命令行输入-webpack-命令-发生了什么\" class=\"headerlink\" title=\"命令行输入 webpack 命令,发生了什么\"></a>命令行输入 webpack 命令,发生了什么</h2><ul>\n<li>首先npm会把包的可执行文件安装到./node_modules/.bin/目录下, 所以我们要在这个目录下执行命令.</li>\n<li>执行 bin 目录下的 webpack.js 脚本，解析命令行参数以及开始执行编译。</li>\n<li>调用 lib 目录下的 webpack.js 文件的核心函数 webpack ，实例化一个 Compiler，继承 Tapable 插件框架，实现注册和调用一系列插件。</li>\n<li>调用 lib 目录下的 /WebpackOptionsApply.js 模块的 process 方法，使用各种各样的插件来逐一编译 webpack 编译对象的各项。</li>\n<li>在3中调用的各种插件编译并输出新文件。</li>\n</ul>\n<h2 id=\"打包方式\"><a href=\"#打包方式\" class=\"headerlink\" title=\"打包方式\"></a>打包方式</h2><ul>\n<li>webpack -p //生产打包</li>\n<li>webpack -d –hot//开发打包<br>-d参数是开发环境(Development)的意思, 它会在我们的配置文件中插入调试相关的选项, 比如打开debug, 打开sourceMap, 代码中插入源文件路径注释.<br>–hot开启热更新功能, 参数会帮我们往配置里添加HotModuleReplacementPlugin插件, 虽然可以在配置里自己写, 但有点麻烦, 用命令行参数方便很多.</li>\n</ul>\n<p>运行命令之后, Webpack 会输出一个 dist/app.bundle.js 文件, 同时在控制台输出当前日期. 需要注意的是, Webpack 会自动找到 moment 的指向(即使你有一个 moment.js 存在于目录中, 但 Webpack 默认会优先去寻找 moment 的Node模块).</p>\n<h2 id=\"多文件\"><a href=\"#多文件\" class=\"headerlink\" title=\"多文件\"></a>多文件</h2><ul>\n<li><p>多个入口文件打包出一个出口文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    app: [&apos;./home.js&apos;, &apos;./events.js&apos;, &apos;./vendor.js&apos;],</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>多个入口文件打包出多个出口文件</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    home: &apos;./home.js&apos;,</div><div class=\"line\">    events: &apos;./events.js&apos;,</div><div class=\"line\">    contact: &apos;./contact.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"自动打包\"><a href=\"#自动打包\" class=\"headerlink\" title=\"自动打包\"></a>自动打包</h2><p>如果你将应用分开打包到多个 output 文件里(如果你的应用有非常多的 JavaScript 文件不需要在前期加载, 这样做是非常有效的), 有可能会出现很多冗余的代码, 因为 Webpack 是独立解析每个文件的依赖的. 幸运的是, Webpack 已经内置了 CommonsChunk 插件来处理这个问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">  name: &apos;commons&apos;,</div><div class=\"line\">  filename: &apos;commons.js&apos;,</div><div class=\"line\">  minChunks: 2,</div><div class=\"line\">&#125;),</div></pre></td></tr></table></figure>\n<p>加上 CommonsChunk 插件后, 任何一个模块在你的 output 文件中被加载 2 次(该值由 minChunks 设置)及以上, 该模块就会被打包在 common.js 中, 你可以在客户端缓存这些模块. 虽然这会增加额外的请求, 但这能防止客户端多次下载同一个模块.</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><p>为启动服务器, 仅需要在 webpack.config.js 中添加一个 devServer 对象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    app: &apos;./app.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist/assets&apos;),</div><div class=\"line\">    publicPath: &apos;/assets&apos;,                          // New</div><div class=\"line\">  &#125;,</div><div class=\"line\">  devServer: &#123;</div><div class=\"line\">    contentBase: path.resolve(__dirname, &apos;./src&apos;),  // New</div><div class=\"line\">    //historyApiFallback用来配置页面的重定向</div><div class=\"line\">    //配置为true, 当访问的文件不存在时, 返回根目录下的index.html文件</div><div class=\"line\">    historyApiFallback: true</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在 src 目录下创建一个带如下标签的 index.html 文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;/assets/app.bundle.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>在终端运行如下命令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">webpack-dev-server</div></pre></td></tr></table></figure></p>\n<h2 id=\"全局方法调用\"><a href=\"#全局方法调用\" class=\"headerlink\" title=\"全局方法调用\"></a>全局方法调用</h2><p>需要使用在全局作用域下的函数? 只需在 output.library 进行简单的设置就行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\"> output: &#123;</div><div class=\"line\">   library: &apos;myClassName&apos;,</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>它会把你的打包文件捆绑在 window.myClassName 实例上. 设置了作用域之后, 你可以在文件的入口处进行调用</p>\n<h2 id=\"总结1\"><a href=\"#总结1\" class=\"headerlink\" title=\"总结1\"></a>总结1</h2><p>到目前为止, 我只介绍了怎么使用 Webpack 处理 JavaScript 文件. 从处理 JavaScript 文件开始是非常重要的, 因为这是 Webpack 唯一能识别的语言. 实际上, Webpack 可以使用 Loaders 来处理各种通过 JavaScript 传递的任何类型的文件。</p>\n<h2 id=\"Loaders\"><a href=\"#Loaders\" class=\"headerlink\" title=\"Loaders\"></a>Loaders</h2><p>loader 可以是像 Sass 这样的预处理器, 也可以是像 Babel 这样的编译器. 在 NPM 里, 它们通常被命名为 *-loader, 例如: sass-loader 或者 babel-loader.</p>\n<ul>\n<li>先安装包 yarn install</li>\n<li>通过正则匹配文件路径，然后进行编译加载处理<h3 id=\"Babel-ES6\"><a href=\"#Babel-ES6\" class=\"headerlink\" title=\"Babel+ES6\"></a>Babel+ES6</h3><h3 id=\"CSS-Style-Loader\"><a href=\"#CSS-Style-Loader\" class=\"headerlink\" title=\"CSS+Style Loader\"></a>CSS+Style Loader</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  // …</div><div class=\"line\">  module: &#123;</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;],</div><div class=\"line\">      &#125;,</div><div class=\"line\">      // …</div><div class=\"line\">    ],</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Loaders会按照数组的逆序运行, 也就是说, 会先运行 css-loader, 后运行 style-loader.</p>\n<p>你可能会注意到, 在生产环境下, CSS 会被打包到 JavaScript 文件里, style-loader 则会把样式写在 style 标签中. 此外, Webpack 通过将这些文件打包成一个文件来自动地解析所有的 @import 查询(而不是依赖 CSS 的默认 import 功能, 这会导致额外的 header 请求, 并且加载资源非常慢).</p>\n<p>从 JavaScript 中加载 CSS 是非常神奇的, 因为这样你可以用新的方式将 CSS 模块化. 也就是说, 可以仅通过 button.js 来加载 button.css, 这意味着如果 button.js 没有用到, 其对应的 CSS 也不会被构建到生产环境中.</p>\n<h3 id=\"CSS-Node-模块\"><a href=\"#CSS-Node-模块\" class=\"headerlink\" title=\"CSS+Node 模块\"></a>CSS+Node 模块</h3><p>我们可以使用 Webpack 里的 ~ 前缀来引入 Node 模块<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@import &quot;~normalize.css&quot;;</div></pre></td></tr></table></figure></p>\n<p>这样就可以充分利用 NPM 管理第三方样式库的优点—版本更新和避免复制和粘贴. 更近一步, 和 CSS 默认的 import 功能相比, 用 Webpack 打包 CSS 有明显的优势, 因为它可以为客户端减少头部请求以及缓慢的加载时间.</p>\n<h3 id=\"将-CSS-分开打包\"><a href=\"#将-CSS-分开打包\" class=\"headerlink\" title=\"将 CSS 分开打包\"></a>将 CSS 分开打包</h3><p>你可能需要处理渐进增强的情况, 也可能因某些原因需要分离 CSS 文件. 这个也很简单, 只需将配置文件中的 style-loader 用 extract-text-webpack-plugin 代替就行.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  // …</div><div class=\"line\">  module: &#123;</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        loader:  ExtractTextPlugin.extract(&#123;</div><div class=\"line\">          loader: &apos;css-loader?importLoaders=1&apos;,</div><div class=\"line\">        &#125;),</div><div class=\"line\">      &#125;,</div><div class=\"line\">    </div><div class=\"line\">      // …</div><div class=\"line\">    ],</div><div class=\"line\">    noParse: /node_modules\\/(jquey|moment|chart\\.js)/   //这些库没有必要去解析他们的依赖</div><div class=\"line\">  &#125;,</div><div class=\"line\">  plugins: [</div><div class=\"line\">    new ExtractTextPlugin(&#123;</div><div class=\"line\">      filename: &apos;[name].bundle.css&apos;,</div><div class=\"line\">      allChunks: true,</div><div class=\"line\">    &#125;),</div><div class=\"line\">  ],</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>运行 webpack -p 之后, 你会发现在 output 指定的目录中会有一个 app.bundle.css 文件. 最后, 在 HTML 文件中通过 <link> 标签正常引用.</p>\n<h2 id=\"实现ES6的模块加载\"><a href=\"#实现ES6的模块加载\" class=\"headerlink\" title=\"实现ES6的模块加载\"></a>实现ES6的模块加载</h2><p>可以用import,export，不需要把他们转成CommonJS模块的格式</p>\n<h3 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h3><ul>\n<li>ES6 Loader 规范定义了 System.import 方法，用于在运行时动态加载 ES6 模块。</li>\n<li>Webpack 把 System.import 作为拆分点，然后把被请求的模块放入一个单独的 “块”（chunk）中。</li>\n<li>System.import 接受模块名作为参数，然后返回一个 Promise。</li>\n<li>chunk 加载失败产生的错误现在可以被捕获了。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.import(&quot;./module&quot;).then(module =&gt; &#123;</div><div class=\"line\">\tmodule.default;</div><div class=\"line\">&#125;).catch(err =&gt; &#123;</div><div class=\"line\">\tconsole.log(&quot;Chunk loading failed&quot;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>开发服务器会运行在 localhost:8080(打开你的浏览器访问该地址就能看到你的页面). 需要注意的是 script 标签里的 /assets 是和 output.publicPath 匹配的–你可以把它命名成任何你想要的名字(如果你使用CDN, 这会很有用).<br>Webpack 提供了热加载功能. 当你修改了 JavaScript 文件后, Webpack 会自动重新加载资源, 而不需要你手动去刷新浏览器. 但是, 任何对 webpack.config.js 文件的改变都需要重启服务器才会生效.</p>\n<p><strong>动态表达式</strong><br>还可以把一个表达式作为参数传给 System.import。表达式的处理方式类似于 CommonJS（Webpack 为每个可能的文件创建一个独立的上下文）。<br>System.import 会令每个可能的模块都产生一个独立的 chunk。所以就可以用循环产生多个 chunk，感觉简写了有木有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function route(path, query) &#123;</div><div class=\"line\">\treturn System.import(&quot;./routes/&quot; + path + &quot;/route&quot;)</div><div class=\"line\">\t\t.then(route =&gt; new route.Route(query));</div><div class=\"line\">&#125;</div><div class=\"line\">// 这会为每种可能的路径组合都创建一个对应的 chunk。</div></pre></td></tr></table></figure>\n<h3 id=\"Babel-与-Webpack\"><a href=\"#Babel-与-Webpack\" class=\"headerlink\" title=\"Babel 与 Webpack\"></a>Babel 与 Webpack</h3><p>在默认情况下，Babel 的 es2015 预设方案（preset）会把 ES6 模块转换为 CommonJS 格式。如果你想让 Webpack 来处理 ES6 模块，那你应该换用 es2015-webpack 这个预设方案。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>在过去的环境中，变量通常用来在配置文件中处理不同的环境。Webpack 2 引入了一种新方法，可以将选项传给配置。<br>配置文件可以导出一个函数，这个函数返回配置。这个函数会被 CLI（命令行界面）调用，而通过 –env 参数传过来的值会被传递给这个配置函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">on the terminal : --env dev //string</div><div class=\"line\"></div><div class=\"line\">on the terminal : --env.minimize true --env.server localhost //object</div><div class=\"line\"></div><div class=\"line\">//配置</div><div class=\"line\">// webpack.config.babel.js</div><div class=\"line\">exports default function(options) &#123;</div><div class=\"line\">\t//string  =&gt; dev</div><div class=\"line\">\t//object  =&gt; &#123;minimize: true, server: &quot;localhost&quot;&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\t// ...</div><div class=\"line\">\t\tdevtool: options.dev ? &quot;cheap-module-eval-source-map&quot; : &quot;hidden-source-map&quot;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"解析选项\"><a href=\"#解析选项\" class=\"headerlink\" title=\"解析选项\"></a>解析选项</h2><p>{<br>    modules: [path.resolve(__dirname, “app”), “node_modules”]<br>    // （以前这个选项分散在 <code>root</code>、<code>modulesDirectories</code> 和 <code>fallback</code> 三处。）<br>    // 模块查找路径：指定解析器查找模块的目录。<br>    // 相对路径会在每一层父级目录中查找（类似 node_modules）。<br>    // 绝对路径会直接查找。<br>    // 将按你指定的顺序查找。</p>\n<pre><code>descriptionFiles: [&quot;package.json&quot;, &quot;bower.json&quot;],\n// 描述文件：这些 JSON 文件将在目录中被读取。\n\nmainFields: [&quot;main&quot;, &quot;browser&quot;],\n// 入口字段：在解析一个包目录时，描述文件中的这些字段所指定的文件将被视为包的入口文件。\n\nmainFiles: [&quot;index&quot;]\n// 入口文件：在解析一个目录时，这些文件将被视为目录的入口文件。\n\naliasFields: [&quot;browser&quot;],\n// 别名字段：描述文件中的这些字段提供了该包的别名对照关系。\n// 这些字段的内容是一个对象，每当请求某个键名时，就会映射到对应的键值。\n\nextensions: [&quot;.js&quot;, &quot;.json&quot;],\n// 扩展名\n\nmoduleExtensions: [&quot;-loader&quot;],\n//模块后缀名：在解析一个模块名时，将会尝试附加这些后缀名\n\nenforceModuleExtension: false,\n// If false it&apos;s also try to use no module extension from above\n\nalias: {\n    jquery: path.resolve(__dirname, &quot;vendor/jquery-2.0.0.js&quot;)\n}\n// 请求重定向，在解析一个模块名时，会使用这个别名映射表\n</code></pre><h2 id=\"Minor-breaking-changes\"><a href=\"#Minor-breaking-changes\" class=\"headerlink\" title=\"Minor breaking changes\"></a>Minor breaking changes</h2><h3 id=\"Promise-polyfill\"><a href=\"#Promise-polyfill\" class=\"headerlink\" title=\"Promise polyfill\"></a>Promise polyfill</h3><p>分块加载机制现在是依赖于 Promise 的。这表示你需要在旧版浏览器下提供一个 Promise 的 polyfill。</p>\n<h3 id=\"other-polyfills\"><a href=\"#other-polyfills\" class=\"headerlink\" title=\"other polyfills\"></a>other polyfills</h3><ul>\n<li>你需要一个 Object.defineProperty 的 polyfill 来实现 ES6 的模块特性。或者在以（除了 module.exports、module.id、module.loaded 或 module.hot 之外的）其它方式使用 module 对象时，这个 polyfill 也是需要的。</li>\n<li>为了实现 ES6 的模块特性，你还需要一个 Function.prototype.bind 的 polyfill</li>\n<li>你需要一个 Object.keys 的 polyfill 来运行 require.context().keys()</li>\n</ul>\n<h2 id=\"Loaders-configuration\"><a href=\"#Loaders-configuration\" class=\"headerlink\" title=\"Loaders configuration\"></a>Loaders configuration</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders: [</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttest: /\\.css$/,</div><div class=\"line\">\t\tloaders: [</div><div class=\"line\">\t\t\t&quot;style-loader&quot;,</div><div class=\"line\">\t\t\t&#123; loader: &quot;css-loader&quot;, query: &#123; modules: true &#125; &#125;,</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tloader: &quot;sass-loader&quot;,</div><div class=\"line\">\t\t\t\tquery: &#123;</div><div class=\"line\">\t\t\t\t\tincludePaths: [</div><div class=\"line\">\t\t\t\t\t\tpath.resolve(__dirname, &quot;some-folder&quot;)</div><div class=\"line\">\t\t\t\t\t]</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t]</div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h3 id=\"Loader-选项以及代码压缩\"><a href=\"#Loader-选项以及代码压缩\" class=\"headerlink\" title=\"Loader 选项以及代码压缩\"></a>Loader 选项以及代码压缩</h3><p>UglifyJsPlugin 将不再把所有 loader 都切到代码压缩模式。debug 选项已经被移除。Loader 不应该再从 Webpack 的配置那里读取自己选项了。取而代之的是，你需要通过 LoaderOptionsPlugin 来提供这些选项。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">new webpack.LoaderOptionsPlugin(&#123;</div><div class=\"line\">\ttest: /\\.css$/, // optionally pass test, include and exclude, default affects all loaders</div><div class=\"line\">\t                // 可以传入 test、include 和 exclude，默认会影响所有的 loader</div><div class=\"line\">\tminimize: true,</div><div class=\"line\">\tdebug: false,</div><div class=\"line\">\toptions: &#123;</div><div class=\"line\">\t\t// pass stuff to the loader</div><div class=\"line\">\t\t// 这里的选项会传给 loader</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"Plugins\"><a href=\"#Plugins\" class=\"headerlink\" title=\"Plugins\"></a>Plugins</h2><p>现在许多插件将可以接受一个选项对象，而不是以前多个参数的形式,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">配置webpack插件</div><div class=\"line\">plugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,</div><div class=\"line\">而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.</div><div class=\"line\">简而言之： loader关注文件名，plugin关注事件</div><div class=\"line\">*/</div><div class=\"line\"> module: &#123;</div><div class=\"line\">    /*</div><div class=\"line\">    配置各种类型文件的加载器, 称之为loader</div><div class=\"line\">    webpack当遇到import ... 时, 会调用这里配置的loader对引用的文件进行编译</div><div class=\"line\">    */</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        /*</div><div class=\"line\">        使用babel编译ES6/ES7/ES8为ES5代码</div><div class=\"line\">        使用正则表达式匹配后缀名为.js的文件</div><div class=\"line\">        */</div><div class=\"line\">        test: /\\.js$/,</div><div class=\"line\"></div><div class=\"line\">        // 排除node_modules目录下的文件, npm安装的包不需要编译</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">        use指定该文件的loader, 值可以是字符串或者数组.</div><div class=\"line\">        这里先使用eslint-loader处理, 返回的结果交给babel-loader处理. loader的处理顺序是从最后一个到第一个.</div><div class=\"line\">        eslint-loader用来检查代码, 如果有错误, 编译的时候会报错.</div><div class=\"line\">        babel-loader用来编译js文件.</div><div class=\"line\">        */</div><div class=\"line\">        use: [&apos;babel-loader&apos;, &apos;eslint-loader&apos;]</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &#123;</div><div class=\"line\">        // 匹配.html文件</div><div class=\"line\">        test: /\\.html$/,</div><div class=\"line\">        /*</div><div class=\"line\">        使用html-loader, 将html内容存为js字符串, 比如当遇到</div><div class=\"line\">        import htmlString from &apos;./template.html&apos;</div><div class=\"line\">        template.html的文件内容会被转成一个js字符串, 合并到js文件里.</div><div class=\"line\">        */</div><div class=\"line\">        use: &apos;html-loader&apos;</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &#123;</div><div class=\"line\">        // 匹配.css文件</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">        先使用css-loader处理, 返回的结果交给style-loader处理.</div><div class=\"line\">        css-loader将css内容存为js字符串, 并且会把background, @font-face等引用的图片,</div><div class=\"line\">        字体文件交给指定的loader打包, 类似上面的html-loader, 用什么loader同样在loaders对象中定义, 等会下面就会看到.</div><div class=\"line\">        */</div><div class=\"line\">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &#123;</div><div class=\"line\">        /*</div><div class=\"line\">        匹配各种格式的图片和字体文件</div><div class=\"line\">        上面html-loader会把html中&lt;img&gt;标签的图片解析出来, 文件名匹配到这里的test的正则表达式,</div><div class=\"line\">        css-loader引用的图片和字体同样会匹配到这里的test条件</div><div class=\"line\">        */</div><div class=\"line\">        test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/,</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">        使用url-loader, 它接受一个limit参数, 单位为字节(byte)</div><div class=\"line\"></div><div class=\"line\">        当文件体积小于limit时, url-loader把文件转为Data URI的格式内联到引用的地方</div><div class=\"line\">        当文件大于limit时, url-loader会调用file-loader, 把文件储存到输出目录, 并把引用的文件路径改写成输出后的路径</div><div class=\"line\"></div><div class=\"line\">        比如 views/foo/index.html中</div><div class=\"line\">        &lt;img src=&quot;smallpic.png&quot;&gt;</div><div class=\"line\">        会被编译成</div><div class=\"line\">        &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">        而</div><div class=\"line\">        &lt;img src=&quot;largepic.png&quot;&gt;</div><div class=\"line\">        会被编译成</div><div class=\"line\">        &lt;img src=&quot;/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</div><div class=\"line\">        */</div><div class=\"line\">        use: [</div><div class=\"line\">          &#123;</div><div class=\"line\">            loader: &apos;url-loader&apos;,</div><div class=\"line\">            options: &#123;</div><div class=\"line\">              limit: 10000</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        ]</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  /*</div><div class=\"line\">  配置webpack插件</div><div class=\"line\">  plugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,</div><div class=\"line\">  而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.</div><div class=\"line\">  */</div><div class=\"line\">  plugins: [</div><div class=\"line\">    /*</div><div class=\"line\">    html-webpack-plugin用来打包入口html文件</div><div class=\"line\">    entry配置的入口是js文件, webpack以js文件为入口, 遇到import, 用配置的loader加载引入文件</div><div class=\"line\">    但作为浏览器打开的入口html, 是引用入口js的文件, 它在整个编译过程的外面,</div><div class=\"line\">    所以, 我们需要html-webpack-plugin来打包作为入口的html文件</div><div class=\"line\">    */</div><div class=\"line\">    new HtmlWebpackPlugin(&#123;</div><div class=\"line\">      /*</div><div class=\"line\">      template参数指定入口html文件路径, 插件会把这个文件交给webpack去编译,</div><div class=\"line\">      webpack按照正常流程, 找到loaders中test条件匹配的loader来编译, 那么这里html-loader就是匹配的loader</div><div class=\"line\">      html-loader编译后产生的字符串, 会由html-webpack-plugin储存为html文件到输出目录, 默认文件名为index.html</div><div class=\"line\">      可以通过filename参数指定输出的文件名</div><div class=\"line\">      html-webpack-plugin也可以不指定template参数, 它会使用默认的html模板.</div><div class=\"line\">      */</div><div class=\"line\">      template: &apos;./src/index.html&apos;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    new webpack.ProvidePlugin(&#123;$: &apos;jquery&apos;, jQuery: &apos;jquery&apos;, &apos;window.jQuery&apos;: &apos;jquery&apos;&#125;),</div><div class=\"line\">  ],</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/dwqs/blog/issues/46\" target=\"_blank\" rel=\"external\">参考</a><br><a href=\"https://github.com/cssmagic/blog/issues/58\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要有webpack\"><a href=\"#为什么要有webpack\" class=\"headerlink\" title=\"为什么要有webpack\"></a>为什么要有webpack</h2><ul>\n<li>依赖加载混乱</li>\n<li>引用重复的代码</li>\n<li>等等<br>本来他是个打包工具，但是现在它俨然成了一个管理工具</li>\n</ul>\n<h2 id=\"webpack2如何运行\"><a href=\"#webpack2如何运行\" class=\"headerlink\" title=\"webpack2如何运行\"></a>webpack2如何运行</h2><ul>\n<li>从context 文件夹</li>\n<li>查找entry对应文件</li>\n<li>找到文件夹，执行该文件的所有的依赖</li>\n<li>输出到对应的目录<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">const path = require(&apos;path&apos;);</div><div class=\"line\">const webpack = require(&apos;webpack&apos;);</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    app: &apos;./app.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">    libraryTarget: &apos;umd&apos; //以什么样的模式导出代码</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"命令行输入-webpack-命令-发生了什么\"><a href=\"#命令行输入-webpack-命令-发生了什么\" class=\"headerlink\" title=\"命令行输入 webpack 命令,发生了什么\"></a>命令行输入 webpack 命令,发生了什么</h2><ul>\n<li>首先npm会把包的可执行文件安装到./node_modules/.bin/目录下, 所以我们要在这个目录下执行命令.</li>\n<li>执行 bin 目录下的 webpack.js 脚本，解析命令行参数以及开始执行编译。</li>\n<li>调用 lib 目录下的 webpack.js 文件的核心函数 webpack ，实例化一个 Compiler，继承 Tapable 插件框架，实现注册和调用一系列插件。</li>\n<li>调用 lib 目录下的 /WebpackOptionsApply.js 模块的 process 方法，使用各种各样的插件来逐一编译 webpack 编译对象的各项。</li>\n<li>在3中调用的各种插件编译并输出新文件。</li>\n</ul>\n<h2 id=\"打包方式\"><a href=\"#打包方式\" class=\"headerlink\" title=\"打包方式\"></a>打包方式</h2><ul>\n<li>webpack -p //生产打包</li>\n<li>webpack -d –hot//开发打包<br>-d参数是开发环境(Development)的意思, 它会在我们的配置文件中插入调试相关的选项, 比如打开debug, 打开sourceMap, 代码中插入源文件路径注释.<br>–hot开启热更新功能, 参数会帮我们往配置里添加HotModuleReplacementPlugin插件, 虽然可以在配置里自己写, 但有点麻烦, 用命令行参数方便很多.</li>\n</ul>\n<p>运行命令之后, Webpack 会输出一个 dist/app.bundle.js 文件, 同时在控制台输出当前日期. 需要注意的是, Webpack 会自动找到 moment 的指向(即使你有一个 moment.js 存在于目录中, 但 Webpack 默认会优先去寻找 moment 的Node模块).</p>\n<h2 id=\"多文件\"><a href=\"#多文件\" class=\"headerlink\" title=\"多文件\"></a>多文件</h2><ul>\n<li><p>多个入口文件打包出一个出口文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    app: [&apos;./home.js&apos;, &apos;./events.js&apos;, &apos;./vendor.js&apos;],</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>多个入口文件打包出多个出口文件</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    home: &apos;./home.js&apos;,</div><div class=\"line\">    events: &apos;./events.js&apos;,</div><div class=\"line\">    contact: &apos;./contact.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"自动打包\"><a href=\"#自动打包\" class=\"headerlink\" title=\"自动打包\"></a>自动打包</h2><p>如果你将应用分开打包到多个 output 文件里(如果你的应用有非常多的 JavaScript 文件不需要在前期加载, 这样做是非常有效的), 有可能会出现很多冗余的代码, 因为 Webpack 是独立解析每个文件的依赖的. 幸运的是, Webpack 已经内置了 CommonsChunk 插件来处理这个问题:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">  name: &apos;commons&apos;,</div><div class=\"line\">  filename: &apos;commons.js&apos;,</div><div class=\"line\">  minChunks: 2,</div><div class=\"line\">&#125;),</div></pre></td></tr></table></figure>\n<p>加上 CommonsChunk 插件后, 任何一个模块在你的 output 文件中被加载 2 次(该值由 minChunks 设置)及以上, 该模块就会被打包在 common.js 中, 你可以在客户端缓存这些模块. 虽然这会增加额外的请求, 但这能防止客户端多次下载同一个模块.</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><p>为启动服务器, 仅需要在 webpack.config.js 中添加一个 devServer 对象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  context: path.resolve(__dirname, &apos;./src&apos;),</div><div class=\"line\">  entry: &#123;</div><div class=\"line\">    app: &apos;./app.js&apos;,</div><div class=\"line\">  &#125;,</div><div class=\"line\">  output: &#123;</div><div class=\"line\">    filename: &apos;[name].bundle.js&apos;,</div><div class=\"line\">    path: path.resolve(__dirname, &apos;./dist/assets&apos;),</div><div class=\"line\">    publicPath: &apos;/assets&apos;,                          // New</div><div class=\"line\">  &#125;,</div><div class=\"line\">  devServer: &#123;</div><div class=\"line\">    contentBase: path.resolve(__dirname, &apos;./src&apos;),  // New</div><div class=\"line\">    //historyApiFallback用来配置页面的重定向</div><div class=\"line\">    //配置为true, 当访问的文件不存在时, 返回根目录下的index.html文件</div><div class=\"line\">    historyApiFallback: true</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>在 src 目录下创建一个带如下标签的 index.html 文件:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script src=&quot;/assets/app.bundle.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>在终端运行如下命令:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">webpack-dev-server</div></pre></td></tr></table></figure></p>\n<h2 id=\"全局方法调用\"><a href=\"#全局方法调用\" class=\"headerlink\" title=\"全局方法调用\"></a>全局方法调用</h2><p>需要使用在全局作用域下的函数? 只需在 output.library 进行简单的设置就行:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\"> output: &#123;</div><div class=\"line\">   library: &apos;myClassName&apos;,</div><div class=\"line\"> &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>它会把你的打包文件捆绑在 window.myClassName 实例上. 设置了作用域之后, 你可以在文件的入口处进行调用</p>\n<h2 id=\"总结1\"><a href=\"#总结1\" class=\"headerlink\" title=\"总结1\"></a>总结1</h2><p>到目前为止, 我只介绍了怎么使用 Webpack 处理 JavaScript 文件. 从处理 JavaScript 文件开始是非常重要的, 因为这是 Webpack 唯一能识别的语言. 实际上, Webpack 可以使用 Loaders 来处理各种通过 JavaScript 传递的任何类型的文件。</p>\n<h2 id=\"Loaders\"><a href=\"#Loaders\" class=\"headerlink\" title=\"Loaders\"></a>Loaders</h2><p>loader 可以是像 Sass 这样的预处理器, 也可以是像 Babel 这样的编译器. 在 NPM 里, 它们通常被命名为 *-loader, 例如: sass-loader 或者 babel-loader.</p>\n<ul>\n<li>先安装包 yarn install</li>\n<li>通过正则匹配文件路径，然后进行编译加载处理<h3 id=\"Babel-ES6\"><a href=\"#Babel-ES6\" class=\"headerlink\" title=\"Babel+ES6\"></a>Babel+ES6</h3><h3 id=\"CSS-Style-Loader\"><a href=\"#CSS-Style-Loader\" class=\"headerlink\" title=\"CSS+Style Loader\"></a>CSS+Style Loader</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  // …</div><div class=\"line\">  module: &#123;</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;],</div><div class=\"line\">      &#125;,</div><div class=\"line\">      // …</div><div class=\"line\">    ],</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Loaders会按照数组的逆序运行, 也就是说, 会先运行 css-loader, 后运行 style-loader.</p>\n<p>你可能会注意到, 在生产环境下, CSS 会被打包到 JavaScript 文件里, style-loader 则会把样式写在 style 标签中. 此外, Webpack 通过将这些文件打包成一个文件来自动地解析所有的 @import 查询(而不是依赖 CSS 的默认 import 功能, 这会导致额外的 header 请求, 并且加载资源非常慢).</p>\n<p>从 JavaScript 中加载 CSS 是非常神奇的, 因为这样你可以用新的方式将 CSS 模块化. 也就是说, 可以仅通过 button.js 来加载 button.css, 这意味着如果 button.js 没有用到, 其对应的 CSS 也不会被构建到生产环境中.</p>\n<h3 id=\"CSS-Node-模块\"><a href=\"#CSS-Node-模块\" class=\"headerlink\" title=\"CSS+Node 模块\"></a>CSS+Node 模块</h3><p>我们可以使用 Webpack 里的 ~ 前缀来引入 Node 模块<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">@import &quot;~normalize.css&quot;;</div></pre></td></tr></table></figure></p>\n<p>这样就可以充分利用 NPM 管理第三方样式库的优点—版本更新和避免复制和粘贴. 更近一步, 和 CSS 默认的 import 功能相比, 用 Webpack 打包 CSS 有明显的优势, 因为它可以为客户端减少头部请求以及缓慢的加载时间.</p>\n<h3 id=\"将-CSS-分开打包\"><a href=\"#将-CSS-分开打包\" class=\"headerlink\" title=\"将 CSS 分开打包\"></a>将 CSS 分开打包</h3><p>你可能需要处理渐进增强的情况, 也可能因某些原因需要分离 CSS 文件. 这个也很简单, 只需将配置文件中的 style-loader 用 extract-text-webpack-plugin 代替就行.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</div><div class=\"line\">module.exports = &#123;</div><div class=\"line\">  // …</div><div class=\"line\">  module: &#123;</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\">        loader:  ExtractTextPlugin.extract(&#123;</div><div class=\"line\">          loader: &apos;css-loader?importLoaders=1&apos;,</div><div class=\"line\">        &#125;),</div><div class=\"line\">      &#125;,</div><div class=\"line\">    </div><div class=\"line\">      // …</div><div class=\"line\">    ],</div><div class=\"line\">    noParse: /node_modules\\/(jquey|moment|chart\\.js)/   //这些库没有必要去解析他们的依赖</div><div class=\"line\">  &#125;,</div><div class=\"line\">  plugins: [</div><div class=\"line\">    new ExtractTextPlugin(&#123;</div><div class=\"line\">      filename: &apos;[name].bundle.css&apos;,</div><div class=\"line\">      allChunks: true,</div><div class=\"line\">    &#125;),</div><div class=\"line\">  ],</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>运行 webpack -p 之后, 你会发现在 output 指定的目录中会有一个 app.bundle.css 文件. 最后, 在 HTML 文件中通过 <link> 标签正常引用.</p>\n<h2 id=\"实现ES6的模块加载\"><a href=\"#实现ES6的模块加载\" class=\"headerlink\" title=\"实现ES6的模块加载\"></a>实现ES6的模块加载</h2><p>可以用import,export，不需要把他们转成CommonJS模块的格式</p>\n<h3 id=\"代码分割\"><a href=\"#代码分割\" class=\"headerlink\" title=\"代码分割\"></a>代码分割</h3><ul>\n<li>ES6 Loader 规范定义了 System.import 方法，用于在运行时动态加载 ES6 模块。</li>\n<li>Webpack 把 System.import 作为拆分点，然后把被请求的模块放入一个单独的 “块”（chunk）中。</li>\n<li>System.import 接受模块名作为参数，然后返回一个 Promise。</li>\n<li>chunk 加载失败产生的错误现在可以被捕获了。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">System.import(&quot;./module&quot;).then(module =&gt; &#123;</div><div class=\"line\">\tmodule.default;</div><div class=\"line\">&#125;).catch(err =&gt; &#123;</div><div class=\"line\">\tconsole.log(&quot;Chunk loading failed&quot;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>开发服务器会运行在 localhost:8080(打开你的浏览器访问该地址就能看到你的页面). 需要注意的是 script 标签里的 /assets 是和 output.publicPath 匹配的–你可以把它命名成任何你想要的名字(如果你使用CDN, 这会很有用).<br>Webpack 提供了热加载功能. 当你修改了 JavaScript 文件后, Webpack 会自动重新加载资源, 而不需要你手动去刷新浏览器. 但是, 任何对 webpack.config.js 文件的改变都需要重启服务器才会生效.</p>\n<p><strong>动态表达式</strong><br>还可以把一个表达式作为参数传给 System.import。表达式的处理方式类似于 CommonJS（Webpack 为每个可能的文件创建一个独立的上下文）。<br>System.import 会令每个可能的模块都产生一个独立的 chunk。所以就可以用循环产生多个 chunk，感觉简写了有木有</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function route(path, query) &#123;</div><div class=\"line\">\treturn System.import(&quot;./routes/&quot; + path + &quot;/route&quot;)</div><div class=\"line\">\t\t.then(route =&gt; new route.Route(query));</div><div class=\"line\">&#125;</div><div class=\"line\">// 这会为每种可能的路径组合都创建一个对应的 chunk。</div></pre></td></tr></table></figure>\n<h3 id=\"Babel-与-Webpack\"><a href=\"#Babel-与-Webpack\" class=\"headerlink\" title=\"Babel 与 Webpack\"></a>Babel 与 Webpack</h3><p>在默认情况下，Babel 的 es2015 预设方案（preset）会把 ES6 模块转换为 CommonJS 格式。如果你想让 Webpack 来处理 ES6 模块，那你应该换用 es2015-webpack 这个预设方案。</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>在过去的环境中，变量通常用来在配置文件中处理不同的环境。Webpack 2 引入了一种新方法，可以将选项传给配置。<br>配置文件可以导出一个函数，这个函数返回配置。这个函数会被 CLI（命令行界面）调用，而通过 –env 参数传过来的值会被传递给这个配置函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">on the terminal : --env dev //string</div><div class=\"line\"></div><div class=\"line\">on the terminal : --env.minimize true --env.server localhost //object</div><div class=\"line\"></div><div class=\"line\">//配置</div><div class=\"line\">// webpack.config.babel.js</div><div class=\"line\">exports default function(options) &#123;</div><div class=\"line\">\t//string  =&gt; dev</div><div class=\"line\">\t//object  =&gt; &#123;minimize: true, server: &quot;localhost&quot;&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\t// ...</div><div class=\"line\">\t\tdevtool: options.dev ? &quot;cheap-module-eval-source-map&quot; : &quot;hidden-source-map&quot;</div><div class=\"line\">\t&#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"解析选项\"><a href=\"#解析选项\" class=\"headerlink\" title=\"解析选项\"></a>解析选项</h2><p>{<br>    modules: [path.resolve(__dirname, “app”), “node_modules”]<br>    // （以前这个选项分散在 <code>root</code>、<code>modulesDirectories</code> 和 <code>fallback</code> 三处。）<br>    // 模块查找路径：指定解析器查找模块的目录。<br>    // 相对路径会在每一层父级目录中查找（类似 node_modules）。<br>    // 绝对路径会直接查找。<br>    // 将按你指定的顺序查找。</p>\n<pre><code>descriptionFiles: [&quot;package.json&quot;, &quot;bower.json&quot;],\n// 描述文件：这些 JSON 文件将在目录中被读取。\n\nmainFields: [&quot;main&quot;, &quot;browser&quot;],\n// 入口字段：在解析一个包目录时，描述文件中的这些字段所指定的文件将被视为包的入口文件。\n\nmainFiles: [&quot;index&quot;]\n// 入口文件：在解析一个目录时，这些文件将被视为目录的入口文件。\n\naliasFields: [&quot;browser&quot;],\n// 别名字段：描述文件中的这些字段提供了该包的别名对照关系。\n// 这些字段的内容是一个对象，每当请求某个键名时，就会映射到对应的键值。\n\nextensions: [&quot;.js&quot;, &quot;.json&quot;],\n// 扩展名\n\nmoduleExtensions: [&quot;-loader&quot;],\n//模块后缀名：在解析一个模块名时，将会尝试附加这些后缀名\n\nenforceModuleExtension: false,\n// If false it&apos;s also try to use no module extension from above\n\nalias: {\n    jquery: path.resolve(__dirname, &quot;vendor/jquery-2.0.0.js&quot;)\n}\n// 请求重定向，在解析一个模块名时，会使用这个别名映射表\n</code></pre><h2 id=\"Minor-breaking-changes\"><a href=\"#Minor-breaking-changes\" class=\"headerlink\" title=\"Minor breaking changes\"></a>Minor breaking changes</h2><h3 id=\"Promise-polyfill\"><a href=\"#Promise-polyfill\" class=\"headerlink\" title=\"Promise polyfill\"></a>Promise polyfill</h3><p>分块加载机制现在是依赖于 Promise 的。这表示你需要在旧版浏览器下提供一个 Promise 的 polyfill。</p>\n<h3 id=\"other-polyfills\"><a href=\"#other-polyfills\" class=\"headerlink\" title=\"other polyfills\"></a>other polyfills</h3><ul>\n<li>你需要一个 Object.defineProperty 的 polyfill 来实现 ES6 的模块特性。或者在以（除了 module.exports、module.id、module.loaded 或 module.hot 之外的）其它方式使用 module 对象时，这个 polyfill 也是需要的。</li>\n<li>为了实现 ES6 的模块特性，你还需要一个 Function.prototype.bind 的 polyfill</li>\n<li>你需要一个 Object.keys 的 polyfill 来运行 require.context().keys()</li>\n</ul>\n<h2 id=\"Loaders-configuration\"><a href=\"#Loaders-configuration\" class=\"headerlink\" title=\"Loaders configuration\"></a>Loaders configuration</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">loaders: [</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttest: /\\.css$/,</div><div class=\"line\">\t\tloaders: [</div><div class=\"line\">\t\t\t&quot;style-loader&quot;,</div><div class=\"line\">\t\t\t&#123; loader: &quot;css-loader&quot;, query: &#123; modules: true &#125; &#125;,</div><div class=\"line\">\t\t\t&#123;</div><div class=\"line\">\t\t\t\tloader: &quot;sass-loader&quot;,</div><div class=\"line\">\t\t\t\tquery: &#123;</div><div class=\"line\">\t\t\t\t\tincludePaths: [</div><div class=\"line\">\t\t\t\t\t\tpath.resolve(__dirname, &quot;some-folder&quot;)</div><div class=\"line\">\t\t\t\t\t]</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t]</div><div class=\"line\">\t&#125;</div><div class=\"line\">]</div></pre></td></tr></table></figure>\n<h3 id=\"Loader-选项以及代码压缩\"><a href=\"#Loader-选项以及代码压缩\" class=\"headerlink\" title=\"Loader 选项以及代码压缩\"></a>Loader 选项以及代码压缩</h3><p>UglifyJsPlugin 将不再把所有 loader 都切到代码压缩模式。debug 选项已经被移除。Loader 不应该再从 Webpack 的配置那里读取自己选项了。取而代之的是，你需要通过 LoaderOptionsPlugin 来提供这些选项。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">new webpack.LoaderOptionsPlugin(&#123;</div><div class=\"line\">\ttest: /\\.css$/, // optionally pass test, include and exclude, default affects all loaders</div><div class=\"line\">\t                // 可以传入 test、include 和 exclude，默认会影响所有的 loader</div><div class=\"line\">\tminimize: true,</div><div class=\"line\">\tdebug: false,</div><div class=\"line\">\toptions: &#123;</div><div class=\"line\">\t\t// pass stuff to the loader</div><div class=\"line\">\t\t// 这里的选项会传给 loader</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<h2 id=\"Plugins\"><a href=\"#Plugins\" class=\"headerlink\" title=\"Plugins\"></a>Plugins</h2><p>现在许多插件将可以接受一个选项对象，而不是以前多个参数的形式,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">配置webpack插件</div><div class=\"line\">plugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,</div><div class=\"line\">而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.</div><div class=\"line\">简而言之： loader关注文件名，plugin关注事件</div><div class=\"line\">*/</div><div class=\"line\"> module: &#123;</div><div class=\"line\">    /*</div><div class=\"line\">    配置各种类型文件的加载器, 称之为loader</div><div class=\"line\">    webpack当遇到import ... 时, 会调用这里配置的loader对引用的文件进行编译</div><div class=\"line\">    */</div><div class=\"line\">    rules: [</div><div class=\"line\">      &#123;</div><div class=\"line\">        /*</div><div class=\"line\">        使用babel编译ES6/ES7/ES8为ES5代码</div><div class=\"line\">        使用正则表达式匹配后缀名为.js的文件</div><div class=\"line\">        */</div><div class=\"line\">        test: /\\.js$/,</div><div class=\"line\"></div><div class=\"line\">        // 排除node_modules目录下的文件, npm安装的包不需要编译</div><div class=\"line\">        exclude: /node_modules/,</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">        use指定该文件的loader, 值可以是字符串或者数组.</div><div class=\"line\">        这里先使用eslint-loader处理, 返回的结果交给babel-loader处理. loader的处理顺序是从最后一个到第一个.</div><div class=\"line\">        eslint-loader用来检查代码, 如果有错误, 编译的时候会报错.</div><div class=\"line\">        babel-loader用来编译js文件.</div><div class=\"line\">        */</div><div class=\"line\">        use: [&apos;babel-loader&apos;, &apos;eslint-loader&apos;]</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &#123;</div><div class=\"line\">        // 匹配.html文件</div><div class=\"line\">        test: /\\.html$/,</div><div class=\"line\">        /*</div><div class=\"line\">        使用html-loader, 将html内容存为js字符串, 比如当遇到</div><div class=\"line\">        import htmlString from &apos;./template.html&apos;</div><div class=\"line\">        template.html的文件内容会被转成一个js字符串, 合并到js文件里.</div><div class=\"line\">        */</div><div class=\"line\">        use: &apos;html-loader&apos;</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &#123;</div><div class=\"line\">        // 匹配.css文件</div><div class=\"line\">        test: /\\.css$/,</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">        先使用css-loader处理, 返回的结果交给style-loader处理.</div><div class=\"line\">        css-loader将css内容存为js字符串, 并且会把background, @font-face等引用的图片,</div><div class=\"line\">        字体文件交给指定的loader打包, 类似上面的html-loader, 用什么loader同样在loaders对象中定义, 等会下面就会看到.</div><div class=\"line\">        */</div><div class=\"line\">        use: [&apos;style-loader&apos;, &apos;css-loader&apos;]</div><div class=\"line\">      &#125;,</div><div class=\"line\"></div><div class=\"line\">      &#123;</div><div class=\"line\">        /*</div><div class=\"line\">        匹配各种格式的图片和字体文件</div><div class=\"line\">        上面html-loader会把html中&lt;img&gt;标签的图片解析出来, 文件名匹配到这里的test的正则表达式,</div><div class=\"line\">        css-loader引用的图片和字体同样会匹配到这里的test条件</div><div class=\"line\">        */</div><div class=\"line\">        test: /\\.(png|jpg|jpeg|gif|eot|ttf|woff|woff2|svg|svgz)(\\?.+)?$/,</div><div class=\"line\"></div><div class=\"line\">        /*</div><div class=\"line\">        使用url-loader, 它接受一个limit参数, 单位为字节(byte)</div><div class=\"line\"></div><div class=\"line\">        当文件体积小于limit时, url-loader把文件转为Data URI的格式内联到引用的地方</div><div class=\"line\">        当文件大于limit时, url-loader会调用file-loader, 把文件储存到输出目录, 并把引用的文件路径改写成输出后的路径</div><div class=\"line\"></div><div class=\"line\">        比如 views/foo/index.html中</div><div class=\"line\">        &lt;img src=&quot;smallpic.png&quot;&gt;</div><div class=\"line\">        会被编译成</div><div class=\"line\">        &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAA...&quot;&gt;</div><div class=\"line\"></div><div class=\"line\">        而</div><div class=\"line\">        &lt;img src=&quot;largepic.png&quot;&gt;</div><div class=\"line\">        会被编译成</div><div class=\"line\">        &lt;img src=&quot;/f78661bef717cf2cc2c2e5158f196384.png&quot;&gt;</div><div class=\"line\">        */</div><div class=\"line\">        use: [</div><div class=\"line\">          &#123;</div><div class=\"line\">            loader: &apos;url-loader&apos;,</div><div class=\"line\">            options: &#123;</div><div class=\"line\">              limit: 10000</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        ]</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  /*</div><div class=\"line\">  配置webpack插件</div><div class=\"line\">  plugin和loader的区别是, loader是在import时根据不同的文件名, 匹配不同的loader对这个文件做处理,</div><div class=\"line\">  而plugin, 关注的不是文件的格式, 而是在编译的各个阶段, 会触发不同的事件, 让你可以干预每个编译阶段.</div><div class=\"line\">  */</div><div class=\"line\">  plugins: [</div><div class=\"line\">    /*</div><div class=\"line\">    html-webpack-plugin用来打包入口html文件</div><div class=\"line\">    entry配置的入口是js文件, webpack以js文件为入口, 遇到import, 用配置的loader加载引入文件</div><div class=\"line\">    但作为浏览器打开的入口html, 是引用入口js的文件, 它在整个编译过程的外面,</div><div class=\"line\">    所以, 我们需要html-webpack-plugin来打包作为入口的html文件</div><div class=\"line\">    */</div><div class=\"line\">    new HtmlWebpackPlugin(&#123;</div><div class=\"line\">      /*</div><div class=\"line\">      template参数指定入口html文件路径, 插件会把这个文件交给webpack去编译,</div><div class=\"line\">      webpack按照正常流程, 找到loaders中test条件匹配的loader来编译, 那么这里html-loader就是匹配的loader</div><div class=\"line\">      html-loader编译后产生的字符串, 会由html-webpack-plugin储存为html文件到输出目录, 默认文件名为index.html</div><div class=\"line\">      可以通过filename参数指定输出的文件名</div><div class=\"line\">      html-webpack-plugin也可以不指定template参数, 它会使用默认的html模板.</div><div class=\"line\">      */</div><div class=\"line\">      template: &apos;./src/index.html&apos;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    new webpack.ProvidePlugin(&#123;$: &apos;jquery&apos;, jQuery: &apos;jquery&apos;, &apos;window.jQuery&apos;: &apos;jquery&apos;&#125;),</div><div class=\"line\">  ],</div></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/dwqs/blog/issues/46\" target=\"_blank\" rel=\"external\">参考</a><br><a href=\"https://github.com/cssmagic/blog/issues/58\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"ES6之静态、私有","type":"categories","_content":"\n# 静态方法和属性（实例化对象不拥有）\n\n## 静态方法\n```\nclass Event {\n\tstatic tell(){\n\n\t}\n\tget(key) {\n\n\t}\n\tset(key, value) {\n\n\t}\n}\n//调用\nEvent.tell()\n//可以覆写\nEvent.tell = function() {\n\t\n}\n```\n## 静态属性\n两种方法设置\n- constructor里面\n- get、set方法（只有get没有set方法，该属性不能修改）\n\n```\nvar age = 0\nclass Own {\n\tconstructor({name}) {\n\t\tthis.name = name //静态属性\n\t}\n\tget age() {\n\n\t}\n\tset age(value) {\n\t\tage = value\n\t}\n}\n\nbabel支持静态属性下面这种写法\n\nclass Own {\n  static name = 'blah'\n}\n```\n\n# 私有方法和属性\n私有属性的特性\n- class内部不同方法间可以使用，因此this要指向实例化对象\n- 私有属性不能让子类继承\n- 私有属性不能被外部访问到\n那么ES6如何实现私有属性呢\n\n## 私有属性\n\n### weakmap\n\n```\nconst _name = new WeakMap()\nclass Own {\n\tconstructor({name, age}) {\n\t\t_name.set(this, name)\n\t}\n\tspeak() {\n\t\t_name.get(this)\n\t}\n}\n并不是理想的私有属性的方法，虽然利用weakmap可以将this作为键名，但是形式上不好看\n```\n\n\n### Symbol\n缺点：\n- 通过Reflect.ownKeys()在外部获取这些键名\n- 每多一个键名，就要在外面定义一个变量\n- 子类将继续拥有这些属性\n```\nconst _name = new Symbol('name') //独一无二的\nclass Own {\n\tconstuctor(name) {\n\t\tthis[_name] = name\n\t}\t\n}\n\n```\n### 终极解决方法\n\n```\nlet attr = {}\n\nclass Own {\n\tget(key) {\n\t\treturn attr[this] && attr[this][key]\n\t}\n\tset(key, value) {\n\t\tif(!attributions[this]) attributions[this] = {}\n\t\tattributions[this][key] = value\n\t}\n}\n```\n为私有属性的存储介质，而且每一个实例化对象都有自己的存储空间。通过get和set方法来获取和设置私有属性，非常好的解决了上面的问题。而且这种方法，如果不看源码，基本在外部是获取不到任何私有属性的，它们也不会被子类继承，当然，get和set方法是可以被继承的。\n\n## 私有方法\n\n理论上讲，私有属性和私有方法的区别是，私有方法是函数。因此，只需要将上面的私有属性的存储值替换为函数即可。但是作为方法，内部的this必须指向其实例化对象，因此还是需要在稍作加工。\n\n```\nvar _say = new WeakMap()\nclass MyClass {\n    constructor({name, age}) {\n        this.name = name\n        _say.set(this, () => {\n            alert(this.name)\n        })\n    }\n}\n```\n由于使用了箭头函数，函数体内的this和外部的this是同一个，因此不会发生this指向偏移的问题。\n\n既然私有属性可以使用set, get来实现，为何私有方法不也用它来实现呢？其实，完全没有必要这样去做，就像在class外部加一个attributions一样，我们也可以在class外部创建函数，这些函数只有在同一个文档中可见，因此对外部也是私有的，外部程序无法获取。\n\n```\nlet factories = {\n\ttell: function(options) {  // 这里一定要用function，而不能用箭头函数，因为使用箭头函数将不能使用bind\n\t\tthis.render()\n\t}\n}\n\nclass Own {\n\trender: function() {\n\t\tconsole.log('render')\n\t}\n\tcall(fun) {\n\t\tif(!factories[fun]) return\n\t\treturn factories[fun].bind(this)\n\t}\n\ttell() {\n\t\tthis.call('tell')(options)\n\t}\n}\n\n//如果你不想用两个括号那么麻烦，要么不允许传入参数，要么可以用apply代替：\nexport default class MyClass {\n    render() {}\n    call(fun, ...args) {\n        if(!factories[fun]) return\n        return factories[fun].apply(this, args)\n    }\n    test() {\n        this.call('a', options) // 使用call来调用私有方法，第一个括号填写函数名，第二个括号填写该函数的参数\n    }\n}\n\n//如果你还想省事，甚至可以不用把函数都包含在factories里面，直接定义函数，在类里面使用apply：\n\nfunction my_fun(options) {\n  this.render()\n}\n\nexport default class MyClass {\n    render() {}\n    test() {\n      my_fun.apply(this, 'options')\n    }\n}\n```\n# 总结\n1、 静态属性主要通过constuctor里的this绑定和自带的get、set方法实现，不需要实例化，直接调用\n2、 私有属性通过set、get属性和一个中间介质变量实现了属性私有化，并且避免了被继承父属性的问题、被外部调用的问题\n3、 其实apply改变函数的执行的作用域间接地相当于调用了私有方法","source":"_posts/js/es6/ES6之静态和私有.md","raw":"---\ntitle: ES6之静态、私有\ntype: \"categories\"\ncategories: [前端, JS, ES6]\n---\n\n# 静态方法和属性（实例化对象不拥有）\n\n## 静态方法\n```\nclass Event {\n\tstatic tell(){\n\n\t}\n\tget(key) {\n\n\t}\n\tset(key, value) {\n\n\t}\n}\n//调用\nEvent.tell()\n//可以覆写\nEvent.tell = function() {\n\t\n}\n```\n## 静态属性\n两种方法设置\n- constructor里面\n- get、set方法（只有get没有set方法，该属性不能修改）\n\n```\nvar age = 0\nclass Own {\n\tconstructor({name}) {\n\t\tthis.name = name //静态属性\n\t}\n\tget age() {\n\n\t}\n\tset age(value) {\n\t\tage = value\n\t}\n}\n\nbabel支持静态属性下面这种写法\n\nclass Own {\n  static name = 'blah'\n}\n```\n\n# 私有方法和属性\n私有属性的特性\n- class内部不同方法间可以使用，因此this要指向实例化对象\n- 私有属性不能让子类继承\n- 私有属性不能被外部访问到\n那么ES6如何实现私有属性呢\n\n## 私有属性\n\n### weakmap\n\n```\nconst _name = new WeakMap()\nclass Own {\n\tconstructor({name, age}) {\n\t\t_name.set(this, name)\n\t}\n\tspeak() {\n\t\t_name.get(this)\n\t}\n}\n并不是理想的私有属性的方法，虽然利用weakmap可以将this作为键名，但是形式上不好看\n```\n\n\n### Symbol\n缺点：\n- 通过Reflect.ownKeys()在外部获取这些键名\n- 每多一个键名，就要在外面定义一个变量\n- 子类将继续拥有这些属性\n```\nconst _name = new Symbol('name') //独一无二的\nclass Own {\n\tconstuctor(name) {\n\t\tthis[_name] = name\n\t}\t\n}\n\n```\n### 终极解决方法\n\n```\nlet attr = {}\n\nclass Own {\n\tget(key) {\n\t\treturn attr[this] && attr[this][key]\n\t}\n\tset(key, value) {\n\t\tif(!attributions[this]) attributions[this] = {}\n\t\tattributions[this][key] = value\n\t}\n}\n```\n为私有属性的存储介质，而且每一个实例化对象都有自己的存储空间。通过get和set方法来获取和设置私有属性，非常好的解决了上面的问题。而且这种方法，如果不看源码，基本在外部是获取不到任何私有属性的，它们也不会被子类继承，当然，get和set方法是可以被继承的。\n\n## 私有方法\n\n理论上讲，私有属性和私有方法的区别是，私有方法是函数。因此，只需要将上面的私有属性的存储值替换为函数即可。但是作为方法，内部的this必须指向其实例化对象，因此还是需要在稍作加工。\n\n```\nvar _say = new WeakMap()\nclass MyClass {\n    constructor({name, age}) {\n        this.name = name\n        _say.set(this, () => {\n            alert(this.name)\n        })\n    }\n}\n```\n由于使用了箭头函数，函数体内的this和外部的this是同一个，因此不会发生this指向偏移的问题。\n\n既然私有属性可以使用set, get来实现，为何私有方法不也用它来实现呢？其实，完全没有必要这样去做，就像在class外部加一个attributions一样，我们也可以在class外部创建函数，这些函数只有在同一个文档中可见，因此对外部也是私有的，外部程序无法获取。\n\n```\nlet factories = {\n\ttell: function(options) {  // 这里一定要用function，而不能用箭头函数，因为使用箭头函数将不能使用bind\n\t\tthis.render()\n\t}\n}\n\nclass Own {\n\trender: function() {\n\t\tconsole.log('render')\n\t}\n\tcall(fun) {\n\t\tif(!factories[fun]) return\n\t\treturn factories[fun].bind(this)\n\t}\n\ttell() {\n\t\tthis.call('tell')(options)\n\t}\n}\n\n//如果你不想用两个括号那么麻烦，要么不允许传入参数，要么可以用apply代替：\nexport default class MyClass {\n    render() {}\n    call(fun, ...args) {\n        if(!factories[fun]) return\n        return factories[fun].apply(this, args)\n    }\n    test() {\n        this.call('a', options) // 使用call来调用私有方法，第一个括号填写函数名，第二个括号填写该函数的参数\n    }\n}\n\n//如果你还想省事，甚至可以不用把函数都包含在factories里面，直接定义函数，在类里面使用apply：\n\nfunction my_fun(options) {\n  this.render()\n}\n\nexport default class MyClass {\n    render() {}\n    test() {\n      my_fun.apply(this, 'options')\n    }\n}\n```\n# 总结\n1、 静态属性主要通过constuctor里的this绑定和自带的get、set方法实现，不需要实例化，直接调用\n2、 私有属性通过set、get属性和一个中间介质变量实现了属性私有化，并且避免了被继承父属性的问题、被外部调用的问题\n3、 其实apply改变函数的执行的作用域间接地相当于调用了私有方法","slug":"js-es6-ES6之静态和私有","published":1,"date":"2017-07-31T02:26:48.000Z","updated":"2017-07-31T02:26:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgp002zkzy631leuupx","content":"<h1 id=\"静态方法和属性（实例化对象不拥有）\"><a href=\"#静态方法和属性（实例化对象不拥有）\" class=\"headerlink\" title=\"静态方法和属性（实例化对象不拥有）\"></a>静态方法和属性（实例化对象不拥有）</h1><h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Event &#123;</div><div class=\"line\">\tstatic tell()&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tget(key) &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tset(key, value) &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//调用</div><div class=\"line\">Event.tell()</div><div class=\"line\">//可以覆写</div><div class=\"line\">Event.tell = function() &#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><p>两种方法设置</p>\n<ul>\n<li>constructor里面</li>\n<li>get、set方法（只有get没有set方法，该属性不能修改）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var age = 0</div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tconstructor(&#123;name&#125;) &#123;</div><div class=\"line\">\t\tthis.name = name //静态属性</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tget age() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tset age(value) &#123;</div><div class=\"line\">\t\tage = value</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">babel支持静态属性下面这种写法</div><div class=\"line\"></div><div class=\"line\">class Own &#123;</div><div class=\"line\">  static name = &apos;blah&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"私有方法和属性\"><a href=\"#私有方法和属性\" class=\"headerlink\" title=\"私有方法和属性\"></a>私有方法和属性</h1><p>私有属性的特性</p>\n<ul>\n<li>class内部不同方法间可以使用，因此this要指向实例化对象</li>\n<li>私有属性不能让子类继承</li>\n<li>私有属性不能被外部访问到<br>那么ES6如何实现私有属性呢</li>\n</ul>\n<h2 id=\"私有属性\"><a href=\"#私有属性\" class=\"headerlink\" title=\"私有属性\"></a>私有属性</h2><h3 id=\"weakmap\"><a href=\"#weakmap\" class=\"headerlink\" title=\"weakmap\"></a>weakmap</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const _name = new WeakMap()</div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tconstructor(&#123;name, age&#125;) &#123;</div><div class=\"line\">\t\t_name.set(this, name)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tspeak() &#123;</div><div class=\"line\">\t\t_name.get(this)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">并不是理想的私有属性的方法，虽然利用weakmap可以将this作为键名，但是形式上不好看</div></pre></td></tr></table></figure>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>缺点：</p>\n<ul>\n<li>通过Reflect.ownKeys()在外部获取这些键名</li>\n<li>每多一个键名，就要在外面定义一个变量</li>\n<li>子类将继续拥有这些属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">const _name = new Symbol(&apos;name&apos;) //独一无二的</div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tconstuctor(name) &#123;</div><div class=\"line\">\t\tthis[_name] = name</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"终极解决方法\"><a href=\"#终极解决方法\" class=\"headerlink\" title=\"终极解决方法\"></a>终极解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let attr = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tget(key) &#123;</div><div class=\"line\">\t\treturn attr[this] &amp;&amp; attr[this][key]</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tset(key, value) &#123;</div><div class=\"line\">\t\tif(!attributions[this]) attributions[this] = &#123;&#125;</div><div class=\"line\">\t\tattributions[this][key] = value</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为私有属性的存储介质，而且每一个实例化对象都有自己的存储空间。通过get和set方法来获取和设置私有属性，非常好的解决了上面的问题。而且这种方法，如果不看源码，基本在外部是获取不到任何私有属性的，它们也不会被子类继承，当然，get和set方法是可以被继承的。</p>\n<h2 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h2><p>理论上讲，私有属性和私有方法的区别是，私有方法是函数。因此，只需要将上面的私有属性的存储值替换为函数即可。但是作为方法，内部的this必须指向其实例化对象，因此还是需要在稍作加工。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var _say = new WeakMap()</div><div class=\"line\">class MyClass &#123;</div><div class=\"line\">    constructor(&#123;name, age&#125;) &#123;</div><div class=\"line\">        this.name = name</div><div class=\"line\">        _say.set(this, () =&gt; &#123;</div><div class=\"line\">            alert(this.name)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于使用了箭头函数，函数体内的this和外部的this是同一个，因此不会发生this指向偏移的问题。</p>\n<p>既然私有属性可以使用set, get来实现，为何私有方法不也用它来实现呢？其实，完全没有必要这样去做，就像在class外部加一个attributions一样，我们也可以在class外部创建函数，这些函数只有在同一个文档中可见，因此对外部也是私有的，外部程序无法获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">let factories = &#123;</div><div class=\"line\">\ttell: function(options) &#123;  // 这里一定要用function，而不能用箭头函数，因为使用箭头函数将不能使用bind</div><div class=\"line\">\t\tthis.render()</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Own &#123;</div><div class=\"line\">\trender: function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;render&apos;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcall(fun) &#123;</div><div class=\"line\">\t\tif(!factories[fun]) return</div><div class=\"line\">\t\treturn factories[fun].bind(this)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ttell() &#123;</div><div class=\"line\">\t\tthis.call(&apos;tell&apos;)(options)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//如果你不想用两个括号那么麻烦，要么不允许传入参数，要么可以用apply代替：</div><div class=\"line\">export default class MyClass &#123;</div><div class=\"line\">    render() &#123;&#125;</div><div class=\"line\">    call(fun, ...args) &#123;</div><div class=\"line\">        if(!factories[fun]) return</div><div class=\"line\">        return factories[fun].apply(this, args)</div><div class=\"line\">    &#125;</div><div class=\"line\">    test() &#123;</div><div class=\"line\">        this.call(&apos;a&apos;, options) // 使用call来调用私有方法，第一个括号填写函数名，第二个括号填写该函数的参数</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//如果你还想省事，甚至可以不用把函数都包含在factories里面，直接定义函数，在类里面使用apply：</div><div class=\"line\"></div><div class=\"line\">function my_fun(options) &#123;</div><div class=\"line\">  this.render()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">export default class MyClass &#123;</div><div class=\"line\">    render() &#123;&#125;</div><div class=\"line\">    test() &#123;</div><div class=\"line\">      my_fun.apply(this, &apos;options&apos;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、 静态属性主要通过constuctor里的this绑定和自带的get、set方法实现，不需要实例化，直接调用<br>2、 私有属性通过set、get属性和一个中间介质变量实现了属性私有化，并且避免了被继承父属性的问题、被外部调用的问题<br>3、 其实apply改变函数的执行的作用域间接地相当于调用了私有方法</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"静态方法和属性（实例化对象不拥有）\"><a href=\"#静态方法和属性（实例化对象不拥有）\" class=\"headerlink\" title=\"静态方法和属性（实例化对象不拥有）\"></a>静态方法和属性（实例化对象不拥有）</h1><h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Event &#123;</div><div class=\"line\">\tstatic tell()&#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tget(key) &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tset(key, value) &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//调用</div><div class=\"line\">Event.tell()</div><div class=\"line\">//可以覆写</div><div class=\"line\">Event.tell = function() &#123;</div><div class=\"line\">\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><p>两种方法设置</p>\n<ul>\n<li>constructor里面</li>\n<li>get、set方法（只有get没有set方法，该属性不能修改）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var age = 0</div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tconstructor(&#123;name&#125;) &#123;</div><div class=\"line\">\t\tthis.name = name //静态属性</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tget age() &#123;</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\">\tset age(value) &#123;</div><div class=\"line\">\t\tage = value</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">babel支持静态属性下面这种写法</div><div class=\"line\"></div><div class=\"line\">class Own &#123;</div><div class=\"line\">  static name = &apos;blah&apos;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"私有方法和属性\"><a href=\"#私有方法和属性\" class=\"headerlink\" title=\"私有方法和属性\"></a>私有方法和属性</h1><p>私有属性的特性</p>\n<ul>\n<li>class内部不同方法间可以使用，因此this要指向实例化对象</li>\n<li>私有属性不能让子类继承</li>\n<li>私有属性不能被外部访问到<br>那么ES6如何实现私有属性呢</li>\n</ul>\n<h2 id=\"私有属性\"><a href=\"#私有属性\" class=\"headerlink\" title=\"私有属性\"></a>私有属性</h2><h3 id=\"weakmap\"><a href=\"#weakmap\" class=\"headerlink\" title=\"weakmap\"></a>weakmap</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">const _name = new WeakMap()</div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tconstructor(&#123;name, age&#125;) &#123;</div><div class=\"line\">\t\t_name.set(this, name)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tspeak() &#123;</div><div class=\"line\">\t\t_name.get(this)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">并不是理想的私有属性的方法，虽然利用weakmap可以将this作为键名，但是形式上不好看</div></pre></td></tr></table></figure>\n<h3 id=\"Symbol\"><a href=\"#Symbol\" class=\"headerlink\" title=\"Symbol\"></a>Symbol</h3><p>缺点：</p>\n<ul>\n<li>通过Reflect.ownKeys()在外部获取这些键名</li>\n<li>每多一个键名，就要在外面定义一个变量</li>\n<li>子类将继续拥有这些属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">const _name = new Symbol(&apos;name&apos;) //独一无二的</div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tconstuctor(name) &#123;</div><div class=\"line\">\t\tthis[_name] = name</div><div class=\"line\">\t&#125;\t</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"终极解决方法\"><a href=\"#终极解决方法\" class=\"headerlink\" title=\"终极解决方法\"></a>终极解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">let attr = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">class Own &#123;</div><div class=\"line\">\tget(key) &#123;</div><div class=\"line\">\t\treturn attr[this] &amp;&amp; attr[this][key]</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tset(key, value) &#123;</div><div class=\"line\">\t\tif(!attributions[this]) attributions[this] = &#123;&#125;</div><div class=\"line\">\t\tattributions[this][key] = value</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>为私有属性的存储介质，而且每一个实例化对象都有自己的存储空间。通过get和set方法来获取和设置私有属性，非常好的解决了上面的问题。而且这种方法，如果不看源码，基本在外部是获取不到任何私有属性的，它们也不会被子类继承，当然，get和set方法是可以被继承的。</p>\n<h2 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h2><p>理论上讲，私有属性和私有方法的区别是，私有方法是函数。因此，只需要将上面的私有属性的存储值替换为函数即可。但是作为方法，内部的this必须指向其实例化对象，因此还是需要在稍作加工。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var _say = new WeakMap()</div><div class=\"line\">class MyClass &#123;</div><div class=\"line\">    constructor(&#123;name, age&#125;) &#123;</div><div class=\"line\">        this.name = name</div><div class=\"line\">        _say.set(this, () =&gt; &#123;</div><div class=\"line\">            alert(this.name)</div><div class=\"line\">        &#125;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于使用了箭头函数，函数体内的this和外部的this是同一个，因此不会发生this指向偏移的问题。</p>\n<p>既然私有属性可以使用set, get来实现，为何私有方法不也用它来实现呢？其实，完全没有必要这样去做，就像在class外部加一个attributions一样，我们也可以在class外部创建函数，这些函数只有在同一个文档中可见，因此对外部也是私有的，外部程序无法获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">let factories = &#123;</div><div class=\"line\">\ttell: function(options) &#123;  // 这里一定要用function，而不能用箭头函数，因为使用箭头函数将不能使用bind</div><div class=\"line\">\t\tthis.render()</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class Own &#123;</div><div class=\"line\">\trender: function() &#123;</div><div class=\"line\">\t\tconsole.log(&apos;render&apos;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcall(fun) &#123;</div><div class=\"line\">\t\tif(!factories[fun]) return</div><div class=\"line\">\t\treturn factories[fun].bind(this)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ttell() &#123;</div><div class=\"line\">\t\tthis.call(&apos;tell&apos;)(options)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//如果你不想用两个括号那么麻烦，要么不允许传入参数，要么可以用apply代替：</div><div class=\"line\">export default class MyClass &#123;</div><div class=\"line\">    render() &#123;&#125;</div><div class=\"line\">    call(fun, ...args) &#123;</div><div class=\"line\">        if(!factories[fun]) return</div><div class=\"line\">        return factories[fun].apply(this, args)</div><div class=\"line\">    &#125;</div><div class=\"line\">    test() &#123;</div><div class=\"line\">        this.call(&apos;a&apos;, options) // 使用call来调用私有方法，第一个括号填写函数名，第二个括号填写该函数的参数</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//如果你还想省事，甚至可以不用把函数都包含在factories里面，直接定义函数，在类里面使用apply：</div><div class=\"line\"></div><div class=\"line\">function my_fun(options) &#123;</div><div class=\"line\">  this.render()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">export default class MyClass &#123;</div><div class=\"line\">    render() &#123;&#125;</div><div class=\"line\">    test() &#123;</div><div class=\"line\">      my_fun.apply(this, &apos;options&apos;)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>1、 静态属性主要通过constuctor里的this绑定和自带的get、set方法实现，不需要实例化，直接调用<br>2、 私有属性通过set、get属性和一个中间介质变量实现了属性私有化，并且避免了被继承父属性的问题、被外部调用的问题<br>3、 其实apply改变函数的执行的作用域间接地相当于调用了私有方法</p>\n"},{"title":"ES6不可忽视的问题","type":"categories","_content":"\n#### const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是?\n> 可以被修改，const避免类型的改变，可以保护引用不变，const保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的**数据结构**是不是可变的，就完全不能控制了\n","source":"_posts/js/es6/ES6的不应忽视的问题.md","raw":"---\ntitle: ES6不可忽视的问题\ntype: \"categories\"\ncategories: [前端, JS, ES6]\n---\n\n#### const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是?\n> 可以被修改，const避免类型的改变，可以保护引用不变，const保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的**数据结构**是不是可变的，就完全不能控制了\n","slug":"js-es6-ES6的不应忽视的问题","published":1,"date":"2017-04-23T10:51:31.000Z","updated":"2017-04-23T10:51:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgq0030kzy6aqzwlh2e","content":"<h4 id=\"const-定义的-Array-中间元素能否被修改-如果可以-那-const-的意义是\"><a href=\"#const-定义的-Array-中间元素能否被修改-如果可以-那-const-的意义是\" class=\"headerlink\" title=\"const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是?\"></a>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是?</h4><blockquote>\n<p>可以被修改，const避免类型的改变，可以保护引用不变，const保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的<strong>数据结构</strong>是不是可变的，就完全不能控制了</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"const-定义的-Array-中间元素能否被修改-如果可以-那-const-的意义是\"><a href=\"#const-定义的-Array-中间元素能否被修改-如果可以-那-const-的意义是\" class=\"headerlink\" title=\"const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是?\"></a>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是?</h4><blockquote>\n<p>可以被修改，const避免类型的改变，可以保护引用不变，const保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的<strong>数据结构</strong>是不是可变的，就完全不能控制了</p>\n</blockquote>\n"},{"title":"代替语言内部方法的Reflect","type":"categories","_content":"\n# Reflect是什么\nReflect和Proxy是ES6提供的一套操作对象的API，目的就是为了将语言内部方法以后用Reflect代替，另外Reflect还是声明式的写法\n\n# Reflect的静态方法\nReflect.apply(target,thisArg,args)\nReflect.construct(target,args)\nReflect.get(target,name,receiver)\nReflect.set(target,name,value,receiver) //Reflect.set会触发Proxy.defineProperty拦截\nReflect.defineProperty(target,name,desc)\nReflect.deleteProperty(target,name)\nReflect.has(target,name)\nReflect.ownKeys(target)\nReflect.isExtensible(target)\nReflect.preventExtensions(target)\nReflect.getOwnPropertyDescriptor(target, name)\nReflect.getPrototypeOf(target)\nReflect.setPrototypeOf(target, prototype)\n大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的\n\n","source":"_posts/js/es6/Reflect.md","raw":"---\ntitle: 代替语言内部方法的Reflect\ntype: \"categories\"\ncategories: [前端, JS, ES6]\n---\n\n# Reflect是什么\nReflect和Proxy是ES6提供的一套操作对象的API，目的就是为了将语言内部方法以后用Reflect代替，另外Reflect还是声明式的写法\n\n# Reflect的静态方法\nReflect.apply(target,thisArg,args)\nReflect.construct(target,args)\nReflect.get(target,name,receiver)\nReflect.set(target,name,value,receiver) //Reflect.set会触发Proxy.defineProperty拦截\nReflect.defineProperty(target,name,desc)\nReflect.deleteProperty(target,name)\nReflect.has(target,name)\nReflect.ownKeys(target)\nReflect.isExtensible(target)\nReflect.preventExtensions(target)\nReflect.getOwnPropertyDescriptor(target, name)\nReflect.getPrototypeOf(target)\nReflect.setPrototypeOf(target, prototype)\n大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的\n\n","slug":"js-es6-Reflect","published":1,"date":"2017-04-27T06:51:39.000Z","updated":"2017-04-27T06:51:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgs0031kzy6ej272g8s","content":"<h1 id=\"Reflect是什么\"><a href=\"#Reflect是什么\" class=\"headerlink\" title=\"Reflect是什么\"></a>Reflect是什么</h1><p>Reflect和Proxy是ES6提供的一套操作对象的API，目的就是为了将语言内部方法以后用Reflect代替，另外Reflect还是声明式的写法</p>\n<h1 id=\"Reflect的静态方法\"><a href=\"#Reflect的静态方法\" class=\"headerlink\" title=\"Reflect的静态方法\"></a>Reflect的静态方法</h1><p>Reflect.apply(target,thisArg,args)<br>Reflect.construct(target,args)<br>Reflect.get(target,name,receiver)<br>Reflect.set(target,name,value,receiver) //Reflect.set会触发Proxy.defineProperty拦截<br>Reflect.defineProperty(target,name,desc)<br>Reflect.deleteProperty(target,name)<br>Reflect.has(target,name)<br>Reflect.ownKeys(target)<br>Reflect.isExtensible(target)<br>Reflect.preventExtensions(target)<br>Reflect.getOwnPropertyDescriptor(target, name)<br>Reflect.getPrototypeOf(target)<br>Reflect.setPrototypeOf(target, prototype)<br>大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Reflect是什么\"><a href=\"#Reflect是什么\" class=\"headerlink\" title=\"Reflect是什么\"></a>Reflect是什么</h1><p>Reflect和Proxy是ES6提供的一套操作对象的API，目的就是为了将语言内部方法以后用Reflect代替，另外Reflect还是声明式的写法</p>\n<h1 id=\"Reflect的静态方法\"><a href=\"#Reflect的静态方法\" class=\"headerlink\" title=\"Reflect的静态方法\"></a>Reflect的静态方法</h1><p>Reflect.apply(target,thisArg,args)<br>Reflect.construct(target,args)<br>Reflect.get(target,name,receiver)<br>Reflect.set(target,name,value,receiver) //Reflect.set会触发Proxy.defineProperty拦截<br>Reflect.defineProperty(target,name,desc)<br>Reflect.deleteProperty(target,name)<br>Reflect.has(target,name)<br>Reflect.ownKeys(target)<br>Reflect.isExtensible(target)<br>Reflect.preventExtensions(target)<br>Reflect.getOwnPropertyDescriptor(target, name)<br>Reflect.getPrototypeOf(target)<br>Reflect.setPrototypeOf(target, prototype)<br>大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的</p>\n"},{"title":"面试的问题","type":"categories","_content":"\n## 如何替换DOM节点\n\n我刚开始只想到replaceChild(替换成元素，需要替换的元素)，后来想了想其实还有innerHTML， outInnerHTML变相替换\n\n## use strict 和 strict 的区别\n回答这个问题的时候讲的不是很全，所以查查资料，补上一些\n\n严格模式的目的：\n- 消除不严谨的行为\n- 提高编译效率，增加运行速度\n- 消除代码的不安的地方\n- 为新版Javascript做好铺垫\n\n严格模式调用方法： \n- 整个脚本文件前加use strict\n- 函数体的第一行加严格模式\n- 考虑到代码合并到情况，将脚本文件放到一个立即执行的函数之中\n\n严格模式对js行为和语法做了哪些改变\n### 全局变量显示声明\n```\n\"use strict\";\n　　v = 1; // 报错，v未声明\n　　for(i = 0; i < 2; i++) { // 报错，i未声明\n　　}\n```\n### 静态绑定\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n```\n　　\"use strict\";\n　　var v = 1;\n　　with (o){ // 语法错误 \n　　　　v = 2;\n　　}\n```\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域,严格模式创设了第三种作用域：eval作用域。\n### 增强的安全措施\n```\n（1）禁止this关键字指向全局对象\n　　function f(){\n　　　　return !this;\n　　} \n　　// 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n　　function f(){ \n　　　　\"use strict\";\n　　　　return !this;\n　　} \n　　// 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n```\n\n因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。\n\n```\n　　function f(){\n　　　　\"use strict\";\n　　　　this.a = 1;\n　　};\n　　f();// 报错，this未定义\n```\n禁止在函数内部遍历调用栈\n```\n　　function f1(){\n　　　　\"use strict\";\n　　　　f1.caller; // 报错\n　　　　f1.arguments; // 报错\n　　}\n　　f1();\n```\n### 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n```\n　　\"use strict\";\n　　var x;\n　　delete x; // 语法错误\n　　var o = Object.create(null, {'x': {\n　　　　　　value: 1,\n　　　　　　configurable: true\n　　}});\n　　delete o.x; // 删除成功\n```\n### 显式报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n```\n　　\"use strict\";\n\n　　var o = {};\n　　Object.defineProperty(o, \"v\", { value: 1, writable: false });\n　　o.v = 2; // 报错\n```\n### arguments对象的限制\narguments不再追踪参数的变化\n```\n　　function f(a) {\n　　　　a = 2;\n　　　　return [a, arguments[0]];\n　　}\n　　f(1); // 正常模式为[2,2]\n　　function f(a) {\n　　　　\"use strict\";\n　　　　a = 2;\n　　　　return [a, arguments[0]];\n　　}\n　　f(1); // 严格模式为[2,1]\n```\n\n### 禁止使用arguments.callee\n```\n　　\"use strict\";\n　　var f = function() { return arguments.callee; };\n　　f(); // 报错\n```\n\n###  重名错误\n- 对象不能有重名的属性\n```\n　　\"use strict\";\n　　var o = {\n　　　　p: 1,\n　　　　p: 2\n　　}; // 语法错误\n```\n- 函数不能有重名的参数\n\n```\n　　\"use strict\";\n　　function f(a, a, b) { // 语法错误\n　　　　return ;\n　　}\n```\n### 函数必须声明在顶层\n```\n　\"use strict\";\n　　if (true) {\n　　　　function f() { } // 语法错误\n　　}\n　　for (var i = 0; i < 5; i++) {\n　　　　function f2() { } // 语法错误\n　　}\n```\n\n### 保留字\n```\n　　function package(protected) { // 语法错误\n　　　　\"use strict\";\n　　　　var implements; // 语法错误\n　　}\n\n```\n\n## CSS选择器权值的问题\n\n1. 内联样式表的权值最高 1000；\n\n2. ID 选择器的权值为 100\n\n3. Class 类选择器的权值为 10\n\n4. HTML 标签选择器的权值为 1\n\n## 箭头函数\n\n- 箭头函数内部没有constructor方法，也没有prototype，所以不支持new操作。但是它对this的处理与一般的普通函数不一样。箭头函数的 this 始终指向**函数定义时的 this**，而非执行时。\n- 这个this是不会改变指向对象的，我们知道call和apply可以改变this的指向\n\n\n## ajax的封装\n\n## history实现\n### 存储当前历史记录点\n```\n// 当前的url为：http://qianduanblog.com/index.html\nvar json={time:new Date().getTime()};\n// @状态对象：记录历史记录点的额外对象，可以为空\n// @页面标题：目前所有浏览器都不支持\n// @可选的url：浏览器不会检查url是否存在，只改变url，url必须同域，不能跨域\nwindow.history.pushState(json,\"\",\"http://qianduanblog.com/post-1.html\");</pre>\n执行了pushState方法后，页面的url地址为http://qianduanblog.com/post-1.html。\n```\n### 替换当前历史记录点\nwindow.history.replaceState和window.history.pushState类似，不同之处在于replaceState不会在window.history里新增历史记录点，其效果类似于window.location.replace(url)，都是不会在历史记录点里新增一个记录点的。当你为了响应用户的某些操作，而要更新当前历史记录条目的状态对象或URL时，使用replaceState()方法会特别合适。\n\n### 监听历史记录点\n\n监听历史记录点，直观的可认为是监听URL的变化，但会忽略URL的hash部分，监听URL的hash部分，HTML5有新的API为onhashchange，我的博客里也有说到该方法和跨浏览器的兼容解决方案。可以通过window.onpopstate来监听url的变化，并且可以获取存储在该历史记录点的状态对象，也就是上文说到的json对象，如：\n```\n// 当前的url为：http://qianduanblog.com/post-1.html\nwindow.onpopstate=function()\n{\n    // 获得存储在该历史记录点的json对象\n    var json=window.history.state;\n    // 点击一次回退到：http://qianduanblog.com/index.html\n    // 获得的json为null\n    // 再点击一次前进到：http://qianduanblog.com/post-1.html\n    // 获得json为{time:1369647895656}\n}\n```\n值得注意的是：javascript脚本执行window.history.pushState和window.history.replaceState不会触发onpopstate事件。\n\n还有一点注意的是，谷歌浏览器和火狐浏览器在页面第一次打开的反应是不同的，谷歌浏览器奇怪的是回触发onpopstate事件，而火狐浏览器则不会。\n\n## 闭包\n```\nvar sum = 0\nfunction fn(a) {\n    sum = sum + a\n    return function(b) {\n        if(a==0 || b== 0) {\n            return sum\n        } else {\n            return fn(b)\n        }\n\n    }\n}\nfn(2)(3)(4)(0)\n```\n\n## 实现一个lazyMan\n\n```\nfunction _LazyMan(n) {\n\tthis.task = []\n\tvar self  = this\n\tvar fn = (function(n) {\n\t\tvar name = n\n\t\treturn function() {\n\t\t\tconsole.log(`HI + ${name}`)\n\t\t\tself.next()\n\t\t}\n\t})\n\tthis.task.push(fn)\n\tsetTimeout(function() {\n\t\tself.next() \n\t}, 0) //在下一个循环执行任务\n}\n\n_LazyMan.prototype.next = function() {\n\tvar fn = this.tasks.shift()\n\tfn && fn()\n}\n\n\n_LazyMan.prototype.eat = function(name) {\n\tvar self = this\n\tvar fn = (function(name) {\n\t\treturn function() {\n\t\t\tconsole.log(`eat + ${name}`)\n\t\t\tself.next()\n\t\t}\n\t})(name)\n\tthis.task.push(fn)\n\treturn this;\n}\n\n_LazyMan.prototype.sleep = function(time) {\n    var self = this;\n    var fn = (function(time){\n        return function() {\n            setTimeout(function(){\n                console.log(\"Wake up after \" + time + \"s!\");\n                self.next();\n            }, time * 1000);\n        }\n    })(time);\n    this.tasks.push(fn);\n   return this;\n}\n\n_LazyMan.prototype.sleepFirst = function(time) {\n    var self = this;\n    var fn = (function(time) {\n        return function() {\n            setTimeout(function() {\n                console.log(\"Wake up after \" + time + \"s!\");\n                self.next();\n            }, time * 1000);\n        }\n    })(time);\n    this.tasks.unshift(fn);\n    return this;\n}\n\nfunction LazyMan(name) {\n\treturn new _LazyMan(name)\n}\n\n```\n\n## 垃圾回收机制原理和方法\n\n原理： \n- 当变量在程序中不再未来的运行中访问的时候\n- 向这些对象要求归还内存\n\n方法：\n- 标记清除法\n- 引用计数（IE)\n\n\n## 随机生成N个m到n的数\n```\nfunction fn(n) {\n    var newArr = []\n    while(n > 0) {\n        var newNumber = Math.floor(Math.random()*31 + 2)\n        if(!newArr.includes(newNumber)) {\n            n --\n            newArr.push(newNumber)\n        }\n    }\n\n    return Array.from(new Set(newArr))\n}\nfn(10)\n```\n\n## 简单动画的实现\n```\nfunction animate2(element, endValue, duration) {\n    var startTime = new Date(),\n        startValue = parseInt(element.style.width);\n\n    var timerId = setInterval(function() {\n        // 保证百分率不大于1\n        var percentage = Math.min(1, (new Date - startTime) / duration);\n\n        var stepValue;\n        if (percentage >= 1) {\n            // 保证最终值的准确性\n            stepValue = endValue;\n        } else {\n            stepValue = startValue + (endValue - startValue) * percentage;\n        }\n        element.style.width = stepValue + 'px';\n\n        if (percentage >= 1) {\n            clearInterval(timerId);\n            element.innerHTML = new Date - startTime;\n        }\n    }, 13);\n}\n\nanimate2(document.getElementById('test1'), 200, 1000);\n\nfunction getTopDistance() {\n    return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;\n}\n```\n## 输入阿拉伯数字，输出对应的中文\n\n```\nfunction fn(n){\n    if(!/^([1-9]\\d*)/.test(n)){\n        return '非法数据';\n    }\n    var unit = '千百十亿千百十万千百十个';\n    if(n.length > unit.length){\n        return '数据过长';\n    }\n    var newStr = '';\n    var nlength = n.length;\n\n    unit = unit.substr(unit.length - nlength);\n\n    for(var i = 0; i < nlength; i++){\n        newStr += '零一二三四五六七八九'.charAt(n[i]) + unit.charAt(i);\n    }\n\n    newStr = newStr.substr(0,newStr.length-1);\n    newStr = newStr.replace(/零(千|百|十)/g,'零').replace(/(零)+/g,'零').replace(/零(亿|万)/g,'$1');\n    return newStr;\n}\nconsole.log(fn('2103'));\n```\n\n## 写一个函数实现一个最大并发数量，limitLoad(urls, handler, limit)\n\n```\n\n//单一请求并发请求四次。采用递归，执行完一个，开入口\n\nlet urls = ['1.png', '2.png', '3.png', '4.png']\n\nlimitLoad(urls, loadImg, 2)\n\nconst limitLoad = (urls, handler, limit) => {\n\n    const squence = [].concat(urls)\n    const promises = []\n    let count = 0\n\n    const load = () => {\n        if(squence.length <= 0 ||  count > limit) return \n        count += 1\n        return handler(squence.shift())\n            .catch(err => {\n                console.error(err)\n            })\n            .then(() => {\n                count -= 1\n            })\n            .then(load())\n    }\n\n    for(let i = 0; i < limit && i < sequence.length; i++){\n        promises.push(load())\n    }\n\n    return Promise.all(promises)\n}\n\nfunction loadImg(url) {\n    return new Promise((resolve, reject) => {\n        var image = new Image()\n        image.onload = () => {\n            resolve()\n        }\n        img.onerror = reject\n        img.src = url\n    })\n}\n\n\n```\n","source":"_posts/js/es6/面试题.md","raw":"---\ntitle: 面试的问题\ntype: \"categories\"\ncategories: [前端, JS, ES6]\n---\n\n## 如何替换DOM节点\n\n我刚开始只想到replaceChild(替换成元素，需要替换的元素)，后来想了想其实还有innerHTML， outInnerHTML变相替换\n\n## use strict 和 strict 的区别\n回答这个问题的时候讲的不是很全，所以查查资料，补上一些\n\n严格模式的目的：\n- 消除不严谨的行为\n- 提高编译效率，增加运行速度\n- 消除代码的不安的地方\n- 为新版Javascript做好铺垫\n\n严格模式调用方法： \n- 整个脚本文件前加use strict\n- 函数体的第一行加严格模式\n- 考虑到代码合并到情况，将脚本文件放到一个立即执行的函数之中\n\n严格模式对js行为和语法做了哪些改变\n### 全局变量显示声明\n```\n\"use strict\";\n　　v = 1; // 报错，v未声明\n　　for(i = 0; i < 2; i++) { // 报错，i未声明\n　　}\n```\n### 静态绑定\n因为with语句无法在编译时就确定，属性到底归属哪个对象。\n```\n　　\"use strict\";\n　　var v = 1;\n　　with (o){ // 语法错误 \n　　　　v = 2;\n　　}\n```\n正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域,严格模式创设了第三种作用域：eval作用域。\n### 增强的安全措施\n```\n（1）禁止this关键字指向全局对象\n　　function f(){\n　　　　return !this;\n　　} \n　　// 返回false，因为\"this\"指向全局对象，\"!this\"就是false\n　　function f(){ \n　　　　\"use strict\";\n　　　　return !this;\n　　} \n　　// 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。\n```\n\n因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。\n\n```\n　　function f(){\n　　　　\"use strict\";\n　　　　this.a = 1;\n　　};\n　　f();// 报错，this未定义\n```\n禁止在函数内部遍历调用栈\n```\n　　function f1(){\n　　　　\"use strict\";\n　　　　f1.caller; // 报错\n　　　　f1.arguments; // 报错\n　　}\n　　f1();\n```\n### 禁止删除变量\n严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。\n```\n　　\"use strict\";\n　　var x;\n　　delete x; // 语法错误\n　　var o = Object.create(null, {'x': {\n　　　　　　value: 1,\n　　　　　　configurable: true\n　　}});\n　　delete o.x; // 删除成功\n```\n### 显式报错\n正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n```\n　　\"use strict\";\n\n　　var o = {};\n　　Object.defineProperty(o, \"v\", { value: 1, writable: false });\n　　o.v = 2; // 报错\n```\n### arguments对象的限制\narguments不再追踪参数的变化\n```\n　　function f(a) {\n　　　　a = 2;\n　　　　return [a, arguments[0]];\n　　}\n　　f(1); // 正常模式为[2,2]\n　　function f(a) {\n　　　　\"use strict\";\n　　　　a = 2;\n　　　　return [a, arguments[0]];\n　　}\n　　f(1); // 严格模式为[2,1]\n```\n\n### 禁止使用arguments.callee\n```\n　　\"use strict\";\n　　var f = function() { return arguments.callee; };\n　　f(); // 报错\n```\n\n###  重名错误\n- 对象不能有重名的属性\n```\n　　\"use strict\";\n　　var o = {\n　　　　p: 1,\n　　　　p: 2\n　　}; // 语法错误\n```\n- 函数不能有重名的参数\n\n```\n　　\"use strict\";\n　　function f(a, a, b) { // 语法错误\n　　　　return ;\n　　}\n```\n### 函数必须声明在顶层\n```\n　\"use strict\";\n　　if (true) {\n　　　　function f() { } // 语法错误\n　　}\n　　for (var i = 0; i < 5; i++) {\n　　　　function f2() { } // 语法错误\n　　}\n```\n\n### 保留字\n```\n　　function package(protected) { // 语法错误\n　　　　\"use strict\";\n　　　　var implements; // 语法错误\n　　}\n\n```\n\n## CSS选择器权值的问题\n\n1. 内联样式表的权值最高 1000；\n\n2. ID 选择器的权值为 100\n\n3. Class 类选择器的权值为 10\n\n4. HTML 标签选择器的权值为 1\n\n## 箭头函数\n\n- 箭头函数内部没有constructor方法，也没有prototype，所以不支持new操作。但是它对this的处理与一般的普通函数不一样。箭头函数的 this 始终指向**函数定义时的 this**，而非执行时。\n- 这个this是不会改变指向对象的，我们知道call和apply可以改变this的指向\n\n\n## ajax的封装\n\n## history实现\n### 存储当前历史记录点\n```\n// 当前的url为：http://qianduanblog.com/index.html\nvar json={time:new Date().getTime()};\n// @状态对象：记录历史记录点的额外对象，可以为空\n// @页面标题：目前所有浏览器都不支持\n// @可选的url：浏览器不会检查url是否存在，只改变url，url必须同域，不能跨域\nwindow.history.pushState(json,\"\",\"http://qianduanblog.com/post-1.html\");</pre>\n执行了pushState方法后，页面的url地址为http://qianduanblog.com/post-1.html。\n```\n### 替换当前历史记录点\nwindow.history.replaceState和window.history.pushState类似，不同之处在于replaceState不会在window.history里新增历史记录点，其效果类似于window.location.replace(url)，都是不会在历史记录点里新增一个记录点的。当你为了响应用户的某些操作，而要更新当前历史记录条目的状态对象或URL时，使用replaceState()方法会特别合适。\n\n### 监听历史记录点\n\n监听历史记录点，直观的可认为是监听URL的变化，但会忽略URL的hash部分，监听URL的hash部分，HTML5有新的API为onhashchange，我的博客里也有说到该方法和跨浏览器的兼容解决方案。可以通过window.onpopstate来监听url的变化，并且可以获取存储在该历史记录点的状态对象，也就是上文说到的json对象，如：\n```\n// 当前的url为：http://qianduanblog.com/post-1.html\nwindow.onpopstate=function()\n{\n    // 获得存储在该历史记录点的json对象\n    var json=window.history.state;\n    // 点击一次回退到：http://qianduanblog.com/index.html\n    // 获得的json为null\n    // 再点击一次前进到：http://qianduanblog.com/post-1.html\n    // 获得json为{time:1369647895656}\n}\n```\n值得注意的是：javascript脚本执行window.history.pushState和window.history.replaceState不会触发onpopstate事件。\n\n还有一点注意的是，谷歌浏览器和火狐浏览器在页面第一次打开的反应是不同的，谷歌浏览器奇怪的是回触发onpopstate事件，而火狐浏览器则不会。\n\n## 闭包\n```\nvar sum = 0\nfunction fn(a) {\n    sum = sum + a\n    return function(b) {\n        if(a==0 || b== 0) {\n            return sum\n        } else {\n            return fn(b)\n        }\n\n    }\n}\nfn(2)(3)(4)(0)\n```\n\n## 实现一个lazyMan\n\n```\nfunction _LazyMan(n) {\n\tthis.task = []\n\tvar self  = this\n\tvar fn = (function(n) {\n\t\tvar name = n\n\t\treturn function() {\n\t\t\tconsole.log(`HI + ${name}`)\n\t\t\tself.next()\n\t\t}\n\t})\n\tthis.task.push(fn)\n\tsetTimeout(function() {\n\t\tself.next() \n\t}, 0) //在下一个循环执行任务\n}\n\n_LazyMan.prototype.next = function() {\n\tvar fn = this.tasks.shift()\n\tfn && fn()\n}\n\n\n_LazyMan.prototype.eat = function(name) {\n\tvar self = this\n\tvar fn = (function(name) {\n\t\treturn function() {\n\t\t\tconsole.log(`eat + ${name}`)\n\t\t\tself.next()\n\t\t}\n\t})(name)\n\tthis.task.push(fn)\n\treturn this;\n}\n\n_LazyMan.prototype.sleep = function(time) {\n    var self = this;\n    var fn = (function(time){\n        return function() {\n            setTimeout(function(){\n                console.log(\"Wake up after \" + time + \"s!\");\n                self.next();\n            }, time * 1000);\n        }\n    })(time);\n    this.tasks.push(fn);\n   return this;\n}\n\n_LazyMan.prototype.sleepFirst = function(time) {\n    var self = this;\n    var fn = (function(time) {\n        return function() {\n            setTimeout(function() {\n                console.log(\"Wake up after \" + time + \"s!\");\n                self.next();\n            }, time * 1000);\n        }\n    })(time);\n    this.tasks.unshift(fn);\n    return this;\n}\n\nfunction LazyMan(name) {\n\treturn new _LazyMan(name)\n}\n\n```\n\n## 垃圾回收机制原理和方法\n\n原理： \n- 当变量在程序中不再未来的运行中访问的时候\n- 向这些对象要求归还内存\n\n方法：\n- 标记清除法\n- 引用计数（IE)\n\n\n## 随机生成N个m到n的数\n```\nfunction fn(n) {\n    var newArr = []\n    while(n > 0) {\n        var newNumber = Math.floor(Math.random()*31 + 2)\n        if(!newArr.includes(newNumber)) {\n            n --\n            newArr.push(newNumber)\n        }\n    }\n\n    return Array.from(new Set(newArr))\n}\nfn(10)\n```\n\n## 简单动画的实现\n```\nfunction animate2(element, endValue, duration) {\n    var startTime = new Date(),\n        startValue = parseInt(element.style.width);\n\n    var timerId = setInterval(function() {\n        // 保证百分率不大于1\n        var percentage = Math.min(1, (new Date - startTime) / duration);\n\n        var stepValue;\n        if (percentage >= 1) {\n            // 保证最终值的准确性\n            stepValue = endValue;\n        } else {\n            stepValue = startValue + (endValue - startValue) * percentage;\n        }\n        element.style.width = stepValue + 'px';\n\n        if (percentage >= 1) {\n            clearInterval(timerId);\n            element.innerHTML = new Date - startTime;\n        }\n    }, 13);\n}\n\nanimate2(document.getElementById('test1'), 200, 1000);\n\nfunction getTopDistance() {\n    return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;\n}\n```\n## 输入阿拉伯数字，输出对应的中文\n\n```\nfunction fn(n){\n    if(!/^([1-9]\\d*)/.test(n)){\n        return '非法数据';\n    }\n    var unit = '千百十亿千百十万千百十个';\n    if(n.length > unit.length){\n        return '数据过长';\n    }\n    var newStr = '';\n    var nlength = n.length;\n\n    unit = unit.substr(unit.length - nlength);\n\n    for(var i = 0; i < nlength; i++){\n        newStr += '零一二三四五六七八九'.charAt(n[i]) + unit.charAt(i);\n    }\n\n    newStr = newStr.substr(0,newStr.length-1);\n    newStr = newStr.replace(/零(千|百|十)/g,'零').replace(/(零)+/g,'零').replace(/零(亿|万)/g,'$1');\n    return newStr;\n}\nconsole.log(fn('2103'));\n```\n\n## 写一个函数实现一个最大并发数量，limitLoad(urls, handler, limit)\n\n```\n\n//单一请求并发请求四次。采用递归，执行完一个，开入口\n\nlet urls = ['1.png', '2.png', '3.png', '4.png']\n\nlimitLoad(urls, loadImg, 2)\n\nconst limitLoad = (urls, handler, limit) => {\n\n    const squence = [].concat(urls)\n    const promises = []\n    let count = 0\n\n    const load = () => {\n        if(squence.length <= 0 ||  count > limit) return \n        count += 1\n        return handler(squence.shift())\n            .catch(err => {\n                console.error(err)\n            })\n            .then(() => {\n                count -= 1\n            })\n            .then(load())\n    }\n\n    for(let i = 0; i < limit && i < sequence.length; i++){\n        promises.push(load())\n    }\n\n    return Promise.all(promises)\n}\n\nfunction loadImg(url) {\n    return new Promise((resolve, reject) => {\n        var image = new Image()\n        image.onload = () => {\n            resolve()\n        }\n        img.onerror = reject\n        img.src = url\n    })\n}\n\n\n```\n","slug":"js-es6-面试题","published":1,"date":"2017-04-25T00:53:41.000Z","updated":"2017-10-02T10:21:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgt0033kzy6n1fp5p7i","content":"<h2 id=\"如何替换DOM节点\"><a href=\"#如何替换DOM节点\" class=\"headerlink\" title=\"如何替换DOM节点\"></a>如何替换DOM节点</h2><p>我刚开始只想到replaceChild(替换成元素，需要替换的元素)，后来想了想其实还有innerHTML， outInnerHTML变相替换</p>\n<h2 id=\"use-strict-和-strict-的区别\"><a href=\"#use-strict-和-strict-的区别\" class=\"headerlink\" title=\"use strict 和 strict 的区别\"></a>use strict 和 strict 的区别</h2><p>回答这个问题的时候讲的不是很全，所以查查资料，补上一些</p>\n<p>严格模式的目的：</p>\n<ul>\n<li>消除不严谨的行为</li>\n<li>提高编译效率，增加运行速度</li>\n<li>消除代码的不安的地方</li>\n<li>为新版Javascript做好铺垫</li>\n</ul>\n<p>严格模式调用方法： </p>\n<ul>\n<li>整个脚本文件前加use strict</li>\n<li>函数体的第一行加严格模式</li>\n<li>考虑到代码合并到情况，将脚本文件放到一个立即执行的函数之中</li>\n</ul>\n<p>严格模式对js行为和语法做了哪些改变</p>\n<h3 id=\"全局变量显示声明\"><a href=\"#全局变量显示声明\" class=\"headerlink\" title=\"全局变量显示声明\"></a>全局变量显示声明</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">　　v = 1; // 报错，v未声明</div><div class=\"line\">　　for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"静态绑定\"><a href=\"#静态绑定\" class=\"headerlink\" title=\"静态绑定\"></a>静态绑定</h3><p>因为with语句无法在编译时就确定，属性到底归属哪个对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var v = 1;</div><div class=\"line\">　　with (o)&#123; // 语法错误 </div><div class=\"line\">　　　　v = 2;</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure></p>\n<p>正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域,严格模式创设了第三种作用域：eval作用域。</p>\n<h3 id=\"增强的安全措施\"><a href=\"#增强的安全措施\" class=\"headerlink\" title=\"增强的安全措施\"></a>增强的安全措施</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）禁止this关键字指向全局对象</div><div class=\"line\">　　function f()&#123;</div><div class=\"line\">　　　　return !this;</div><div class=\"line\">　　&#125; </div><div class=\"line\">　　// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</div><div class=\"line\">　　function f()&#123; </div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　return !this;</div><div class=\"line\">　　&#125; </div><div class=\"line\">　　// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</div></pre></td></tr></table></figure>\n<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f()&#123;</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　this.a = 1;</div><div class=\"line\">　　&#125;;</div><div class=\"line\">　　f();// 报错，this未定义</div></pre></td></tr></table></figure>\n<p>禁止在函数内部遍历调用栈<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f1()&#123;</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　f1.caller; // 报错</div><div class=\"line\">　　　　f1.arguments; // 报错</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　f1();</div></pre></td></tr></table></figure></p>\n<h3 id=\"禁止删除变量\"><a href=\"#禁止删除变量\" class=\"headerlink\" title=\"禁止删除变量\"></a>禁止删除变量</h3><p>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var x;</div><div class=\"line\">　　delete x; // 语法错误</div><div class=\"line\">　　var o = Object.create(null, &#123;&apos;x&apos;: &#123;</div><div class=\"line\">　　　　　　value: 1,</div><div class=\"line\">　　　　　　configurable: true</div><div class=\"line\">　　&#125;&#125;);</div><div class=\"line\">　　delete o.x; // 删除成功</div></pre></td></tr></table></figure></p>\n<h3 id=\"显式报错\"><a href=\"#显式报错\" class=\"headerlink\" title=\"显式报错\"></a>显式报错</h3><p>正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\"></div><div class=\"line\">　　var o = &#123;&#125;;</div><div class=\"line\">　　Object.defineProperty(o, &quot;v&quot;, &#123; value: 1, writable: false &#125;);</div><div class=\"line\">　　o.v = 2; // 报错</div></pre></td></tr></table></figure></p>\n<h3 id=\"arguments对象的限制\"><a href=\"#arguments对象的限制\" class=\"headerlink\" title=\"arguments对象的限制\"></a>arguments对象的限制</h3><p>arguments不再追踪参数的变化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f(a) &#123;</div><div class=\"line\">　　　　a = 2;</div><div class=\"line\">　　　　return [a, arguments[0]];</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　f(1); // 正常模式为[2,2]</div><div class=\"line\">　　function f(a) &#123;</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　a = 2;</div><div class=\"line\">　　　　return [a, arguments[0]];</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　f(1); // 严格模式为[2,1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"禁止使用arguments-callee\"><a href=\"#禁止使用arguments-callee\" class=\"headerlink\" title=\"禁止使用arguments.callee\"></a>禁止使用arguments.callee</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var f = function() &#123; return arguments.callee; &#125;;</div><div class=\"line\">　　f(); // 报错</div></pre></td></tr></table></figure>\n<h3 id=\"重名错误\"><a href=\"#重名错误\" class=\"headerlink\" title=\"重名错误\"></a>重名错误</h3><ul>\n<li><p>对象不能有重名的属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var o = &#123;</div><div class=\"line\">　　　　p: 1,</div><div class=\"line\">　　　　p: 2</div><div class=\"line\">　　&#125;; // 语法错误</div></pre></td></tr></table></figure>\n</li>\n<li><p>函数不能有重名的参数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　function f(a, a, b) &#123; // 语法错误</div><div class=\"line\">　　　　return ;</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"函数必须声明在顶层\"><a href=\"#函数必须声明在顶层\" class=\"headerlink\" title=\"函数必须声明在顶层\"></a>函数必须声明在顶层</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">　&quot;use strict&quot;;</div><div class=\"line\">　　if (true) &#123;</div><div class=\"line\">　　　　function f() &#123; &#125; // 语法错误</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　for (var i = 0; i &lt; 5; i++) &#123;</div><div class=\"line\">　　　　function f2() &#123; &#125; // 语法错误</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"保留字\"><a href=\"#保留字\" class=\"headerlink\" title=\"保留字\"></a>保留字</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function package(protected) &#123; // 语法错误</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　var implements; // 语法错误</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CSS选择器权值的问题\"><a href=\"#CSS选择器权值的问题\" class=\"headerlink\" title=\"CSS选择器权值的问题\"></a>CSS选择器权值的问题</h2><ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ul>\n<li>箭头函数内部没有constructor方法，也没有prototype，所以不支持new操作。但是它对this的处理与一般的普通函数不一样。箭头函数的 this 始终指向<strong>函数定义时的 this</strong>，而非执行时。</li>\n<li>这个this是不会改变指向对象的，我们知道call和apply可以改变this的指向</li>\n</ul>\n<h2 id=\"ajax的封装\"><a href=\"#ajax的封装\" class=\"headerlink\" title=\"ajax的封装\"></a>ajax的封装</h2><h2 id=\"history实现\"><a href=\"#history实现\" class=\"headerlink\" title=\"history实现\"></a>history实现</h2><h3 id=\"存储当前历史记录点\"><a href=\"#存储当前历史记录点\" class=\"headerlink\" title=\"存储当前历史记录点\"></a>存储当前历史记录点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 当前的url为：http://qianduanblog.com/index.html</div><div class=\"line\">var json=&#123;time:new Date().getTime()&#125;;</div><div class=\"line\">// @状态对象：记录历史记录点的额外对象，可以为空</div><div class=\"line\">// @页面标题：目前所有浏览器都不支持</div><div class=\"line\">// @可选的url：浏览器不会检查url是否存在，只改变url，url必须同域，不能跨域</div><div class=\"line\">window.history.pushState(json,&quot;&quot;,&quot;http://qianduanblog.com/post-1.html&quot;);&lt;/pre&gt;</div><div class=\"line\">执行了pushState方法后，页面的url地址为http://qianduanblog.com/post-1.html。</div></pre></td></tr></table></figure>\n<h3 id=\"替换当前历史记录点\"><a href=\"#替换当前历史记录点\" class=\"headerlink\" title=\"替换当前历史记录点\"></a>替换当前历史记录点</h3><p>window.history.replaceState和window.history.pushState类似，不同之处在于replaceState不会在window.history里新增历史记录点，其效果类似于window.location.replace(url)，都是不会在历史记录点里新增一个记录点的。当你为了响应用户的某些操作，而要更新当前历史记录条目的状态对象或URL时，使用replaceState()方法会特别合适。</p>\n<h3 id=\"监听历史记录点\"><a href=\"#监听历史记录点\" class=\"headerlink\" title=\"监听历史记录点\"></a>监听历史记录点</h3><p>监听历史记录点，直观的可认为是监听URL的变化，但会忽略URL的hash部分，监听URL的hash部分，HTML5有新的API为onhashchange，我的博客里也有说到该方法和跨浏览器的兼容解决方案。可以通过window.onpopstate来监听url的变化，并且可以获取存储在该历史记录点的状态对象，也就是上文说到的json对象，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 当前的url为：http://qianduanblog.com/post-1.html</div><div class=\"line\">window.onpopstate=function()</div><div class=\"line\">&#123;</div><div class=\"line\">    // 获得存储在该历史记录点的json对象</div><div class=\"line\">    var json=window.history.state;</div><div class=\"line\">    // 点击一次回退到：http://qianduanblog.com/index.html</div><div class=\"line\">    // 获得的json为null</div><div class=\"line\">    // 再点击一次前进到：http://qianduanblog.com/post-1.html</div><div class=\"line\">    // 获得json为&#123;time:1369647895656&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>值得注意的是：javascript脚本执行window.history.pushState和window.history.replaceState不会触发onpopstate事件。</p>\n<p>还有一点注意的是，谷歌浏览器和火狐浏览器在页面第一次打开的反应是不同的，谷歌浏览器奇怪的是回触发onpopstate事件，而火狐浏览器则不会。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var sum = 0</div><div class=\"line\">function fn(a) &#123;</div><div class=\"line\">    sum = sum + a</div><div class=\"line\">    return function(b) &#123;</div><div class=\"line\">        if(a==0 || b== 0) &#123;</div><div class=\"line\">            return sum</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return fn(b)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">fn(2)(3)(4)(0)</div></pre></td></tr></table></figure>\n<h2 id=\"实现一个lazyMan\"><a href=\"#实现一个lazyMan\" class=\"headerlink\" title=\"实现一个lazyMan\"></a>实现一个lazyMan</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">function _LazyMan(n) &#123;</div><div class=\"line\">\tthis.task = []</div><div class=\"line\">\tvar self  = this</div><div class=\"line\">\tvar fn = (function(n) &#123;</div><div class=\"line\">\t\tvar name = n</div><div class=\"line\">\t\treturn function() &#123;</div><div class=\"line\">\t\t\tconsole.log(`HI + $&#123;name&#125;`)</div><div class=\"line\">\t\t\tself.next()</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\tthis.task.push(fn)</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tself.next() </div><div class=\"line\">\t&#125;, 0) //在下一个循环执行任务</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.next = function() &#123;</div><div class=\"line\">\tvar fn = this.tasks.shift()</div><div class=\"line\">\tfn &amp;&amp; fn()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = function(name) &#123;</div><div class=\"line\">\tvar self = this</div><div class=\"line\">\tvar fn = (function(name) &#123;</div><div class=\"line\">\t\treturn function() &#123;</div><div class=\"line\">\t\t\tconsole.log(`eat + $&#123;name&#125;`)</div><div class=\"line\">\t\t\tself.next()</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)(name)</div><div class=\"line\">\tthis.task.push(fn)</div><div class=\"line\">\treturn this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = function(time) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    var fn = (function(time)&#123;</div><div class=\"line\">        return function() &#123;</div><div class=\"line\">            setTimeout(function()&#123;</div><div class=\"line\">                console.log(&quot;Wake up after &quot; + time + &quot;s!&quot;);</div><div class=\"line\">                self.next();</div><div class=\"line\">            &#125;, time * 1000);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)(time);</div><div class=\"line\">    this.tasks.push(fn);</div><div class=\"line\">   return this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleepFirst = function(time) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    var fn = (function(time) &#123;</div><div class=\"line\">        return function() &#123;</div><div class=\"line\">            setTimeout(function() &#123;</div><div class=\"line\">                console.log(&quot;Wake up after &quot; + time + &quot;s!&quot;);</div><div class=\"line\">                self.next();</div><div class=\"line\">            &#125;, time * 1000);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)(time);</div><div class=\"line\">    this.tasks.unshift(fn);</div><div class=\"line\">    return this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function LazyMan(name) &#123;</div><div class=\"line\">\treturn new _LazyMan(name)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"垃圾回收机制原理和方法\"><a href=\"#垃圾回收机制原理和方法\" class=\"headerlink\" title=\"垃圾回收机制原理和方法\"></a>垃圾回收机制原理和方法</h2><p>原理： </p>\n<ul>\n<li>当变量在程序中不再未来的运行中访问的时候</li>\n<li>向这些对象要求归还内存</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li>标记清除法</li>\n<li>引用计数（IE)</li>\n</ul>\n<h2 id=\"随机生成N个m到n的数\"><a href=\"#随机生成N个m到n的数\" class=\"headerlink\" title=\"随机生成N个m到n的数\"></a>随机生成N个m到n的数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fn(n) &#123;</div><div class=\"line\">    var newArr = []</div><div class=\"line\">    while(n &gt; 0) &#123;</div><div class=\"line\">        var newNumber = Math.floor(Math.random()*31 + 2)</div><div class=\"line\">        if(!newArr.includes(newNumber)) &#123;</div><div class=\"line\">            n --</div><div class=\"line\">            newArr.push(newNumber)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return Array.from(new Set(newArr))</div><div class=\"line\">&#125;</div><div class=\"line\">fn(10)</div></pre></td></tr></table></figure>\n<h2 id=\"简单动画的实现\"><a href=\"#简单动画的实现\" class=\"headerlink\" title=\"简单动画的实现\"></a>简单动画的实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">function animate2(element, endValue, duration) &#123;</div><div class=\"line\">    var startTime = new Date(),</div><div class=\"line\">        startValue = parseInt(element.style.width);</div><div class=\"line\"></div><div class=\"line\">    var timerId = setInterval(function() &#123;</div><div class=\"line\">        // 保证百分率不大于1</div><div class=\"line\">        var percentage = Math.min(1, (new Date - startTime) / duration);</div><div class=\"line\"></div><div class=\"line\">        var stepValue;</div><div class=\"line\">        if (percentage &gt;= 1) &#123;</div><div class=\"line\">            // 保证最终值的准确性</div><div class=\"line\">            stepValue = endValue;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            stepValue = startValue + (endValue - startValue) * percentage;</div><div class=\"line\">        &#125;</div><div class=\"line\">        element.style.width = stepValue + &apos;px&apos;;</div><div class=\"line\"></div><div class=\"line\">        if (percentage &gt;= 1) &#123;</div><div class=\"line\">            clearInterval(timerId);</div><div class=\"line\">            element.innerHTML = new Date - startTime;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;, 13);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">animate2(document.getElementById(&apos;test1&apos;), 200, 1000);</div><div class=\"line\"></div><div class=\"line\">function getTopDistance() &#123;</div><div class=\"line\">    return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"输入阿拉伯数字，输出对应的中文\"><a href=\"#输入阿拉伯数字，输出对应的中文\" class=\"headerlink\" title=\"输入阿拉伯数字，输出对应的中文\"></a>输入阿拉伯数字，输出对应的中文</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fn(n)&#123;</div><div class=\"line\">    if(!/^([1-9]\\d*)/.test(n))&#123;</div><div class=\"line\">        return &apos;非法数据&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var unit = &apos;千百十亿千百十万千百十个&apos;;</div><div class=\"line\">    if(n.length &gt; unit.length)&#123;</div><div class=\"line\">        return &apos;数据过长&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var newStr = &apos;&apos;;</div><div class=\"line\">    var nlength = n.length;</div><div class=\"line\"></div><div class=\"line\">    unit = unit.substr(unit.length - nlength);</div><div class=\"line\"></div><div class=\"line\">    for(var i = 0; i &lt; nlength; i++)&#123;</div><div class=\"line\">        newStr += &apos;零一二三四五六七八九&apos;.charAt(n[i]) + unit.charAt(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    newStr = newStr.substr(0,newStr.length-1);</div><div class=\"line\">    newStr = newStr.replace(/零(千|百|十)/g,&apos;零&apos;).replace(/(零)+/g,&apos;零&apos;).replace(/零(亿|万)/g,&apos;$1&apos;);</div><div class=\"line\">    return newStr;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(fn(&apos;2103&apos;));</div></pre></td></tr></table></figure>\n<h2 id=\"写一个函数实现一个最大并发数量，limitLoad-urls-handler-limit\"><a href=\"#写一个函数实现一个最大并发数量，limitLoad-urls-handler-limit\" class=\"headerlink\" title=\"写一个函数实现一个最大并发数量，limitLoad(urls, handler, limit)\"></a>写一个函数实现一个最大并发数量，limitLoad(urls, handler, limit)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//单一请求并发请求四次。采用递归，执行完一个，开入口</div><div class=\"line\"></div><div class=\"line\">let urls = [&apos;1.png&apos;, &apos;2.png&apos;, &apos;3.png&apos;, &apos;4.png&apos;]</div><div class=\"line\"></div><div class=\"line\">limitLoad(urls, loadImg, 2)</div><div class=\"line\"></div><div class=\"line\">const limitLoad = (urls, handler, limit) =&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">    const squence = [].concat(urls)</div><div class=\"line\">    const promises = []</div><div class=\"line\">    let count = 0</div><div class=\"line\"></div><div class=\"line\">    const load = () =&gt; &#123;</div><div class=\"line\">        if(squence.length &lt;= 0 ||  count &gt; limit) return </div><div class=\"line\">        count += 1</div><div class=\"line\">        return handler(squence.shift())</div><div class=\"line\">            .catch(err =&gt; &#123;</div><div class=\"line\">                console.error(err)</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .then(() =&gt; &#123;</div><div class=\"line\">                count -= 1</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .then(load())</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    for(let i = 0; i &lt; limit &amp;&amp; i &lt; sequence.length; i++)&#123;</div><div class=\"line\">        promises.push(load())</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return Promise.all(promises)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function loadImg(url) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">        var image = new Image()</div><div class=\"line\">        image.onload = () =&gt; &#123;</div><div class=\"line\">            resolve()</div><div class=\"line\">        &#125;</div><div class=\"line\">        img.onerror = reject</div><div class=\"line\">        img.src = url</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何替换DOM节点\"><a href=\"#如何替换DOM节点\" class=\"headerlink\" title=\"如何替换DOM节点\"></a>如何替换DOM节点</h2><p>我刚开始只想到replaceChild(替换成元素，需要替换的元素)，后来想了想其实还有innerHTML， outInnerHTML变相替换</p>\n<h2 id=\"use-strict-和-strict-的区别\"><a href=\"#use-strict-和-strict-的区别\" class=\"headerlink\" title=\"use strict 和 strict 的区别\"></a>use strict 和 strict 的区别</h2><p>回答这个问题的时候讲的不是很全，所以查查资料，补上一些</p>\n<p>严格模式的目的：</p>\n<ul>\n<li>消除不严谨的行为</li>\n<li>提高编译效率，增加运行速度</li>\n<li>消除代码的不安的地方</li>\n<li>为新版Javascript做好铺垫</li>\n</ul>\n<p>严格模式调用方法： </p>\n<ul>\n<li>整个脚本文件前加use strict</li>\n<li>函数体的第一行加严格模式</li>\n<li>考虑到代码合并到情况，将脚本文件放到一个立即执行的函数之中</li>\n</ul>\n<p>严格模式对js行为和语法做了哪些改变</p>\n<h3 id=\"全局变量显示声明\"><a href=\"#全局变量显示声明\" class=\"headerlink\" title=\"全局变量显示声明\"></a>全局变量显示声明</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;use strict&quot;;</div><div class=\"line\">　　v = 1; // 报错，v未声明</div><div class=\"line\">　　for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"静态绑定\"><a href=\"#静态绑定\" class=\"headerlink\" title=\"静态绑定\"></a>静态绑定</h3><p>因为with语句无法在编译时就确定，属性到底归属哪个对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var v = 1;</div><div class=\"line\">　　with (o)&#123; // 语法错误 </div><div class=\"line\">　　　　v = 2;</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure></p>\n<p>正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域,严格模式创设了第三种作用域：eval作用域。</p>\n<h3 id=\"增强的安全措施\"><a href=\"#增强的安全措施\" class=\"headerlink\" title=\"增强的安全措施\"></a>增强的安全措施</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）禁止this关键字指向全局对象</div><div class=\"line\">　　function f()&#123;</div><div class=\"line\">　　　　return !this;</div><div class=\"line\">　　&#125; </div><div class=\"line\">　　// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</div><div class=\"line\">　　function f()&#123; </div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　return !this;</div><div class=\"line\">　　&#125; </div><div class=\"line\">　　// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</div></pre></td></tr></table></figure>\n<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f()&#123;</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　this.a = 1;</div><div class=\"line\">　　&#125;;</div><div class=\"line\">　　f();// 报错，this未定义</div></pre></td></tr></table></figure>\n<p>禁止在函数内部遍历调用栈<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f1()&#123;</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　f1.caller; // 报错</div><div class=\"line\">　　　　f1.arguments; // 报错</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　f1();</div></pre></td></tr></table></figure></p>\n<h3 id=\"禁止删除变量\"><a href=\"#禁止删除变量\" class=\"headerlink\" title=\"禁止删除变量\"></a>禁止删除变量</h3><p>严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var x;</div><div class=\"line\">　　delete x; // 语法错误</div><div class=\"line\">　　var o = Object.create(null, &#123;&apos;x&apos;: &#123;</div><div class=\"line\">　　　　　　value: 1,</div><div class=\"line\">　　　　　　configurable: true</div><div class=\"line\">　　&#125;&#125;);</div><div class=\"line\">　　delete o.x; // 删除成功</div></pre></td></tr></table></figure></p>\n<h3 id=\"显式报错\"><a href=\"#显式报错\" class=\"headerlink\" title=\"显式报错\"></a>显式报错</h3><p>正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\"></div><div class=\"line\">　　var o = &#123;&#125;;</div><div class=\"line\">　　Object.defineProperty(o, &quot;v&quot;, &#123; value: 1, writable: false &#125;);</div><div class=\"line\">　　o.v = 2; // 报错</div></pre></td></tr></table></figure></p>\n<h3 id=\"arguments对象的限制\"><a href=\"#arguments对象的限制\" class=\"headerlink\" title=\"arguments对象的限制\"></a>arguments对象的限制</h3><p>arguments不再追踪参数的变化<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function f(a) &#123;</div><div class=\"line\">　　　　a = 2;</div><div class=\"line\">　　　　return [a, arguments[0]];</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　f(1); // 正常模式为[2,2]</div><div class=\"line\">　　function f(a) &#123;</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　a = 2;</div><div class=\"line\">　　　　return [a, arguments[0]];</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　f(1); // 严格模式为[2,1]</div></pre></td></tr></table></figure></p>\n<h3 id=\"禁止使用arguments-callee\"><a href=\"#禁止使用arguments-callee\" class=\"headerlink\" title=\"禁止使用arguments.callee\"></a>禁止使用arguments.callee</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var f = function() &#123; return arguments.callee; &#125;;</div><div class=\"line\">　　f(); // 报错</div></pre></td></tr></table></figure>\n<h3 id=\"重名错误\"><a href=\"#重名错误\" class=\"headerlink\" title=\"重名错误\"></a>重名错误</h3><ul>\n<li><p>对象不能有重名的属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　var o = &#123;</div><div class=\"line\">　　　　p: 1,</div><div class=\"line\">　　　　p: 2</div><div class=\"line\">　　&#125;; // 语法错误</div></pre></td></tr></table></figure>\n</li>\n<li><p>函数不能有重名的参数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　&quot;use strict&quot;;</div><div class=\"line\">　　function f(a, a, b) &#123; // 语法错误</div><div class=\"line\">　　　　return ;</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"函数必须声明在顶层\"><a href=\"#函数必须声明在顶层\" class=\"headerlink\" title=\"函数必须声明在顶层\"></a>函数必须声明在顶层</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">　&quot;use strict&quot;;</div><div class=\"line\">　　if (true) &#123;</div><div class=\"line\">　　　　function f() &#123; &#125; // 语法错误</div><div class=\"line\">　　&#125;</div><div class=\"line\">　　for (var i = 0; i &lt; 5; i++) &#123;</div><div class=\"line\">　　　　function f2() &#123; &#125; // 语法错误</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"保留字\"><a href=\"#保留字\" class=\"headerlink\" title=\"保留字\"></a>保留字</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">　　function package(protected) &#123; // 语法错误</div><div class=\"line\">　　　　&quot;use strict&quot;;</div><div class=\"line\">　　　　var implements; // 语法错误</div><div class=\"line\">　　&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"CSS选择器权值的问题\"><a href=\"#CSS选择器权值的问题\" class=\"headerlink\" title=\"CSS选择器权值的问题\"></a>CSS选择器权值的问题</h2><ol>\n<li><p>内联样式表的权值最高 1000；</p>\n</li>\n<li><p>ID 选择器的权值为 100</p>\n</li>\n<li><p>Class 类选择器的权值为 10</p>\n</li>\n<li><p>HTML 标签选择器的权值为 1</p>\n</li>\n</ol>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ul>\n<li>箭头函数内部没有constructor方法，也没有prototype，所以不支持new操作。但是它对this的处理与一般的普通函数不一样。箭头函数的 this 始终指向<strong>函数定义时的 this</strong>，而非执行时。</li>\n<li>这个this是不会改变指向对象的，我们知道call和apply可以改变this的指向</li>\n</ul>\n<h2 id=\"ajax的封装\"><a href=\"#ajax的封装\" class=\"headerlink\" title=\"ajax的封装\"></a>ajax的封装</h2><h2 id=\"history实现\"><a href=\"#history实现\" class=\"headerlink\" title=\"history实现\"></a>history实现</h2><h3 id=\"存储当前历史记录点\"><a href=\"#存储当前历史记录点\" class=\"headerlink\" title=\"存储当前历史记录点\"></a>存储当前历史记录点</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 当前的url为：http://qianduanblog.com/index.html</div><div class=\"line\">var json=&#123;time:new Date().getTime()&#125;;</div><div class=\"line\">// @状态对象：记录历史记录点的额外对象，可以为空</div><div class=\"line\">// @页面标题：目前所有浏览器都不支持</div><div class=\"line\">// @可选的url：浏览器不会检查url是否存在，只改变url，url必须同域，不能跨域</div><div class=\"line\">window.history.pushState(json,&quot;&quot;,&quot;http://qianduanblog.com/post-1.html&quot;);&lt;/pre&gt;</div><div class=\"line\">执行了pushState方法后，页面的url地址为http://qianduanblog.com/post-1.html。</div></pre></td></tr></table></figure>\n<h3 id=\"替换当前历史记录点\"><a href=\"#替换当前历史记录点\" class=\"headerlink\" title=\"替换当前历史记录点\"></a>替换当前历史记录点</h3><p>window.history.replaceState和window.history.pushState类似，不同之处在于replaceState不会在window.history里新增历史记录点，其效果类似于window.location.replace(url)，都是不会在历史记录点里新增一个记录点的。当你为了响应用户的某些操作，而要更新当前历史记录条目的状态对象或URL时，使用replaceState()方法会特别合适。</p>\n<h3 id=\"监听历史记录点\"><a href=\"#监听历史记录点\" class=\"headerlink\" title=\"监听历史记录点\"></a>监听历史记录点</h3><p>监听历史记录点，直观的可认为是监听URL的变化，但会忽略URL的hash部分，监听URL的hash部分，HTML5有新的API为onhashchange，我的博客里也有说到该方法和跨浏览器的兼容解决方案。可以通过window.onpopstate来监听url的变化，并且可以获取存储在该历史记录点的状态对象，也就是上文说到的json对象，如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 当前的url为：http://qianduanblog.com/post-1.html</div><div class=\"line\">window.onpopstate=function()</div><div class=\"line\">&#123;</div><div class=\"line\">    // 获得存储在该历史记录点的json对象</div><div class=\"line\">    var json=window.history.state;</div><div class=\"line\">    // 点击一次回退到：http://qianduanblog.com/index.html</div><div class=\"line\">    // 获得的json为null</div><div class=\"line\">    // 再点击一次前进到：http://qianduanblog.com/post-1.html</div><div class=\"line\">    // 获得json为&#123;time:1369647895656&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>值得注意的是：javascript脚本执行window.history.pushState和window.history.replaceState不会触发onpopstate事件。</p>\n<p>还有一点注意的是，谷歌浏览器和火狐浏览器在页面第一次打开的反应是不同的，谷歌浏览器奇怪的是回触发onpopstate事件，而火狐浏览器则不会。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">var sum = 0</div><div class=\"line\">function fn(a) &#123;</div><div class=\"line\">    sum = sum + a</div><div class=\"line\">    return function(b) &#123;</div><div class=\"line\">        if(a==0 || b== 0) &#123;</div><div class=\"line\">            return sum</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            return fn(b)</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">fn(2)(3)(4)(0)</div></pre></td></tr></table></figure>\n<h2 id=\"实现一个lazyMan\"><a href=\"#实现一个lazyMan\" class=\"headerlink\" title=\"实现一个lazyMan\"></a>实现一个lazyMan</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">function _LazyMan(n) &#123;</div><div class=\"line\">\tthis.task = []</div><div class=\"line\">\tvar self  = this</div><div class=\"line\">\tvar fn = (function(n) &#123;</div><div class=\"line\">\t\tvar name = n</div><div class=\"line\">\t\treturn function() &#123;</div><div class=\"line\">\t\t\tconsole.log(`HI + $&#123;name&#125;`)</div><div class=\"line\">\t\t\tself.next()</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\tthis.task.push(fn)</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tself.next() </div><div class=\"line\">\t&#125;, 0) //在下一个循环执行任务</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.next = function() &#123;</div><div class=\"line\">\tvar fn = this.tasks.shift()</div><div class=\"line\">\tfn &amp;&amp; fn()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.eat = function(name) &#123;</div><div class=\"line\">\tvar self = this</div><div class=\"line\">\tvar fn = (function(name) &#123;</div><div class=\"line\">\t\treturn function() &#123;</div><div class=\"line\">\t\t\tconsole.log(`eat + $&#123;name&#125;`)</div><div class=\"line\">\t\t\tself.next()</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;)(name)</div><div class=\"line\">\tthis.task.push(fn)</div><div class=\"line\">\treturn this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleep = function(time) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    var fn = (function(time)&#123;</div><div class=\"line\">        return function() &#123;</div><div class=\"line\">            setTimeout(function()&#123;</div><div class=\"line\">                console.log(&quot;Wake up after &quot; + time + &quot;s!&quot;);</div><div class=\"line\">                self.next();</div><div class=\"line\">            &#125;, time * 1000);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)(time);</div><div class=\"line\">    this.tasks.push(fn);</div><div class=\"line\">   return this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">_LazyMan.prototype.sleepFirst = function(time) &#123;</div><div class=\"line\">    var self = this;</div><div class=\"line\">    var fn = (function(time) &#123;</div><div class=\"line\">        return function() &#123;</div><div class=\"line\">            setTimeout(function() &#123;</div><div class=\"line\">                console.log(&quot;Wake up after &quot; + time + &quot;s!&quot;);</div><div class=\"line\">                self.next();</div><div class=\"line\">            &#125;, time * 1000);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)(time);</div><div class=\"line\">    this.tasks.unshift(fn);</div><div class=\"line\">    return this;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function LazyMan(name) &#123;</div><div class=\"line\">\treturn new _LazyMan(name)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"垃圾回收机制原理和方法\"><a href=\"#垃圾回收机制原理和方法\" class=\"headerlink\" title=\"垃圾回收机制原理和方法\"></a>垃圾回收机制原理和方法</h2><p>原理： </p>\n<ul>\n<li>当变量在程序中不再未来的运行中访问的时候</li>\n<li>向这些对象要求归还内存</li>\n</ul>\n<p>方法：</p>\n<ul>\n<li>标记清除法</li>\n<li>引用计数（IE)</li>\n</ul>\n<h2 id=\"随机生成N个m到n的数\"><a href=\"#随机生成N个m到n的数\" class=\"headerlink\" title=\"随机生成N个m到n的数\"></a>随机生成N个m到n的数</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fn(n) &#123;</div><div class=\"line\">    var newArr = []</div><div class=\"line\">    while(n &gt; 0) &#123;</div><div class=\"line\">        var newNumber = Math.floor(Math.random()*31 + 2)</div><div class=\"line\">        if(!newArr.includes(newNumber)) &#123;</div><div class=\"line\">            n --</div><div class=\"line\">            newArr.push(newNumber)</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return Array.from(new Set(newArr))</div><div class=\"line\">&#125;</div><div class=\"line\">fn(10)</div></pre></td></tr></table></figure>\n<h2 id=\"简单动画的实现\"><a href=\"#简单动画的实现\" class=\"headerlink\" title=\"简单动画的实现\"></a>简单动画的实现</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">function animate2(element, endValue, duration) &#123;</div><div class=\"line\">    var startTime = new Date(),</div><div class=\"line\">        startValue = parseInt(element.style.width);</div><div class=\"line\"></div><div class=\"line\">    var timerId = setInterval(function() &#123;</div><div class=\"line\">        // 保证百分率不大于1</div><div class=\"line\">        var percentage = Math.min(1, (new Date - startTime) / duration);</div><div class=\"line\"></div><div class=\"line\">        var stepValue;</div><div class=\"line\">        if (percentage &gt;= 1) &#123;</div><div class=\"line\">            // 保证最终值的准确性</div><div class=\"line\">            stepValue = endValue;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            stepValue = startValue + (endValue - startValue) * percentage;</div><div class=\"line\">        &#125;</div><div class=\"line\">        element.style.width = stepValue + &apos;px&apos;;</div><div class=\"line\"></div><div class=\"line\">        if (percentage &gt;= 1) &#123;</div><div class=\"line\">            clearInterval(timerId);</div><div class=\"line\">            element.innerHTML = new Date - startTime;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;, 13);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">animate2(document.getElementById(&apos;test1&apos;), 200, 1000);</div><div class=\"line\"></div><div class=\"line\">function getTopDistance() &#123;</div><div class=\"line\">    return document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"输入阿拉伯数字，输出对应的中文\"><a href=\"#输入阿拉伯数字，输出对应的中文\" class=\"headerlink\" title=\"输入阿拉伯数字，输出对应的中文\"></a>输入阿拉伯数字，输出对应的中文</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">function fn(n)&#123;</div><div class=\"line\">    if(!/^([1-9]\\d*)/.test(n))&#123;</div><div class=\"line\">        return &apos;非法数据&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var unit = &apos;千百十亿千百十万千百十个&apos;;</div><div class=\"line\">    if(n.length &gt; unit.length)&#123;</div><div class=\"line\">        return &apos;数据过长&apos;;</div><div class=\"line\">    &#125;</div><div class=\"line\">    var newStr = &apos;&apos;;</div><div class=\"line\">    var nlength = n.length;</div><div class=\"line\"></div><div class=\"line\">    unit = unit.substr(unit.length - nlength);</div><div class=\"line\"></div><div class=\"line\">    for(var i = 0; i &lt; nlength; i++)&#123;</div><div class=\"line\">        newStr += &apos;零一二三四五六七八九&apos;.charAt(n[i]) + unit.charAt(i);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    newStr = newStr.substr(0,newStr.length-1);</div><div class=\"line\">    newStr = newStr.replace(/零(千|百|十)/g,&apos;零&apos;).replace(/(零)+/g,&apos;零&apos;).replace(/零(亿|万)/g,&apos;$1&apos;);</div><div class=\"line\">    return newStr;</div><div class=\"line\">&#125;</div><div class=\"line\">console.log(fn(&apos;2103&apos;));</div></pre></td></tr></table></figure>\n<h2 id=\"写一个函数实现一个最大并发数量，limitLoad-urls-handler-limit\"><a href=\"#写一个函数实现一个最大并发数量，limitLoad-urls-handler-limit\" class=\"headerlink\" title=\"写一个函数实现一个最大并发数量，limitLoad(urls, handler, limit)\"></a>写一个函数实现一个最大并发数量，limitLoad(urls, handler, limit)</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">//单一请求并发请求四次。采用递归，执行完一个，开入口</div><div class=\"line\"></div><div class=\"line\">let urls = [&apos;1.png&apos;, &apos;2.png&apos;, &apos;3.png&apos;, &apos;4.png&apos;]</div><div class=\"line\"></div><div class=\"line\">limitLoad(urls, loadImg, 2)</div><div class=\"line\"></div><div class=\"line\">const limitLoad = (urls, handler, limit) =&gt; &#123;</div><div class=\"line\"></div><div class=\"line\">    const squence = [].concat(urls)</div><div class=\"line\">    const promises = []</div><div class=\"line\">    let count = 0</div><div class=\"line\"></div><div class=\"line\">    const load = () =&gt; &#123;</div><div class=\"line\">        if(squence.length &lt;= 0 ||  count &gt; limit) return </div><div class=\"line\">        count += 1</div><div class=\"line\">        return handler(squence.shift())</div><div class=\"line\">            .catch(err =&gt; &#123;</div><div class=\"line\">                console.error(err)</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .then(() =&gt; &#123;</div><div class=\"line\">                count -= 1</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .then(load())</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    for(let i = 0; i &lt; limit &amp;&amp; i &lt; sequence.length; i++)&#123;</div><div class=\"line\">        promises.push(load())</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return Promise.all(promises)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function loadImg(url) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">        var image = new Image()</div><div class=\"line\">        image.onload = () =&gt; &#123;</div><div class=\"line\">            resolve()</div><div class=\"line\">        &#125;</div><div class=\"line\">        img.onerror = reject</div><div class=\"line\">        img.src = url</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"for .. of","type":"categories","_content":"\n### 让我们先来比较for..of 和for in， forEach区别\n\n```\n\t//本质在于只要具有[Symbol.iterator]对象，都可以用for..of\n\n\tfor..of  //可以遍历Map，Set，类数组 可break，continue, Object不能遍历， 遍历数组是值，不是索引 \n\n\tfor .. in //遍历对象,主要是继承的属性也会被遍历出来，可break，continue， 遍历数组的时候是下标，非值\n\n\tforEach //不可break continue\n\t\n```\n\n### 既然谈到了for..of，接下来再来深入谈谈iterator\n\n```\n\t1. iterator的简单实现，就是创建一个指针对象，然后调用他的next方法，直到数据结构结束的位置\n\n\teg:\n\n\t\tvar it = makeIterator([2,3])\n\n\t\tfunction makeIterator(arr) {\n\t\t\treturn {\n\t\t\t\tnextIndex: 0,\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn this.nextIndex < arr.length ? {value: arr[this.nextIndex++], done: false} : {value: undefined, done: true}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t//generator函数也具有iterator特性\n\tfunction* fibonacci() { // a generator function\n\t    let [prev, curr] = [1, 1];\n\t    while (true) {\n\t    \t[prev, curr] = [curr, prev + curr];\n\t    \tyield curr;\n\t    }\n\t}\n\n\tfor (let n of fibonacci()) {\n\t    console.log(n);\n\t    // truncate the sequence at 10\n\t    if (n >= 10) {\n\t    \tbreak;\n\t    }\n\t}\n```","source":"_posts/js/es6/for..of.md","raw":"---\ntitle: for .. of\ntype: \"categories\"\ncategories: [前端, JS, ES6]\n---\n\n### 让我们先来比较for..of 和for in， forEach区别\n\n```\n\t//本质在于只要具有[Symbol.iterator]对象，都可以用for..of\n\n\tfor..of  //可以遍历Map，Set，类数组 可break，continue, Object不能遍历， 遍历数组是值，不是索引 \n\n\tfor .. in //遍历对象,主要是继承的属性也会被遍历出来，可break，continue， 遍历数组的时候是下标，非值\n\n\tforEach //不可break continue\n\t\n```\n\n### 既然谈到了for..of，接下来再来深入谈谈iterator\n\n```\n\t1. iterator的简单实现，就是创建一个指针对象，然后调用他的next方法，直到数据结构结束的位置\n\n\teg:\n\n\t\tvar it = makeIterator([2,3])\n\n\t\tfunction makeIterator(arr) {\n\t\t\treturn {\n\t\t\t\tnextIndex: 0,\n\t\t\t\tnext: function() {\n\t\t\t\t\treturn this.nextIndex < arr.length ? {value: arr[this.nextIndex++], done: false} : {value: undefined, done: true}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t//generator函数也具有iterator特性\n\tfunction* fibonacci() { // a generator function\n\t    let [prev, curr] = [1, 1];\n\t    while (true) {\n\t    \t[prev, curr] = [curr, prev + curr];\n\t    \tyield curr;\n\t    }\n\t}\n\n\tfor (let n of fibonacci()) {\n\t    console.log(n);\n\t    // truncate the sequence at 10\n\t    if (n >= 10) {\n\t    \tbreak;\n\t    }\n\t}\n```","slug":"js-es6-for-of","published":1,"date":"2017-04-23T10:51:38.000Z","updated":"2017-04-23T10:51:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgu0034kzy62a8ykhvb","content":"<h3 id=\"让我们先来比较for-of-和for-in，-forEach区别\"><a href=\"#让我们先来比较for-of-和for-in，-forEach区别\" class=\"headerlink\" title=\"让我们先来比较for..of 和for in， forEach区别\"></a>让我们先来比较for..of 和for in， forEach区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//本质在于只要具有[Symbol.iterator]对象，都可以用for..of</div><div class=\"line\"></div><div class=\"line\">for..of  //可以遍历Map，Set，类数组 可break，continue, Object不能遍历， 遍历数组是值，不是索引 </div><div class=\"line\"></div><div class=\"line\">for .. in //遍历对象,主要是继承的属性也会被遍历出来，可break，continue， 遍历数组的时候是下标，非值</div><div class=\"line\"></div><div class=\"line\">forEach //不可break continue</div></pre></td></tr></table></figure>\n<h3 id=\"既然谈到了for-of，接下来再来深入谈谈iterator\"><a href=\"#既然谈到了for-of，接下来再来深入谈谈iterator\" class=\"headerlink\" title=\"既然谈到了for..of，接下来再来深入谈谈iterator\"></a>既然谈到了for..of，接下来再来深入谈谈iterator</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. iterator的简单实现，就是创建一个指针对象，然后调用他的next方法，直到数据结构结束的位置</div><div class=\"line\"></div><div class=\"line\">eg:</div><div class=\"line\"></div><div class=\"line\">\tvar it = makeIterator([2,3])</div><div class=\"line\"></div><div class=\"line\">\tfunction makeIterator(arr) &#123;</div><div class=\"line\">\t\treturn &#123;</div><div class=\"line\">\t\t\tnextIndex: 0,</div><div class=\"line\">\t\t\tnext: function() &#123;</div><div class=\"line\">\t\t\t\treturn this.nextIndex &lt; arr.length ? &#123;value: arr[this.nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//generator函数也具有iterator特性</div><div class=\"line\">function* fibonacci() &#123; // a generator function</div><div class=\"line\">    let [prev, curr] = [1, 1];</div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">    \t[prev, curr] = [curr, prev + curr];</div><div class=\"line\">    \tyield curr;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for (let n of fibonacci()) &#123;</div><div class=\"line\">    console.log(n);</div><div class=\"line\">    // truncate the sequence at 10</div><div class=\"line\">    if (n &gt;= 10) &#123;</div><div class=\"line\">    \tbreak;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"让我们先来比较for-of-和for-in，-forEach区别\"><a href=\"#让我们先来比较for-of-和for-in，-forEach区别\" class=\"headerlink\" title=\"让我们先来比较for..of 和for in， forEach区别\"></a>让我们先来比较for..of 和for in， forEach区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">//本质在于只要具有[Symbol.iterator]对象，都可以用for..of</div><div class=\"line\"></div><div class=\"line\">for..of  //可以遍历Map，Set，类数组 可break，continue, Object不能遍历， 遍历数组是值，不是索引 </div><div class=\"line\"></div><div class=\"line\">for .. in //遍历对象,主要是继承的属性也会被遍历出来，可break，continue， 遍历数组的时候是下标，非值</div><div class=\"line\"></div><div class=\"line\">forEach //不可break continue</div></pre></td></tr></table></figure>\n<h3 id=\"既然谈到了for-of，接下来再来深入谈谈iterator\"><a href=\"#既然谈到了for-of，接下来再来深入谈谈iterator\" class=\"headerlink\" title=\"既然谈到了for..of，接下来再来深入谈谈iterator\"></a>既然谈到了for..of，接下来再来深入谈谈iterator</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. iterator的简单实现，就是创建一个指针对象，然后调用他的next方法，直到数据结构结束的位置</div><div class=\"line\"></div><div class=\"line\">eg:</div><div class=\"line\"></div><div class=\"line\">\tvar it = makeIterator([2,3])</div><div class=\"line\"></div><div class=\"line\">\tfunction makeIterator(arr) &#123;</div><div class=\"line\">\t\treturn &#123;</div><div class=\"line\">\t\t\tnextIndex: 0,</div><div class=\"line\">\t\t\tnext: function() &#123;</div><div class=\"line\">\t\t\t\treturn this.nextIndex &lt; arr.length ? &#123;value: arr[this.nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">//generator函数也具有iterator特性</div><div class=\"line\">function* fibonacci() &#123; // a generator function</div><div class=\"line\">    let [prev, curr] = [1, 1];</div><div class=\"line\">    while (true) &#123;</div><div class=\"line\">    \t[prev, curr] = [curr, prev + curr];</div><div class=\"line\">    \tyield curr;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for (let n of fibonacci()) &#123;</div><div class=\"line\">    console.log(n);</div><div class=\"line\">    // truncate the sequence at 10</div><div class=\"line\">    if (n &gt;= 10) &#123;</div><div class=\"line\">    \tbreak;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"单一设计原则","type":"categories","_content":"\n### The Single Responsibility Principle\n```\npush products to cart：\n    //solove events functions：1.Event, In order to create handler，2.EventAggregator, In order to create publish and subscribe;\n\n        function Event(name) {\n            var handlers = [];\n            this.getName = function() {\n                return name;\n            };\n            this.addHandler = function(handler) {\n                handlers.push(handler)\n            };\n            this.removeHandler = function(handlerName) {\n                for(var i=0 ; i<handlers.length; i++) {\n                    if(handlers[handler] === handlerName) {\n                        handlers.splice(i,1);\n                    }\n                }\n            }\n            this.fire = function(eventArgs) {\n                handlers.forEach(function(h){\n                    h(eventArgs);\n                }\n            }\n        }\n\n        function EventAggregator() {\n            var events = [];\n            this.getEvent = function(eventName) {\n                $.grep(events, function(event) {\n                    return event.getName() === eventName\n                })[0]\n            }\n            this.publish = function(eventName, eventargs) {\n                var event = getEvent(eventName)\n                if(!event) {\n                    event = new Event(eventName)\n                }\n                event.fire(eventargs)\n            }\n            this.subcribe = function (eventName, handler) {\n                var event = getEvent(eventName)\n                if(!event) {\n                    event = new event(eventName)\n                    events.push(event)\n                }\n                event.addHandler(event)\n            }\n            \n            \n        }\n\n        //prodouct object\n        function product(id, description) {//\n            this.getId = function() {\n                return id\n            }\n        }\n\n        //cart object\n        function cart(eventAggregator, items = []) {\n            this.addItem = function(item) {\n                items.push[item];\n                eventAggregator.pushlish('itemAdd', item);\n            }\n        }\n\n        function CartController(cart, eventAggregator) {\n\n            eventAggregator.subcribe(\"itemAdd\", function(eventArgs){\n\n                var newItem = $('<li></li>').html(eventArgs.getDescription()).attr('id-cart', eventArgs.getId()).appendTo(\"#cart\");\n            });\n\n                eventAggregator.subscribe(\"productSelected\", function (eventArgs) {\n                    cart.addItem(eventArgs.product);\n                })\n        })\n\n        function ProductRepository() {//service\n            var products = [\n                new Product(1, \"wwwwp\"),\n                new Product(2, \"Bafgfg\"),\n                new Product(3, \"ppppp\")];\n            ];\n            this.getProducts = function () {\n                return products;\n            }\n        }\n\n        function ProductController(eventAggregator, ProductRepository) {\n            var products = ProductRepository.getProucts()\n            function onProductSelected() {\n                var productId = $(this).attr(id);\n                var products = $.grep(products, function(x){\n                    return x.getId == productId;\n                }\n                eventAggregator.publish('productSelected',{\n                    product: product\n                });\n            }\n            products.forEach(function(product){\n                var newItem =$('<li></li>').html(product.getDescription()).attr('id', product.getId()).attr('id', product.getId()).dbclick(onProductSelected).appendTo(\"#products\")\n                \n            })\n        })\n        \n        //finally\n\n        (function () {\n            var eventAggregator = new EventAggregator(),\n            cart = new Cart(eventAggregator),\n            cartController = new CartController(cart, eventAggregator),\n            productRepository = new ProductRepository(),\n            productController = new ProductController(eventAggregator, productRepository);\n        })();\n    \n```","source":"_posts/js/designPattern/单一设计原则.md","raw":"---\ntitle: 单一设计原则\ntype: \"categories\"\ncategories: [前端, JS, 设计模式]\n---\n\n### The Single Responsibility Principle\n```\npush products to cart：\n    //solove events functions：1.Event, In order to create handler，2.EventAggregator, In order to create publish and subscribe;\n\n        function Event(name) {\n            var handlers = [];\n            this.getName = function() {\n                return name;\n            };\n            this.addHandler = function(handler) {\n                handlers.push(handler)\n            };\n            this.removeHandler = function(handlerName) {\n                for(var i=0 ; i<handlers.length; i++) {\n                    if(handlers[handler] === handlerName) {\n                        handlers.splice(i,1);\n                    }\n                }\n            }\n            this.fire = function(eventArgs) {\n                handlers.forEach(function(h){\n                    h(eventArgs);\n                }\n            }\n        }\n\n        function EventAggregator() {\n            var events = [];\n            this.getEvent = function(eventName) {\n                $.grep(events, function(event) {\n                    return event.getName() === eventName\n                })[0]\n            }\n            this.publish = function(eventName, eventargs) {\n                var event = getEvent(eventName)\n                if(!event) {\n                    event = new Event(eventName)\n                }\n                event.fire(eventargs)\n            }\n            this.subcribe = function (eventName, handler) {\n                var event = getEvent(eventName)\n                if(!event) {\n                    event = new event(eventName)\n                    events.push(event)\n                }\n                event.addHandler(event)\n            }\n            \n            \n        }\n\n        //prodouct object\n        function product(id, description) {//\n            this.getId = function() {\n                return id\n            }\n        }\n\n        //cart object\n        function cart(eventAggregator, items = []) {\n            this.addItem = function(item) {\n                items.push[item];\n                eventAggregator.pushlish('itemAdd', item);\n            }\n        }\n\n        function CartController(cart, eventAggregator) {\n\n            eventAggregator.subcribe(\"itemAdd\", function(eventArgs){\n\n                var newItem = $('<li></li>').html(eventArgs.getDescription()).attr('id-cart', eventArgs.getId()).appendTo(\"#cart\");\n            });\n\n                eventAggregator.subscribe(\"productSelected\", function (eventArgs) {\n                    cart.addItem(eventArgs.product);\n                })\n        })\n\n        function ProductRepository() {//service\n            var products = [\n                new Product(1, \"wwwwp\"),\n                new Product(2, \"Bafgfg\"),\n                new Product(3, \"ppppp\")];\n            ];\n            this.getProducts = function () {\n                return products;\n            }\n        }\n\n        function ProductController(eventAggregator, ProductRepository) {\n            var products = ProductRepository.getProucts()\n            function onProductSelected() {\n                var productId = $(this).attr(id);\n                var products = $.grep(products, function(x){\n                    return x.getId == productId;\n                }\n                eventAggregator.publish('productSelected',{\n                    product: product\n                });\n            }\n            products.forEach(function(product){\n                var newItem =$('<li></li>').html(product.getDescription()).attr('id', product.getId()).attr('id', product.getId()).dbclick(onProductSelected).appendTo(\"#products\")\n                \n            })\n        })\n        \n        //finally\n\n        (function () {\n            var eventAggregator = new EventAggregator(),\n            cart = new Cart(eventAggregator),\n            cartController = new CartController(cart, eventAggregator),\n            productRepository = new ProductRepository(),\n            productController = new ProductController(eventAggregator, productRepository);\n        })();\n    \n```","slug":"js-designPattern-单一设计原则","published":1,"date":"2017-04-23T11:06:23.000Z","updated":"2017-04-23T11:06:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgv0036kzy6fysa2lgc","content":"<h3 id=\"The-Single-Responsibility-Principle\"><a href=\"#The-Single-Responsibility-Principle\" class=\"headerlink\" title=\"The Single Responsibility Principle\"></a>The Single Responsibility Principle</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">push products to cart：</div><div class=\"line\">    //solove events functions：1.Event, In order to create handler，2.EventAggregator, In order to create publish and subscribe;</div><div class=\"line\"></div><div class=\"line\">        function Event(name) &#123;</div><div class=\"line\">            var handlers = [];</div><div class=\"line\">            this.getName = function() &#123;</div><div class=\"line\">                return name;</div><div class=\"line\">            &#125;;</div><div class=\"line\">            this.addHandler = function(handler) &#123;</div><div class=\"line\">                handlers.push(handler)</div><div class=\"line\">            &#125;;</div><div class=\"line\">            this.removeHandler = function(handlerName) &#123;</div><div class=\"line\">                for(var i=0 ; i&lt;handlers.length; i++) &#123;</div><div class=\"line\">                    if(handlers[handler] === handlerName) &#123;</div><div class=\"line\">                        handlers.splice(i,1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            this.fire = function(eventArgs) &#123;</div><div class=\"line\">                handlers.forEach(function(h)&#123;</div><div class=\"line\">                    h(eventArgs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        function EventAggregator() &#123;</div><div class=\"line\">            var events = [];</div><div class=\"line\">            this.getEvent = function(eventName) &#123;</div><div class=\"line\">                $.grep(events, function(event) &#123;</div><div class=\"line\">                    return event.getName() === eventName</div><div class=\"line\">                &#125;)[0]</div><div class=\"line\">            &#125;</div><div class=\"line\">            this.publish = function(eventName, eventargs) &#123;</div><div class=\"line\">                var event = getEvent(eventName)</div><div class=\"line\">                if(!event) &#123;</div><div class=\"line\">                    event = new Event(eventName)</div><div class=\"line\">                &#125;</div><div class=\"line\">                event.fire(eventargs)</div><div class=\"line\">            &#125;</div><div class=\"line\">            this.subcribe = function (eventName, handler) &#123;</div><div class=\"line\">                var event = getEvent(eventName)</div><div class=\"line\">                if(!event) &#123;</div><div class=\"line\">                    event = new event(eventName)</div><div class=\"line\">                    events.push(event)</div><div class=\"line\">                &#125;</div><div class=\"line\">                event.addHandler(event)</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //prodouct object</div><div class=\"line\">        function product(id, description) &#123;//</div><div class=\"line\">            this.getId = function() &#123;</div><div class=\"line\">                return id</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //cart object</div><div class=\"line\">        function cart(eventAggregator, items = []) &#123;</div><div class=\"line\">            this.addItem = function(item) &#123;</div><div class=\"line\">                items.push[item];</div><div class=\"line\">                eventAggregator.pushlish(&apos;itemAdd&apos;, item);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        function CartController(cart, eventAggregator) &#123;</div><div class=\"line\"></div><div class=\"line\">            eventAggregator.subcribe(&quot;itemAdd&quot;, function(eventArgs)&#123;</div><div class=\"line\"></div><div class=\"line\">                var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(eventArgs.getDescription()).attr(&apos;id-cart&apos;, eventArgs.getId()).appendTo(&quot;#cart&quot;);</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">                eventAggregator.subscribe(&quot;productSelected&quot;, function (eventArgs) &#123;</div><div class=\"line\">                    cart.addItem(eventArgs.product);</div><div class=\"line\">                &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\"></div><div class=\"line\">        function ProductRepository() &#123;//service</div><div class=\"line\">            var products = [</div><div class=\"line\">                new Product(1, &quot;wwwwp&quot;),</div><div class=\"line\">                new Product(2, &quot;Bafgfg&quot;),</div><div class=\"line\">                new Product(3, &quot;ppppp&quot;)];</div><div class=\"line\">            ];</div><div class=\"line\">            this.getProducts = function () &#123;</div><div class=\"line\">                return products;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        function ProductController(eventAggregator, ProductRepository) &#123;</div><div class=\"line\">            var products = ProductRepository.getProucts()</div><div class=\"line\">            function onProductSelected() &#123;</div><div class=\"line\">                var productId = $(this).attr(id);</div><div class=\"line\">                var products = $.grep(products, function(x)&#123;</div><div class=\"line\">                    return x.getId == productId;</div><div class=\"line\">                &#125;</div><div class=\"line\">                eventAggregator.publish(&apos;productSelected&apos;,&#123;</div><div class=\"line\">                    product: product</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            products.forEach(function(product)&#123;</div><div class=\"line\">                var newItem =$(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(product.getDescription()).attr(&apos;id&apos;, product.getId()).attr(&apos;id&apos;, product.getId()).dbclick(onProductSelected).appendTo(&quot;#products&quot;)</div><div class=\"line\">                </div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\">        </div><div class=\"line\">        //finally</div><div class=\"line\"></div><div class=\"line\">        (function () &#123;</div><div class=\"line\">            var eventAggregator = new EventAggregator(),</div><div class=\"line\">            cart = new Cart(eventAggregator),</div><div class=\"line\">            cartController = new CartController(cart, eventAggregator),</div><div class=\"line\">            productRepository = new ProductRepository(),</div><div class=\"line\">            productController = new ProductController(eventAggregator, productRepository);</div><div class=\"line\">        &#125;)();</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"The-Single-Responsibility-Principle\"><a href=\"#The-Single-Responsibility-Principle\" class=\"headerlink\" title=\"The Single Responsibility Principle\"></a>The Single Responsibility Principle</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div></pre></td><td class=\"code\"><pre><div class=\"line\">push products to cart：</div><div class=\"line\">    //solove events functions：1.Event, In order to create handler，2.EventAggregator, In order to create publish and subscribe;</div><div class=\"line\"></div><div class=\"line\">        function Event(name) &#123;</div><div class=\"line\">            var handlers = [];</div><div class=\"line\">            this.getName = function() &#123;</div><div class=\"line\">                return name;</div><div class=\"line\">            &#125;;</div><div class=\"line\">            this.addHandler = function(handler) &#123;</div><div class=\"line\">                handlers.push(handler)</div><div class=\"line\">            &#125;;</div><div class=\"line\">            this.removeHandler = function(handlerName) &#123;</div><div class=\"line\">                for(var i=0 ; i&lt;handlers.length; i++) &#123;</div><div class=\"line\">                    if(handlers[handler] === handlerName) &#123;</div><div class=\"line\">                        handlers.splice(i,1);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            this.fire = function(eventArgs) &#123;</div><div class=\"line\">                handlers.forEach(function(h)&#123;</div><div class=\"line\">                    h(eventArgs);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        function EventAggregator() &#123;</div><div class=\"line\">            var events = [];</div><div class=\"line\">            this.getEvent = function(eventName) &#123;</div><div class=\"line\">                $.grep(events, function(event) &#123;</div><div class=\"line\">                    return event.getName() === eventName</div><div class=\"line\">                &#125;)[0]</div><div class=\"line\">            &#125;</div><div class=\"line\">            this.publish = function(eventName, eventargs) &#123;</div><div class=\"line\">                var event = getEvent(eventName)</div><div class=\"line\">                if(!event) &#123;</div><div class=\"line\">                    event = new Event(eventName)</div><div class=\"line\">                &#125;</div><div class=\"line\">                event.fire(eventargs)</div><div class=\"line\">            &#125;</div><div class=\"line\">            this.subcribe = function (eventName, handler) &#123;</div><div class=\"line\">                var event = getEvent(eventName)</div><div class=\"line\">                if(!event) &#123;</div><div class=\"line\">                    event = new event(eventName)</div><div class=\"line\">                    events.push(event)</div><div class=\"line\">                &#125;</div><div class=\"line\">                event.addHandler(event)</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //prodouct object</div><div class=\"line\">        function product(id, description) &#123;//</div><div class=\"line\">            this.getId = function() &#123;</div><div class=\"line\">                return id</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        //cart object</div><div class=\"line\">        function cart(eventAggregator, items = []) &#123;</div><div class=\"line\">            this.addItem = function(item) &#123;</div><div class=\"line\">                items.push[item];</div><div class=\"line\">                eventAggregator.pushlish(&apos;itemAdd&apos;, item);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        function CartController(cart, eventAggregator) &#123;</div><div class=\"line\"></div><div class=\"line\">            eventAggregator.subcribe(&quot;itemAdd&quot;, function(eventArgs)&#123;</div><div class=\"line\"></div><div class=\"line\">                var newItem = $(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(eventArgs.getDescription()).attr(&apos;id-cart&apos;, eventArgs.getId()).appendTo(&quot;#cart&quot;);</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">                eventAggregator.subscribe(&quot;productSelected&quot;, function (eventArgs) &#123;</div><div class=\"line\">                    cart.addItem(eventArgs.product);</div><div class=\"line\">                &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\"></div><div class=\"line\">        function ProductRepository() &#123;//service</div><div class=\"line\">            var products = [</div><div class=\"line\">                new Product(1, &quot;wwwwp&quot;),</div><div class=\"line\">                new Product(2, &quot;Bafgfg&quot;),</div><div class=\"line\">                new Product(3, &quot;ppppp&quot;)];</div><div class=\"line\">            ];</div><div class=\"line\">            this.getProducts = function () &#123;</div><div class=\"line\">                return products;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        function ProductController(eventAggregator, ProductRepository) &#123;</div><div class=\"line\">            var products = ProductRepository.getProucts()</div><div class=\"line\">            function onProductSelected() &#123;</div><div class=\"line\">                var productId = $(this).attr(id);</div><div class=\"line\">                var products = $.grep(products, function(x)&#123;</div><div class=\"line\">                    return x.getId == productId;</div><div class=\"line\">                &#125;</div><div class=\"line\">                eventAggregator.publish(&apos;productSelected&apos;,&#123;</div><div class=\"line\">                    product: product</div><div class=\"line\">                &#125;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            products.forEach(function(product)&#123;</div><div class=\"line\">                var newItem =$(&apos;&lt;li&gt;&lt;/li&gt;&apos;).html(product.getDescription()).attr(&apos;id&apos;, product.getId()).attr(&apos;id&apos;, product.getId()).dbclick(onProductSelected).appendTo(&quot;#products&quot;)</div><div class=\"line\">                </div><div class=\"line\">            &#125;)</div><div class=\"line\">        &#125;)</div><div class=\"line\">        </div><div class=\"line\">        //finally</div><div class=\"line\"></div><div class=\"line\">        (function () &#123;</div><div class=\"line\">            var eventAggregator = new EventAggregator(),</div><div class=\"line\">            cart = new Cart(eventAggregator),</div><div class=\"line\">            cartController = new CartController(cart, eventAggregator),</div><div class=\"line\">            productRepository = new ProductRepository(),</div><div class=\"line\">            productController = new ProductController(eventAggregator, productRepository);</div><div class=\"line\">        &#125;)();</div></pre></td></tr></table></figure>"},{"title":"ES6 Symbol","type":"categories","_content":"\n### Symbol的由来\n\n保证对象的属性不重复\n\n#### Symbol 类型(有点类似于字符串)\n\n```\nlet sys = Symbol('test')\ntypeof sys  //\"symbol\"\n```\n#### Symbol的比较\n\n```\nlet sys = Symbol('test')\nlet ss = Symbol('test')\nsys === ss //false\n\nlet r = Symbol()\nlet ss = Symbol()\nr === ss  //false\n\n结论： Symbol函数的参数只是表示对当前 Symbol 值的描述\n\n```\n#### symbol与其他类型的不同点\n\n```\nlet sys = Symbol('test')\nsys + 222  //TypeError //不能隐式的其他的函数进行运算\n\nBoolean(sys) // true\nString(sys) // \"Symbol(test)\"\nNumber(sys)  //TypeError\n\n//显示转换只有Number报错\n\n```\n### 作为属性名的Symbol\n\n```\n为了保证属性不重复，如此定义\n\nlet sys = Symbol('prop1')\nlet obj = {\n\t[sys]: 'name'\n}\nobj[sys]\n```\n\n#### 使用\n```\n//switch中的常量不等\n\nconst COLOR_RED    = Symbol();\nconst COLOR_GREEN  = Symbol();\n\nfunction getComplement(color) {\n  switch (color) {\n    case COLOR_RED:\n      return COLOR_GREEN;\n    case COLOR_GREEN:\n      return COLOR_RED;\n    default:\n      throw new Error('Undefined color');\n    }\n}\n\n```\n","source":"_posts/js/es6/Symbol.md","raw":"---\ntitle: ES6 Symbol\ntype: \"categories\"\ncategories: [前端, JS, ES6]\n---\n\n### Symbol的由来\n\n保证对象的属性不重复\n\n#### Symbol 类型(有点类似于字符串)\n\n```\nlet sys = Symbol('test')\ntypeof sys  //\"symbol\"\n```\n#### Symbol的比较\n\n```\nlet sys = Symbol('test')\nlet ss = Symbol('test')\nsys === ss //false\n\nlet r = Symbol()\nlet ss = Symbol()\nr === ss  //false\n\n结论： Symbol函数的参数只是表示对当前 Symbol 值的描述\n\n```\n#### symbol与其他类型的不同点\n\n```\nlet sys = Symbol('test')\nsys + 222  //TypeError //不能隐式的其他的函数进行运算\n\nBoolean(sys) // true\nString(sys) // \"Symbol(test)\"\nNumber(sys)  //TypeError\n\n//显示转换只有Number报错\n\n```\n### 作为属性名的Symbol\n\n```\n为了保证属性不重复，如此定义\n\nlet sys = Symbol('prop1')\nlet obj = {\n\t[sys]: 'name'\n}\nobj[sys]\n```\n\n#### 使用\n```\n//switch中的常量不等\n\nconst COLOR_RED    = Symbol();\nconst COLOR_GREEN  = Symbol();\n\nfunction getComplement(color) {\n  switch (color) {\n    case COLOR_RED:\n      return COLOR_GREEN;\n    case COLOR_GREEN:\n      return COLOR_RED;\n    default:\n      throw new Error('Undefined color');\n    }\n}\n\n```\n","slug":"js-es6-Symbol","published":1,"date":"2017-04-23T10:51:47.000Z","updated":"2017-04-23T10:51:47.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgw0037kzy6yi12pcul","content":"<h3 id=\"Symbol的由来\"><a href=\"#Symbol的由来\" class=\"headerlink\" title=\"Symbol的由来\"></a>Symbol的由来</h3><p>保证对象的属性不重复</p>\n<h4 id=\"Symbol-类型-有点类似于字符串\"><a href=\"#Symbol-类型-有点类似于字符串\" class=\"headerlink\" title=\"Symbol 类型(有点类似于字符串)\"></a>Symbol 类型(有点类似于字符串)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sys = Symbol(&apos;test&apos;)</div><div class=\"line\">typeof sys  //&quot;symbol&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"Symbol的比较\"><a href=\"#Symbol的比较\" class=\"headerlink\" title=\"Symbol的比较\"></a>Symbol的比较</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sys = Symbol(&apos;test&apos;)</div><div class=\"line\">let ss = Symbol(&apos;test&apos;)</div><div class=\"line\">sys === ss //false</div><div class=\"line\"></div><div class=\"line\">let r = Symbol()</div><div class=\"line\">let ss = Symbol()</div><div class=\"line\">r === ss  //false</div><div class=\"line\"></div><div class=\"line\">结论： Symbol函数的参数只是表示对当前 Symbol 值的描述</div></pre></td></tr></table></figure>\n<h4 id=\"symbol与其他类型的不同点\"><a href=\"#symbol与其他类型的不同点\" class=\"headerlink\" title=\"symbol与其他类型的不同点\"></a>symbol与其他类型的不同点</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sys = Symbol(&apos;test&apos;)</div><div class=\"line\">sys + 222  //TypeError //不能隐式的其他的函数进行运算</div><div class=\"line\"></div><div class=\"line\">Boolean(sys) // true</div><div class=\"line\">String(sys) // &quot;Symbol(test)&quot;</div><div class=\"line\">Number(sys)  //TypeError</div><div class=\"line\"></div><div class=\"line\">//显示转换只有Number报错</div></pre></td></tr></table></figure>\n<h3 id=\"作为属性名的Symbol\"><a href=\"#作为属性名的Symbol\" class=\"headerlink\" title=\"作为属性名的Symbol\"></a>作为属性名的Symbol</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">为了保证属性不重复，如此定义</div><div class=\"line\"></div><div class=\"line\">let sys = Symbol(&apos;prop1&apos;)</div><div class=\"line\">let obj = &#123;</div><div class=\"line\">\t[sys]: &apos;name&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">obj[sys]</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//switch中的常量不等</div><div class=\"line\"></div><div class=\"line\">const COLOR_RED    = Symbol();</div><div class=\"line\">const COLOR_GREEN  = Symbol();</div><div class=\"line\"></div><div class=\"line\">function getComplement(color) &#123;</div><div class=\"line\">  switch (color) &#123;</div><div class=\"line\">    case COLOR_RED:</div><div class=\"line\">      return COLOR_GREEN;</div><div class=\"line\">    case COLOR_GREEN:</div><div class=\"line\">      return COLOR_RED;</div><div class=\"line\">    default:</div><div class=\"line\">      throw new Error(&apos;Undefined color&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Symbol的由来\"><a href=\"#Symbol的由来\" class=\"headerlink\" title=\"Symbol的由来\"></a>Symbol的由来</h3><p>保证对象的属性不重复</p>\n<h4 id=\"Symbol-类型-有点类似于字符串\"><a href=\"#Symbol-类型-有点类似于字符串\" class=\"headerlink\" title=\"Symbol 类型(有点类似于字符串)\"></a>Symbol 类型(有点类似于字符串)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sys = Symbol(&apos;test&apos;)</div><div class=\"line\">typeof sys  //&quot;symbol&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"Symbol的比较\"><a href=\"#Symbol的比较\" class=\"headerlink\" title=\"Symbol的比较\"></a>Symbol的比较</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sys = Symbol(&apos;test&apos;)</div><div class=\"line\">let ss = Symbol(&apos;test&apos;)</div><div class=\"line\">sys === ss //false</div><div class=\"line\"></div><div class=\"line\">let r = Symbol()</div><div class=\"line\">let ss = Symbol()</div><div class=\"line\">r === ss  //false</div><div class=\"line\"></div><div class=\"line\">结论： Symbol函数的参数只是表示对当前 Symbol 值的描述</div></pre></td></tr></table></figure>\n<h4 id=\"symbol与其他类型的不同点\"><a href=\"#symbol与其他类型的不同点\" class=\"headerlink\" title=\"symbol与其他类型的不同点\"></a>symbol与其他类型的不同点</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">let sys = Symbol(&apos;test&apos;)</div><div class=\"line\">sys + 222  //TypeError //不能隐式的其他的函数进行运算</div><div class=\"line\"></div><div class=\"line\">Boolean(sys) // true</div><div class=\"line\">String(sys) // &quot;Symbol(test)&quot;</div><div class=\"line\">Number(sys)  //TypeError</div><div class=\"line\"></div><div class=\"line\">//显示转换只有Number报错</div></pre></td></tr></table></figure>\n<h3 id=\"作为属性名的Symbol\"><a href=\"#作为属性名的Symbol\" class=\"headerlink\" title=\"作为属性名的Symbol\"></a>作为属性名的Symbol</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">为了保证属性不重复，如此定义</div><div class=\"line\"></div><div class=\"line\">let sys = Symbol(&apos;prop1&apos;)</div><div class=\"line\">let obj = &#123;</div><div class=\"line\">\t[sys]: &apos;name&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">obj[sys]</div></pre></td></tr></table></figure>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">//switch中的常量不等</div><div class=\"line\"></div><div class=\"line\">const COLOR_RED    = Symbol();</div><div class=\"line\">const COLOR_GREEN  = Symbol();</div><div class=\"line\"></div><div class=\"line\">function getComplement(color) &#123;</div><div class=\"line\">  switch (color) &#123;</div><div class=\"line\">    case COLOR_RED:</div><div class=\"line\">      return COLOR_GREEN;</div><div class=\"line\">    case COLOR_GREEN:</div><div class=\"line\">      return COLOR_RED;</div><div class=\"line\">    default:</div><div class=\"line\">      throw new Error(&apos;Undefined color&apos;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"promise解读","type":"categories","_content":"### promise是什么\n\npromise是对异步操作的封装，可以通过独立的接口在异步操作执行成功和失败的方法\n\n### 原理\n\npromise通过then让异步函数按照你的规定的顺序进行，.then的时候放入下一个事件，当异步操作完成时，resolve触发事件队列中的事件，便完成了一个.then操作，\n所以每当我们异步操作完成的时候就移除事件队列的这个事件，通过resolve使事件持续触发下去,核心如下：\n- 定义一个需要传递给下面事件的value\n- 定义一个events，维持一个事件队列\n- 定义一个then函数，把需要执行的函数存入事件队列\n- 定义一个resolve函数，移除已经执行完的函数，并且触发下面的事件继续执行，并传递value\n- 要保证promise里面是一个异步操作，所以需要加setTimeout将执行回调的逻辑放置到 JS 任务队列末尾\n\n```\nfunction Promise(fn) {\n\n\tvar events = []\n\tvar value = null\n\n\tthis.then = function (f) {\n\t\tevents.push(f)\n\t\treturn this\n\t}\n\tfunction resolve(newValue) {\n\t\tsetTimeout(function() {\n\t\t\tvar f = events.shift()\n\t\t\tf(newValue, resolve)\n\t\t}, 0)\n\t}\n\n\tfn(resolve)\n}\t\n```\n\n","source":"_posts/js/es6/promise.md","raw":"---\ntitle: promise解读\ntype: \"categories\"\ncategories: [前端, JS, ES6]\n---\n### promise是什么\n\npromise是对异步操作的封装，可以通过独立的接口在异步操作执行成功和失败的方法\n\n### 原理\n\npromise通过then让异步函数按照你的规定的顺序进行，.then的时候放入下一个事件，当异步操作完成时，resolve触发事件队列中的事件，便完成了一个.then操作，\n所以每当我们异步操作完成的时候就移除事件队列的这个事件，通过resolve使事件持续触发下去,核心如下：\n- 定义一个需要传递给下面事件的value\n- 定义一个events，维持一个事件队列\n- 定义一个then函数，把需要执行的函数存入事件队列\n- 定义一个resolve函数，移除已经执行完的函数，并且触发下面的事件继续执行，并传递value\n- 要保证promise里面是一个异步操作，所以需要加setTimeout将执行回调的逻辑放置到 JS 任务队列末尾\n\n```\nfunction Promise(fn) {\n\n\tvar events = []\n\tvar value = null\n\n\tthis.then = function (f) {\n\t\tevents.push(f)\n\t\treturn this\n\t}\n\tfunction resolve(newValue) {\n\t\tsetTimeout(function() {\n\t\t\tvar f = events.shift()\n\t\t\tf(newValue, resolve)\n\t\t}, 0)\n\t}\n\n\tfn(resolve)\n}\t\n```\n\n","slug":"js-es6-promise","published":1,"date":"2017-04-19T04:02:03.000Z","updated":"2017-04-19T04:02:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgx0039kzy6er8qnksg","content":"<h3 id=\"promise是什么\"><a href=\"#promise是什么\" class=\"headerlink\" title=\"promise是什么\"></a>promise是什么</h3><p>promise是对异步操作的封装，可以通过独立的接口在异步操作执行成功和失败的方法</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>promise通过then让异步函数按照你的规定的顺序进行，.then的时候放入下一个事件，当异步操作完成时，resolve触发事件队列中的事件，便完成了一个.then操作，<br>所以每当我们异步操作完成的时候就移除事件队列的这个事件，通过resolve使事件持续触发下去,核心如下：</p>\n<ul>\n<li>定义一个需要传递给下面事件的value</li>\n<li>定义一个events，维持一个事件队列</li>\n<li>定义一个then函数，把需要执行的函数存入事件队列</li>\n<li>定义一个resolve函数，移除已经执行完的函数，并且触发下面的事件继续执行，并传递value</li>\n<li>要保证promise里面是一个异步操作，所以需要加setTimeout将执行回调的逻辑放置到 JS 任务队列末尾</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Promise(fn) &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar events = []</div><div class=\"line\">\tvar value = null</div><div class=\"line\"></div><div class=\"line\">\tthis.then = function (f) &#123;</div><div class=\"line\">\t\tevents.push(f)</div><div class=\"line\">\t\treturn this</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfunction resolve(newValue) &#123;</div><div class=\"line\">\t\tsetTimeout(function() &#123;</div><div class=\"line\">\t\t\tvar f = events.shift()</div><div class=\"line\">\t\t\tf(newValue, resolve)</div><div class=\"line\">\t\t&#125;, 0)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tfn(resolve)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"promise是什么\"><a href=\"#promise是什么\" class=\"headerlink\" title=\"promise是什么\"></a>promise是什么</h3><p>promise是对异步操作的封装，可以通过独立的接口在异步操作执行成功和失败的方法</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>promise通过then让异步函数按照你的规定的顺序进行，.then的时候放入下一个事件，当异步操作完成时，resolve触发事件队列中的事件，便完成了一个.then操作，<br>所以每当我们异步操作完成的时候就移除事件队列的这个事件，通过resolve使事件持续触发下去,核心如下：</p>\n<ul>\n<li>定义一个需要传递给下面事件的value</li>\n<li>定义一个events，维持一个事件队列</li>\n<li>定义一个then函数，把需要执行的函数存入事件队列</li>\n<li>定义一个resolve函数，移除已经执行完的函数，并且触发下面的事件继续执行，并传递value</li>\n<li>要保证promise里面是一个异步操作，所以需要加setTimeout将执行回调的逻辑放置到 JS 任务队列末尾</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Promise(fn) &#123;</div><div class=\"line\"></div><div class=\"line\">\tvar events = []</div><div class=\"line\">\tvar value = null</div><div class=\"line\"></div><div class=\"line\">\tthis.then = function (f) &#123;</div><div class=\"line\">\t\tevents.push(f)</div><div class=\"line\">\t\treturn this</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfunction resolve(newValue) &#123;</div><div class=\"line\">\t\tsetTimeout(function() &#123;</div><div class=\"line\">\t\t\tvar f = events.shift()</div><div class=\"line\">\t\t\tf(newValue, resolve)</div><div class=\"line\">\t\t&#125;, 0)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tfn(resolve)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"常用设计模式","type":"categories","_content":"\n## 工厂模式\n\n解决了多个类似对象声明的问题，把他称作工厂模式，这种问题就是为了解决实例化对象产生大量重复的问题,消除对象间的耦合\n```\nfunction createObj(name,age) {\n\t//原料\n\tvar obj = new Object();\n\n\t//加工\n\tobj.name = name;\n\tobj.age = age\n\n\t//出厂\n\treturn obj\n}\n\nvar test1 = createObj('wb',22);//第一个实例\nvar test2 = createObj('cz',25);//第二个实例\n\n```\n\n## Constructor(构造器)模式\n\n```\n    function Car(model,year,miles){//构造函数模式\n        this.model = model;\n        this.year = year;\n        this.miles = miles;\n        this.run = function () {\n            return this.model + \" has done \" + this.miles + \"miles\";\n        }\n    }\n    var Benz = new Car('Benz',2014,20000);\n    var BMW = new Car(\"BMW\",2013,12000);\n    alert(Benz instanceof Car); //很清晰的识别他从属于 Car,true\n\n    console.log(Benz.run());\n    console.log(BMW.run());\n```\n1.构造函数方法没有显示的创建对象 (new Object()); \n2.直接将属性和方法赋值给 this 对象;\n3.没有 renturn 语句。\n\n## 迭代器模式\n\n> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n书中演示了一个文件上传的例子，情景是：在不同的浏览器环境下，选择的上传方式是不一样的。所以我们会优先使用控件上传。如果浏览器没有安装上传控件，则使用Flash上传，如果连Flash也没安装，那就只好使用浏览器原生的表单上传了。\n\n\n看，这种场景其实就是遍历。特殊点在于，当遍历到合适的情况的时候，就停止遍历了。这不正是for...of所擅长的吗？\n我们先来看看不使用for...of的bad code\n\n```\nvar getUploadObj = function(){\n    try {\n        return new ActiveXObject('TXFTNActiveX.FTNUpload');   // IE上传控件\n    } catch (e) {\n        try {\n            new ActiveXObject('ShockwaveFlash.ShockwaveFlash');   // Flash上传控件\n            let str = '<object type=\"application/x-shockwave-flash\"></object>';\n            return $(str).appendTo($('body'));\n        } catch (e) {\n            let str = '<input name=\"file\" type=\"file\" calss=\"ui-file\"/>';   // 表单上传\n            return $(str).appendTo($('body'));\n        }\n    }\n}\n\nvar uploadObj = getUploadObj();\nconsole.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]\n```\n上面这个嵌套层级太多了，不利于维护和阅读，**下面来通过for...of解决**\n\n```\nlet getUploadObj = {\n    getActiveUploadObj (){\n        try {\n            return new ActiveXObject('TXFTNActiveX.FTNUpload');   // IE上传控件\n        } catch (e) {\n            return false;\n        }\n    },\n    getFalshUploadObj () {  \n        try {\n            new ActiveXObject('ShockwaveFlash.ShockwaveFlash');   // Flash上传控件\n            let str = '<object type=\"application/x-shockwave-flash\"></object>';\n            return $(str).appendTo($('body'));\n        } catch (e) {\n            return false;\n        }\n    },\n    getFormUploadObj () {\n        let str = '<input name=\"file\" type=\"file\" calss=\"ui-file\"/>';   // 表单上传\n        return $(str).appendTo($('body'));\n    }\n}\n\n// 给对象getUploadObj定义iterator接口，上面演示过这段代码\n// 这里可以通过工厂模式，抽象成一个专门给对象安装iterator接口的函数，这样就可以省却很多重复代码了。\nObject.defineProperty(getUploadObj, Symbol.iterator, {\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    value: function(){\n        var o = this;\n        var idx = 0;\n        var ks = Object.keys(o);\n        return {\n            next: function(){\n                return {\n                    value: o[ks[idx++]],\n                    done: (idx > ks.length)\n                }\n            }\n        }\n    }\n});\n\nfunction iteratorUploadObj (uploadObj){\n    // 直接使用`for...of`遍历uploadObj对象\n    for(let getUpload of uploadObj){\n        let uploadObj = getUpload();\n        if(uploadObj) return uploadObj;\n    }\n}\n\nlet uploadObj = iteratorUploadObj(getUploadObj);\nconsole.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]\n```\n\n## 装饰者模式\n为函数（对象）动态增加职责，又不直接修改这个函数（对象）本身\n缺点： 需要增加一个临时变量来存储原函数。当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护。\n\n```\n//对与别人写好的函数，往里面加一些功能，how to do?也许你说我路子野直接\n// 修改前\nlet doSomething = function() {\n  console.log(1);\n}\n\n// 修改后\nlet doSomething = function() {\n  console.log(1);\n  console.log(2);\n}\n```\n可这违反了开闭原则，那如何解决呢？\n\n```\nlet dosomething = function() {\n    console.log(1)\n}\nlet _dosomething = dosomething\ndosomething = function(){\n    _dosomething();\n    console.log(2)\n}\ndosomething()\n```\n发现其实只需要一个定义一个变量存放，然后在覆写函数里面拓展，but当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护，所以\n\n```\nFunction.prototype.before = function(beforefn) {\n    let _self = this\n    return function() {\n        beforefn.apply(this, arguments)\n        return _self.apply(this, arguments)\n    }\n}\nFunction.prototype.after = function(afterfn){\n    let _self = this;\n    return function(){\n        let ret = _self.apply(this, arguments);\n        afterfn.apply(this, arguments);\n        return ret;\n    }\n}\n\nlet something  = function() {\n    console.log(333)\n}\nsomething.before(() => {\n    console.log(4)\n}).after(()=> {\n    console.log(55)\n})\n\n```\n这样，有了before和after方法，我们就能在函数的前面和后面动态添加功能，而且非常的优雅。\n\n\n\n","source":"_posts/js/designPattern/常用设计模式.md","raw":"---\ntitle: 常用设计模式\ntype: \"categories\"\ncategories: [前端, JS, 设计模式]\n---\n\n## 工厂模式\n\n解决了多个类似对象声明的问题，把他称作工厂模式，这种问题就是为了解决实例化对象产生大量重复的问题,消除对象间的耦合\n```\nfunction createObj(name,age) {\n\t//原料\n\tvar obj = new Object();\n\n\t//加工\n\tobj.name = name;\n\tobj.age = age\n\n\t//出厂\n\treturn obj\n}\n\nvar test1 = createObj('wb',22);//第一个实例\nvar test2 = createObj('cz',25);//第二个实例\n\n```\n\n## Constructor(构造器)模式\n\n```\n    function Car(model,year,miles){//构造函数模式\n        this.model = model;\n        this.year = year;\n        this.miles = miles;\n        this.run = function () {\n            return this.model + \" has done \" + this.miles + \"miles\";\n        }\n    }\n    var Benz = new Car('Benz',2014,20000);\n    var BMW = new Car(\"BMW\",2013,12000);\n    alert(Benz instanceof Car); //很清晰的识别他从属于 Car,true\n\n    console.log(Benz.run());\n    console.log(BMW.run());\n```\n1.构造函数方法没有显示的创建对象 (new Object()); \n2.直接将属性和方法赋值给 this 对象;\n3.没有 renturn 语句。\n\n## 迭代器模式\n\n> 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。\n书中演示了一个文件上传的例子，情景是：在不同的浏览器环境下，选择的上传方式是不一样的。所以我们会优先使用控件上传。如果浏览器没有安装上传控件，则使用Flash上传，如果连Flash也没安装，那就只好使用浏览器原生的表单上传了。\n\n\n看，这种场景其实就是遍历。特殊点在于，当遍历到合适的情况的时候，就停止遍历了。这不正是for...of所擅长的吗？\n我们先来看看不使用for...of的bad code\n\n```\nvar getUploadObj = function(){\n    try {\n        return new ActiveXObject('TXFTNActiveX.FTNUpload');   // IE上传控件\n    } catch (e) {\n        try {\n            new ActiveXObject('ShockwaveFlash.ShockwaveFlash');   // Flash上传控件\n            let str = '<object type=\"application/x-shockwave-flash\"></object>';\n            return $(str).appendTo($('body'));\n        } catch (e) {\n            let str = '<input name=\"file\" type=\"file\" calss=\"ui-file\"/>';   // 表单上传\n            return $(str).appendTo($('body'));\n        }\n    }\n}\n\nvar uploadObj = getUploadObj();\nconsole.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]\n```\n上面这个嵌套层级太多了，不利于维护和阅读，**下面来通过for...of解决**\n\n```\nlet getUploadObj = {\n    getActiveUploadObj (){\n        try {\n            return new ActiveXObject('TXFTNActiveX.FTNUpload');   // IE上传控件\n        } catch (e) {\n            return false;\n        }\n    },\n    getFalshUploadObj () {  \n        try {\n            new ActiveXObject('ShockwaveFlash.ShockwaveFlash');   // Flash上传控件\n            let str = '<object type=\"application/x-shockwave-flash\"></object>';\n            return $(str).appendTo($('body'));\n        } catch (e) {\n            return false;\n        }\n    },\n    getFormUploadObj () {\n        let str = '<input name=\"file\" type=\"file\" calss=\"ui-file\"/>';   // 表单上传\n        return $(str).appendTo($('body'));\n    }\n}\n\n// 给对象getUploadObj定义iterator接口，上面演示过这段代码\n// 这里可以通过工厂模式，抽象成一个专门给对象安装iterator接口的函数，这样就可以省却很多重复代码了。\nObject.defineProperty(getUploadObj, Symbol.iterator, {\n    enumerable: false,\n    writable: false,\n    configurable: true,\n    value: function(){\n        var o = this;\n        var idx = 0;\n        var ks = Object.keys(o);\n        return {\n            next: function(){\n                return {\n                    value: o[ks[idx++]],\n                    done: (idx > ks.length)\n                }\n            }\n        }\n    }\n});\n\nfunction iteratorUploadObj (uploadObj){\n    // 直接使用`for...of`遍历uploadObj对象\n    for(let getUpload of uploadObj){\n        let uploadObj = getUpload();\n        if(uploadObj) return uploadObj;\n    }\n}\n\nlet uploadObj = iteratorUploadObj(getUploadObj);\nconsole.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]\n```\n\n## 装饰者模式\n为函数（对象）动态增加职责，又不直接修改这个函数（对象）本身\n缺点： 需要增加一个临时变量来存储原函数。当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护。\n\n```\n//对与别人写好的函数，往里面加一些功能，how to do?也许你说我路子野直接\n// 修改前\nlet doSomething = function() {\n  console.log(1);\n}\n\n// 修改后\nlet doSomething = function() {\n  console.log(1);\n  console.log(2);\n}\n```\n可这违反了开闭原则，那如何解决呢？\n\n```\nlet dosomething = function() {\n    console.log(1)\n}\nlet _dosomething = dosomething\ndosomething = function(){\n    _dosomething();\n    console.log(2)\n}\ndosomething()\n```\n发现其实只需要一个定义一个变量存放，然后在覆写函数里面拓展，but当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护，所以\n\n```\nFunction.prototype.before = function(beforefn) {\n    let _self = this\n    return function() {\n        beforefn.apply(this, arguments)\n        return _self.apply(this, arguments)\n    }\n}\nFunction.prototype.after = function(afterfn){\n    let _self = this;\n    return function(){\n        let ret = _self.apply(this, arguments);\n        afterfn.apply(this, arguments);\n        return ret;\n    }\n}\n\nlet something  = function() {\n    console.log(333)\n}\nsomething.before(() => {\n    console.log(4)\n}).after(()=> {\n    console.log(55)\n})\n\n```\n这样，有了before和after方法，我们就能在函数的前面和后面动态添加功能，而且非常的优雅。\n\n\n\n","slug":"js-designPattern-常用设计模式","published":1,"date":"2017-04-23T11:06:18.000Z","updated":"2017-04-23T11:06:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgx003akzy6sen92gv9","content":"<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>解决了多个类似对象声明的问题，把他称作工厂模式，这种问题就是为了解决实例化对象产生大量重复的问题,消除对象间的耦合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createObj(name,age) &#123;</div><div class=\"line\">\t//原料</div><div class=\"line\">\tvar obj = new Object();</div><div class=\"line\"></div><div class=\"line\">\t//加工</div><div class=\"line\">\tobj.name = name;</div><div class=\"line\">\tobj.age = age</div><div class=\"line\"></div><div class=\"line\">\t//出厂</div><div class=\"line\">\treturn obj</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var test1 = createObj(&apos;wb&apos;,22);//第一个实例</div><div class=\"line\">var test2 = createObj(&apos;cz&apos;,25);//第二个实例</div></pre></td></tr></table></figure></p>\n<h2 id=\"Constructor-构造器-模式\"><a href=\"#Constructor-构造器-模式\" class=\"headerlink\" title=\"Constructor(构造器)模式\"></a>Constructor(构造器)模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Car(model,year,miles)&#123;//构造函数模式</div><div class=\"line\">    this.model = model;</div><div class=\"line\">    this.year = year;</div><div class=\"line\">    this.miles = miles;</div><div class=\"line\">    this.run = function () &#123;</div><div class=\"line\">        return this.model + &quot; has done &quot; + this.miles + &quot;miles&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var Benz = new Car(&apos;Benz&apos;,2014,20000);</div><div class=\"line\">var BMW = new Car(&quot;BMW&quot;,2013,12000);</div><div class=\"line\">alert(Benz instanceof Car); //很清晰的识别他从属于 Car,true</div><div class=\"line\"></div><div class=\"line\">console.log(Benz.run());</div><div class=\"line\">console.log(BMW.run());</div></pre></td></tr></table></figure>\n<p>1.构造函数方法没有显示的创建对象 (new Object());<br>2.直接将属性和方法赋值给 this 对象;<br>3.没有 renturn 语句。</p>\n<h2 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h2><blockquote>\n<p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>书中演示了一个文件上传的例子，情景是：在不同的浏览器环境下，选择的上传方式是不一样的。所以我们会优先使用控件上传。如果浏览器没有安装上传控件，则使用Flash上传，如果连Flash也没安装，那就只好使用浏览器原生的表单上传了。</p>\n</blockquote>\n<p>看，这种场景其实就是遍历。特殊点在于，当遍历到合适的情况的时候，就停止遍历了。这不正是for…of所擅长的吗？<br>我们先来看看不使用for…of的bad code</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var getUploadObj = function()&#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return new ActiveXObject(&apos;TXFTNActiveX.FTNUpload&apos;);   // IE上传控件</div><div class=\"line\">    &#125; catch (e) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;);   // Flash上传控件</div><div class=\"line\">            let str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class=\"line\">            return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            let str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; calss=&quot;ui-file&quot;/&gt;&apos;;   // 表单上传</div><div class=\"line\">            return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var uploadObj = getUploadObj();</div><div class=\"line\">console.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]</div></pre></td></tr></table></figure>\n<p>上面这个嵌套层级太多了，不利于维护和阅读，<strong>下面来通过for…of解决</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">let getUploadObj = &#123;</div><div class=\"line\">    getActiveUploadObj ()&#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return new ActiveXObject(&apos;TXFTNActiveX.FTNUpload&apos;);   // IE上传控件</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getFalshUploadObj () &#123;  </div><div class=\"line\">        try &#123;</div><div class=\"line\">            new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;);   // Flash上传控件</div><div class=\"line\">            let str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class=\"line\">            return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getFormUploadObj () &#123;</div><div class=\"line\">        let str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; calss=&quot;ui-file&quot;/&gt;&apos;;   // 表单上传</div><div class=\"line\">        return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 给对象getUploadObj定义iterator接口，上面演示过这段代码</div><div class=\"line\">// 这里可以通过工厂模式，抽象成一个专门给对象安装iterator接口的函数，这样就可以省却很多重复代码了。</div><div class=\"line\">Object.defineProperty(getUploadObj, Symbol.iterator, &#123;</div><div class=\"line\">    enumerable: false,</div><div class=\"line\">    writable: false,</div><div class=\"line\">    configurable: true,</div><div class=\"line\">    value: function()&#123;</div><div class=\"line\">        var o = this;</div><div class=\"line\">        var idx = 0;</div><div class=\"line\">        var ks = Object.keys(o);</div><div class=\"line\">        return &#123;</div><div class=\"line\">            next: function()&#123;</div><div class=\"line\">                return &#123;</div><div class=\"line\">                    value: o[ks[idx++]],</div><div class=\"line\">                    done: (idx &gt; ks.length)</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">function iteratorUploadObj (uploadObj)&#123;</div><div class=\"line\">    // 直接使用`for...of`遍历uploadObj对象</div><div class=\"line\">    for(let getUpload of uploadObj)&#123;</div><div class=\"line\">        let uploadObj = getUpload();</div><div class=\"line\">        if(uploadObj) return uploadObj;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let uploadObj = iteratorUploadObj(getUploadObj);</div><div class=\"line\">console.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]</div></pre></td></tr></table></figure>\n<h2 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h2><p>为函数（对象）动态增加职责，又不直接修改这个函数（对象）本身<br>缺点： 需要增加一个临时变量来存储原函数。当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对与别人写好的函数，往里面加一些功能，how to do?也许你说我路子野直接</div><div class=\"line\">// 修改前</div><div class=\"line\">let doSomething = function() &#123;</div><div class=\"line\">  console.log(1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 修改后</div><div class=\"line\">let doSomething = function() &#123;</div><div class=\"line\">  console.log(1);</div><div class=\"line\">  console.log(2);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可这违反了开闭原则，那如何解决呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">let dosomething = function() &#123;</div><div class=\"line\">    console.log(1)</div><div class=\"line\">&#125;</div><div class=\"line\">let _dosomething = dosomething</div><div class=\"line\">dosomething = function()&#123;</div><div class=\"line\">    _dosomething();</div><div class=\"line\">    console.log(2)</div><div class=\"line\">&#125;</div><div class=\"line\">dosomething()</div></pre></td></tr></table></figure>\n<p>发现其实只需要一个定义一个变量存放，然后在覆写函数里面拓展，but当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护，所以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">Function.prototype.before = function(beforefn) &#123;</div><div class=\"line\">    let _self = this</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        beforefn.apply(this, arguments)</div><div class=\"line\">        return _self.apply(this, arguments)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Function.prototype.after = function(afterfn)&#123;</div><div class=\"line\">    let _self = this;</div><div class=\"line\">    return function()&#123;</div><div class=\"line\">        let ret = _self.apply(this, arguments);</div><div class=\"line\">        afterfn.apply(this, arguments);</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let something  = function() &#123;</div><div class=\"line\">    console.log(333)</div><div class=\"line\">&#125;</div><div class=\"line\">something.before(() =&gt; &#123;</div><div class=\"line\">    console.log(4)</div><div class=\"line\">&#125;).after(()=&gt; &#123;</div><div class=\"line\">    console.log(55)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样，有了before和after方法，我们就能在函数的前面和后面动态添加功能，而且非常的优雅。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>解决了多个类似对象声明的问题，把他称作工厂模式，这种问题就是为了解决实例化对象产生大量重复的问题,消除对象间的耦合<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function createObj(name,age) &#123;</div><div class=\"line\">\t//原料</div><div class=\"line\">\tvar obj = new Object();</div><div class=\"line\"></div><div class=\"line\">\t//加工</div><div class=\"line\">\tobj.name = name;</div><div class=\"line\">\tobj.age = age</div><div class=\"line\"></div><div class=\"line\">\t//出厂</div><div class=\"line\">\treturn obj</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var test1 = createObj(&apos;wb&apos;,22);//第一个实例</div><div class=\"line\">var test2 = createObj(&apos;cz&apos;,25);//第二个实例</div></pre></td></tr></table></figure></p>\n<h2 id=\"Constructor-构造器-模式\"><a href=\"#Constructor-构造器-模式\" class=\"headerlink\" title=\"Constructor(构造器)模式\"></a>Constructor(构造器)模式</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">function Car(model,year,miles)&#123;//构造函数模式</div><div class=\"line\">    this.model = model;</div><div class=\"line\">    this.year = year;</div><div class=\"line\">    this.miles = miles;</div><div class=\"line\">    this.run = function () &#123;</div><div class=\"line\">        return this.model + &quot; has done &quot; + this.miles + &quot;miles&quot;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">var Benz = new Car(&apos;Benz&apos;,2014,20000);</div><div class=\"line\">var BMW = new Car(&quot;BMW&quot;,2013,12000);</div><div class=\"line\">alert(Benz instanceof Car); //很清晰的识别他从属于 Car,true</div><div class=\"line\"></div><div class=\"line\">console.log(Benz.run());</div><div class=\"line\">console.log(BMW.run());</div></pre></td></tr></table></figure>\n<p>1.构造函数方法没有显示的创建对象 (new Object());<br>2.直接将属性和方法赋值给 this 对象;<br>3.没有 renturn 语句。</p>\n<h2 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h2><blockquote>\n<p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。<br>书中演示了一个文件上传的例子，情景是：在不同的浏览器环境下，选择的上传方式是不一样的。所以我们会优先使用控件上传。如果浏览器没有安装上传控件，则使用Flash上传，如果连Flash也没安装，那就只好使用浏览器原生的表单上传了。</p>\n</blockquote>\n<p>看，这种场景其实就是遍历。特殊点在于，当遍历到合适的情况的时候，就停止遍历了。这不正是for…of所擅长的吗？<br>我们先来看看不使用for…of的bad code</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">var getUploadObj = function()&#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        return new ActiveXObject(&apos;TXFTNActiveX.FTNUpload&apos;);   // IE上传控件</div><div class=\"line\">    &#125; catch (e) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;);   // Flash上传控件</div><div class=\"line\">            let str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class=\"line\">            return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            let str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; calss=&quot;ui-file&quot;/&gt;&apos;;   // 表单上传</div><div class=\"line\">            return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var uploadObj = getUploadObj();</div><div class=\"line\">console.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]</div></pre></td></tr></table></figure>\n<p>上面这个嵌套层级太多了，不利于维护和阅读，<strong>下面来通过for…of解决</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">let getUploadObj = &#123;</div><div class=\"line\">    getActiveUploadObj ()&#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return new ActiveXObject(&apos;TXFTNActiveX.FTNUpload&apos;);   // IE上传控件</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getFalshUploadObj () &#123;  </div><div class=\"line\">        try &#123;</div><div class=\"line\">            new ActiveXObject(&apos;ShockwaveFlash.ShockwaveFlash&apos;);   // Flash上传控件</div><div class=\"line\">            let str = &apos;&lt;object type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt;&apos;;</div><div class=\"line\">            return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">        &#125; catch (e) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    getFormUploadObj () &#123;</div><div class=\"line\">        let str = &apos;&lt;input name=&quot;file&quot; type=&quot;file&quot; calss=&quot;ui-file&quot;/&gt;&apos;;   // 表单上传</div><div class=\"line\">        return $(str).appendTo($(&apos;body&apos;));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 给对象getUploadObj定义iterator接口，上面演示过这段代码</div><div class=\"line\">// 这里可以通过工厂模式，抽象成一个专门给对象安装iterator接口的函数，这样就可以省却很多重复代码了。</div><div class=\"line\">Object.defineProperty(getUploadObj, Symbol.iterator, &#123;</div><div class=\"line\">    enumerable: false,</div><div class=\"line\">    writable: false,</div><div class=\"line\">    configurable: true,</div><div class=\"line\">    value: function()&#123;</div><div class=\"line\">        var o = this;</div><div class=\"line\">        var idx = 0;</div><div class=\"line\">        var ks = Object.keys(o);</div><div class=\"line\">        return &#123;</div><div class=\"line\">            next: function()&#123;</div><div class=\"line\">                return &#123;</div><div class=\"line\">                    value: o[ks[idx++]],</div><div class=\"line\">                    done: (idx &gt; ks.length)</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">function iteratorUploadObj (uploadObj)&#123;</div><div class=\"line\">    // 直接使用`for...of`遍历uploadObj对象</div><div class=\"line\">    for(let getUpload of uploadObj)&#123;</div><div class=\"line\">        let uploadObj = getUpload();</div><div class=\"line\">        if(uploadObj) return uploadObj;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let uploadObj = iteratorUploadObj(getUploadObj);</div><div class=\"line\">console.log(uploadObj);  // [input, prevObject: Z.fn.init[1], context: undefined]</div></pre></td></tr></table></figure>\n<h2 id=\"装饰者模式\"><a href=\"#装饰者模式\" class=\"headerlink\" title=\"装饰者模式\"></a>装饰者模式</h2><p>为函数（对象）动态增加职责，又不直接修改这个函数（对象）本身<br>缺点： 需要增加一个临时变量来存储原函数。当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//对与别人写好的函数，往里面加一些功能，how to do?也许你说我路子野直接</div><div class=\"line\">// 修改前</div><div class=\"line\">let doSomething = function() &#123;</div><div class=\"line\">  console.log(1);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// 修改后</div><div class=\"line\">let doSomething = function() &#123;</div><div class=\"line\">  console.log(1);</div><div class=\"line\">  console.log(2);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可这违反了开闭原则，那如何解决呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">let dosomething = function() &#123;</div><div class=\"line\">    console.log(1)</div><div class=\"line\">&#125;</div><div class=\"line\">let _dosomething = dosomething</div><div class=\"line\">dosomething = function()&#123;</div><div class=\"line\">    _dosomething();</div><div class=\"line\">    console.log(2)</div><div class=\"line\">&#125;</div><div class=\"line\">dosomething()</div></pre></td></tr></table></figure>\n<p>发现其实只需要一个定义一个变量存放，然后在覆写函数里面拓展，but当需要装饰的函数越来越多的时候，临时变量的数量呈线性增长，代码将变得越来越难以维护，所以</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">Function.prototype.before = function(beforefn) &#123;</div><div class=\"line\">    let _self = this</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        beforefn.apply(this, arguments)</div><div class=\"line\">        return _self.apply(this, arguments)</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Function.prototype.after = function(afterfn)&#123;</div><div class=\"line\">    let _self = this;</div><div class=\"line\">    return function()&#123;</div><div class=\"line\">        let ret = _self.apply(this, arguments);</div><div class=\"line\">        afterfn.apply(this, arguments);</div><div class=\"line\">        return ret;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let something  = function() &#123;</div><div class=\"line\">    console.log(333)</div><div class=\"line\">&#125;</div><div class=\"line\">something.before(() =&gt; &#123;</div><div class=\"line\">    console.log(4)</div><div class=\"line\">&#125;).after(()=&gt; &#123;</div><div class=\"line\">    console.log(55)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>这样，有了before和after方法，我们就能在函数的前面和后面动态添加功能，而且非常的优雅。</p>\n"},{"title":"混合对象‘类’","type":"categories","_content":"\n## JS中的多态\n举例：鸡和狗都会叫，叫的方式不同，简单的来说这就是多态的一种表现方式\n\n\n## 混入\n### 显示混入\nObject.assign是常用的方法，它跟mixin有一个重大的区别在于：mixin会把原型链上的属性一并复制过去（因为for...in），而Object.assign则不会。\n```\n// 非常简单的 mixin(..) 例子 :\nfunction mixin( sourceObj, targetObj ) {\n\tfor (var key in sourceObj) { // 只会在不存在的情况下复制 if (!(key in targetObj)) {\n\t     targetObj[key] = sourceObj[key];\n\t\t}\n\t}\n\treturn targetObj; \n}\n\nvar Vehicle = { \n\tengines: 1,\n\tignition: function() {\n\t\tconsole.log( \"Turning on my engine.\" );\n\t},\n\tdrive: function() { \n\t\tthis.ignition();\n\t    console.log( \"Steering and moving forward!\" );\n\t}\n};\n\nvar Car = mixin( Vehicle, { \n\twheels: 4,\n\tdrive: function() { \n\t\tVehicle.drive.call( this ); //这就是显式多态\n\t\tconsole.log(\"Rolling on all \" + this.wheels + \" wheels!\");\n\t}\n});\n```\n#### 寄生继承\n```\n//“传统的 JavaScript 类”\nVehicle function Vehicle() {\n\tthis.engines = 1; \n}\nVehicle.prototype.ignition = function() { \n\tconsole.log( \"Turning on my engine.\" );\n};\nVehicle.prototype.drive = function() {\n\tthis.ignition();\n\tconsole.log( \"Steering and moving forward!\" );\n};\n\n//“寄生类”Car \nfunction Car() {\n// 首先，car 是一个 Vehicle \nvar car = new Vehicle();\n// 接着我们对 car 进行定制 \ncar.wheels = 4;\n// 保存到 Vehicle::drive() 的特殊引用 \nvar vehDrive = car.drive;\n// 重写 Vehicle::drive() \ncar.drive = function() {\n\tvehDrive.call( this );\n    console.log(\"Rolling on all \" + this.wheels + \" wheels!\");\n\treturn car; \n}\n\n```\n\n### 隐式混入\nSomething.cool.call( this ) 其实就是改变this指向，作用域的方式\n","source":"_posts/js/designPattern/混合对象‘类’.md","raw":"---\ntitle: 混合对象‘类’\ntype: \"categories\"\ncategories: [前端, JS, 设计模式]\n---\n\n## JS中的多态\n举例：鸡和狗都会叫，叫的方式不同，简单的来说这就是多态的一种表现方式\n\n\n## 混入\n### 显示混入\nObject.assign是常用的方法，它跟mixin有一个重大的区别在于：mixin会把原型链上的属性一并复制过去（因为for...in），而Object.assign则不会。\n```\n// 非常简单的 mixin(..) 例子 :\nfunction mixin( sourceObj, targetObj ) {\n\tfor (var key in sourceObj) { // 只会在不存在的情况下复制 if (!(key in targetObj)) {\n\t     targetObj[key] = sourceObj[key];\n\t\t}\n\t}\n\treturn targetObj; \n}\n\nvar Vehicle = { \n\tengines: 1,\n\tignition: function() {\n\t\tconsole.log( \"Turning on my engine.\" );\n\t},\n\tdrive: function() { \n\t\tthis.ignition();\n\t    console.log( \"Steering and moving forward!\" );\n\t}\n};\n\nvar Car = mixin( Vehicle, { \n\twheels: 4,\n\tdrive: function() { \n\t\tVehicle.drive.call( this ); //这就是显式多态\n\t\tconsole.log(\"Rolling on all \" + this.wheels + \" wheels!\");\n\t}\n});\n```\n#### 寄生继承\n```\n//“传统的 JavaScript 类”\nVehicle function Vehicle() {\n\tthis.engines = 1; \n}\nVehicle.prototype.ignition = function() { \n\tconsole.log( \"Turning on my engine.\" );\n};\nVehicle.prototype.drive = function() {\n\tthis.ignition();\n\tconsole.log( \"Steering and moving forward!\" );\n};\n\n//“寄生类”Car \nfunction Car() {\n// 首先，car 是一个 Vehicle \nvar car = new Vehicle();\n// 接着我们对 car 进行定制 \ncar.wheels = 4;\n// 保存到 Vehicle::drive() 的特殊引用 \nvar vehDrive = car.drive;\n// 重写 Vehicle::drive() \ncar.drive = function() {\n\tvehDrive.call( this );\n    console.log(\"Rolling on all \" + this.wheels + \" wheels!\");\n\treturn car; \n}\n\n```\n\n### 隐式混入\nSomething.cool.call( this ) 其实就是改变this指向，作用域的方式\n","slug":"js-designPattern-混合对象‘类’","published":1,"date":"2017-04-23T11:06:13.000Z","updated":"2017-04-23T11:06:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cgz003ckzy6tbyb45nb","content":"<h2 id=\"JS中的多态\"><a href=\"#JS中的多态\" class=\"headerlink\" title=\"JS中的多态\"></a>JS中的多态</h2><p>举例：鸡和狗都会叫，叫的方式不同，简单的来说这就是多态的一种表现方式</p>\n<h2 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h2><h3 id=\"显示混入\"><a href=\"#显示混入\" class=\"headerlink\" title=\"显示混入\"></a>显示混入</h3><p>Object.assign是常用的方法，它跟mixin有一个重大的区别在于：mixin会把原型链上的属性一并复制过去（因为for…in），而Object.assign则不会。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 非常简单的 mixin(..) 例子 :</div><div class=\"line\">function mixin( sourceObj, targetObj ) &#123;</div><div class=\"line\">\tfor (var key in sourceObj) &#123; // 只会在不存在的情况下复制 if (!(key in targetObj)) &#123;</div><div class=\"line\">\t     targetObj[key] = sourceObj[key];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn targetObj; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var Vehicle = &#123; </div><div class=\"line\">\tengines: 1,</div><div class=\"line\">\tignition: function() &#123;</div><div class=\"line\">\t\tconsole.log( &quot;Turning on my engine.&quot; );</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tdrive: function() &#123; </div><div class=\"line\">\t\tthis.ignition();</div><div class=\"line\">\t    console.log( &quot;Steering and moving forward!&quot; );</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var Car = mixin( Vehicle, &#123; </div><div class=\"line\">\twheels: 4,</div><div class=\"line\">\tdrive: function() &#123; </div><div class=\"line\">\t\tVehicle.drive.call( this ); //这就是显式多态</div><div class=\"line\">\t\tconsole.log(&quot;Rolling on all &quot; + this.wheels + &quot; wheels!&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"寄生继承\"><a href=\"#寄生继承\" class=\"headerlink\" title=\"寄生继承\"></a>寄生继承</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//“传统的 JavaScript 类”</div><div class=\"line\">Vehicle function Vehicle() &#123;</div><div class=\"line\">\tthis.engines = 1; </div><div class=\"line\">&#125;</div><div class=\"line\">Vehicle.prototype.ignition = function() &#123; </div><div class=\"line\">\tconsole.log( &quot;Turning on my engine.&quot; );</div><div class=\"line\">&#125;;</div><div class=\"line\">Vehicle.prototype.drive = function() &#123;</div><div class=\"line\">\tthis.ignition();</div><div class=\"line\">\tconsole.log( &quot;Steering and moving forward!&quot; );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//“寄生类”Car </div><div class=\"line\">function Car() &#123;</div><div class=\"line\">// 首先，car 是一个 Vehicle </div><div class=\"line\">var car = new Vehicle();</div><div class=\"line\">// 接着我们对 car 进行定制 </div><div class=\"line\">car.wheels = 4;</div><div class=\"line\">// 保存到 Vehicle::drive() 的特殊引用 </div><div class=\"line\">var vehDrive = car.drive;</div><div class=\"line\">// 重写 Vehicle::drive() </div><div class=\"line\">car.drive = function() &#123;</div><div class=\"line\">\tvehDrive.call( this );</div><div class=\"line\">    console.log(&quot;Rolling on all &quot; + this.wheels + &quot; wheels!&quot;);</div><div class=\"line\">\treturn car; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"隐式混入\"><a href=\"#隐式混入\" class=\"headerlink\" title=\"隐式混入\"></a>隐式混入</h3><p>Something.cool.call( this ) 其实就是改变this指向，作用域的方式</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JS中的多态\"><a href=\"#JS中的多态\" class=\"headerlink\" title=\"JS中的多态\"></a>JS中的多态</h2><p>举例：鸡和狗都会叫，叫的方式不同，简单的来说这就是多态的一种表现方式</p>\n<h2 id=\"混入\"><a href=\"#混入\" class=\"headerlink\" title=\"混入\"></a>混入</h2><h3 id=\"显示混入\"><a href=\"#显示混入\" class=\"headerlink\" title=\"显示混入\"></a>显示混入</h3><p>Object.assign是常用的方法，它跟mixin有一个重大的区别在于：mixin会把原型链上的属性一并复制过去（因为for…in），而Object.assign则不会。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 非常简单的 mixin(..) 例子 :</div><div class=\"line\">function mixin( sourceObj, targetObj ) &#123;</div><div class=\"line\">\tfor (var key in sourceObj) &#123; // 只会在不存在的情况下复制 if (!(key in targetObj)) &#123;</div><div class=\"line\">\t     targetObj[key] = sourceObj[key];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn targetObj; </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var Vehicle = &#123; </div><div class=\"line\">\tengines: 1,</div><div class=\"line\">\tignition: function() &#123;</div><div class=\"line\">\t\tconsole.log( &quot;Turning on my engine.&quot; );</div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tdrive: function() &#123; </div><div class=\"line\">\t\tthis.ignition();</div><div class=\"line\">\t    console.log( &quot;Steering and moving forward!&quot; );</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var Car = mixin( Vehicle, &#123; </div><div class=\"line\">\twheels: 4,</div><div class=\"line\">\tdrive: function() &#123; </div><div class=\"line\">\t\tVehicle.drive.call( this ); //这就是显式多态</div><div class=\"line\">\t\tconsole.log(&quot;Rolling on all &quot; + this.wheels + &quot; wheels!&quot;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<h4 id=\"寄生继承\"><a href=\"#寄生继承\" class=\"headerlink\" title=\"寄生继承\"></a>寄生继承</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//“传统的 JavaScript 类”</div><div class=\"line\">Vehicle function Vehicle() &#123;</div><div class=\"line\">\tthis.engines = 1; </div><div class=\"line\">&#125;</div><div class=\"line\">Vehicle.prototype.ignition = function() &#123; </div><div class=\"line\">\tconsole.log( &quot;Turning on my engine.&quot; );</div><div class=\"line\">&#125;;</div><div class=\"line\">Vehicle.prototype.drive = function() &#123;</div><div class=\"line\">\tthis.ignition();</div><div class=\"line\">\tconsole.log( &quot;Steering and moving forward!&quot; );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">//“寄生类”Car </div><div class=\"line\">function Car() &#123;</div><div class=\"line\">// 首先，car 是一个 Vehicle </div><div class=\"line\">var car = new Vehicle();</div><div class=\"line\">// 接着我们对 car 进行定制 </div><div class=\"line\">car.wheels = 4;</div><div class=\"line\">// 保存到 Vehicle::drive() 的特殊引用 </div><div class=\"line\">var vehDrive = car.drive;</div><div class=\"line\">// 重写 Vehicle::drive() </div><div class=\"line\">car.drive = function() &#123;</div><div class=\"line\">\tvehDrive.call( this );</div><div class=\"line\">    console.log(&quot;Rolling on all &quot; + this.wheels + &quot; wheels!&quot;);</div><div class=\"line\">\treturn car; </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"隐式混入\"><a href=\"#隐式混入\" class=\"headerlink\" title=\"隐式混入\"></a>隐式混入</h3><p>Something.cool.call( this ) 其实就是改变this指向，作用域的方式</p>\n"},{"title":"DOM事件机制","type":"categories","_content":"\n# 漫谈\n我们在node中很看见events事件操作模块， 事件操作有什么作用？为什么很多地方都存在？\n- 事件操作能使复杂的业务中抽象出独立的逻辑，跨模块之间传递数据，可以达到解耦\n\n# DOM事件\n## DOM0级事件\n```\n<p onclick=\"alert(1)\"></p>\n```\n缺点：\n- HTML和JS耦合在一起\n- 同一个元素不能绑定多个事件\n\n## DOM2\nel.addEventListener(eventName, callback, capture)\n兼容性问题这里不多谈\n\n## DOM3级事件\n增加了很多事件类型\n\n1. UI事件，如：scroll、load\n2. 焦点事件： blur、focus\n3. 鼠标事件： dbclick、mouseup\n4. 滚轮事件： mousewheel\n5. 文本事件： textInput\n6. 键盘事件： keydown等\n......\n\n## 事件流\n为什么会出现事件流，当我们给子父级同时绑定事件的时候，事件执行顺序的过程该是怎样的呢，所以这个事件执行的过程就是事件流动的过程\n\n## 事件阶段\n\n事件流的三个阶段：\n- 捕获阶段\n- 目标阶段\n- 冒泡阶段\n\n\n## 事件代理\n\n绑定事件过多造成的问题\n- 函数是对象，会占用内存，内存中的对象越多，浏览器性能越差\n- 注册的事件一般都会指定DOM元素，事件越多，导致DOM元素访问次数越多，会延迟页面交互就绪时间。\n- 删除子元素的时候不用考虑删除绑定事件\n为了减少事件的注册，我们使用一个代理元素是代理它内部所有子元素事件\n\n无论是Capture是true还是false，事件都会触发，那么事件代理和事件没有关系吗？(参考这里)[http://coderlt.coding.me/2016/11/22/js-event/]\n\n## e.target vs e.currentTarget\n- e.target返回触发事件的节点\n- e.currentTarget 返回监听触发事件的节点，在冒泡和捕获阶段是非常有用的\n- 在事件代理中，e.target 是当前点击的目标元素，而 e.currentTarget 始终是事件的代理元素\n\n## 自定义事件\non，one，off，emit\none的情况单独用个数组存放\n","source":"_posts/js/foundation/DOM事件机制.md","raw":"---\ntitle: DOM事件机制\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n# 漫谈\n我们在node中很看见events事件操作模块， 事件操作有什么作用？为什么很多地方都存在？\n- 事件操作能使复杂的业务中抽象出独立的逻辑，跨模块之间传递数据，可以达到解耦\n\n# DOM事件\n## DOM0级事件\n```\n<p onclick=\"alert(1)\"></p>\n```\n缺点：\n- HTML和JS耦合在一起\n- 同一个元素不能绑定多个事件\n\n## DOM2\nel.addEventListener(eventName, callback, capture)\n兼容性问题这里不多谈\n\n## DOM3级事件\n增加了很多事件类型\n\n1. UI事件，如：scroll、load\n2. 焦点事件： blur、focus\n3. 鼠标事件： dbclick、mouseup\n4. 滚轮事件： mousewheel\n5. 文本事件： textInput\n6. 键盘事件： keydown等\n......\n\n## 事件流\n为什么会出现事件流，当我们给子父级同时绑定事件的时候，事件执行顺序的过程该是怎样的呢，所以这个事件执行的过程就是事件流动的过程\n\n## 事件阶段\n\n事件流的三个阶段：\n- 捕获阶段\n- 目标阶段\n- 冒泡阶段\n\n\n## 事件代理\n\n绑定事件过多造成的问题\n- 函数是对象，会占用内存，内存中的对象越多，浏览器性能越差\n- 注册的事件一般都会指定DOM元素，事件越多，导致DOM元素访问次数越多，会延迟页面交互就绪时间。\n- 删除子元素的时候不用考虑删除绑定事件\n为了减少事件的注册，我们使用一个代理元素是代理它内部所有子元素事件\n\n无论是Capture是true还是false，事件都会触发，那么事件代理和事件没有关系吗？(参考这里)[http://coderlt.coding.me/2016/11/22/js-event/]\n\n## e.target vs e.currentTarget\n- e.target返回触发事件的节点\n- e.currentTarget 返回监听触发事件的节点，在冒泡和捕获阶段是非常有用的\n- 在事件代理中，e.target 是当前点击的目标元素，而 e.currentTarget 始终是事件的代理元素\n\n## 自定义事件\non，one，off，emit\none的情况单独用个数组存放\n","slug":"js-foundation-DOM事件机制","published":1,"date":"2017-04-26T07:12:57.000Z","updated":"2017-04-26T07:12:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ch0003dkzy6s1pdh7ye","content":"<h1 id=\"漫谈\"><a href=\"#漫谈\" class=\"headerlink\" title=\"漫谈\"></a>漫谈</h1><p>我们在node中很看见events事件操作模块， 事件操作有什么作用？为什么很多地方都存在？</p>\n<ul>\n<li>事件操作能使复杂的业务中抽象出独立的逻辑，跨模块之间传递数据，可以达到解耦</li>\n</ul>\n<h1 id=\"DOM事件\"><a href=\"#DOM事件\" class=\"headerlink\" title=\"DOM事件\"></a>DOM事件</h1><h2 id=\"DOM0级事件\"><a href=\"#DOM0级事件\" class=\"headerlink\" title=\"DOM0级事件\"></a>DOM0级事件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p onclick=&quot;alert(1)&quot;&gt;&lt;/p&gt;</div></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ul>\n<li>HTML和JS耦合在一起</li>\n<li>同一个元素不能绑定多个事件</li>\n</ul>\n<h2 id=\"DOM2\"><a href=\"#DOM2\" class=\"headerlink\" title=\"DOM2\"></a>DOM2</h2><p>el.addEventListener(eventName, callback, capture)<br>兼容性问题这里不多谈</p>\n<h2 id=\"DOM3级事件\"><a href=\"#DOM3级事件\" class=\"headerlink\" title=\"DOM3级事件\"></a>DOM3级事件</h2><p>增加了很多事件类型</p>\n<ol>\n<li>UI事件，如：scroll、load</li>\n<li>焦点事件： blur、focus</li>\n<li>鼠标事件： dbclick、mouseup</li>\n<li>滚轮事件： mousewheel</li>\n<li>文本事件： textInput</li>\n<li>键盘事件： keydown等<br>……</li>\n</ol>\n<h2 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h2><p>为什么会出现事件流，当我们给子父级同时绑定事件的时候，事件执行顺序的过程该是怎样的呢，所以这个事件执行的过程就是事件流动的过程</p>\n<h2 id=\"事件阶段\"><a href=\"#事件阶段\" class=\"headerlink\" title=\"事件阶段\"></a>事件阶段</h2><p>事件流的三个阶段：</p>\n<ul>\n<li>捕获阶段</li>\n<li>目标阶段</li>\n<li>冒泡阶段</li>\n</ul>\n<h2 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h2><p>绑定事件过多造成的问题</p>\n<ul>\n<li>函数是对象，会占用内存，内存中的对象越多，浏览器性能越差</li>\n<li>注册的事件一般都会指定DOM元素，事件越多，导致DOM元素访问次数越多，会延迟页面交互就绪时间。</li>\n<li>删除子元素的时候不用考虑删除绑定事件<br>为了减少事件的注册，我们使用一个代理元素是代理它内部所有子元素事件</li>\n</ul>\n<p>无论是Capture是true还是false，事件都会触发，那么事件代理和事件没有关系吗？(参考这里)[<a href=\"http://coderlt.coding.me/2016/11/22/js-event/\" target=\"_blank\" rel=\"external\">http://coderlt.coding.me/2016/11/22/js-event/</a>]</p>\n<h2 id=\"e-target-vs-e-currentTarget\"><a href=\"#e-target-vs-e-currentTarget\" class=\"headerlink\" title=\"e.target vs e.currentTarget\"></a>e.target vs e.currentTarget</h2><ul>\n<li>e.target返回触发事件的节点</li>\n<li>e.currentTarget 返回监听触发事件的节点，在冒泡和捕获阶段是非常有用的</li>\n<li>在事件代理中，e.target 是当前点击的目标元素，而 e.currentTarget 始终是事件的代理元素</li>\n</ul>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><p>on，one，off，emit<br>one的情况单独用个数组存放</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"漫谈\"><a href=\"#漫谈\" class=\"headerlink\" title=\"漫谈\"></a>漫谈</h1><p>我们在node中很看见events事件操作模块， 事件操作有什么作用？为什么很多地方都存在？</p>\n<ul>\n<li>事件操作能使复杂的业务中抽象出独立的逻辑，跨模块之间传递数据，可以达到解耦</li>\n</ul>\n<h1 id=\"DOM事件\"><a href=\"#DOM事件\" class=\"headerlink\" title=\"DOM事件\"></a>DOM事件</h1><h2 id=\"DOM0级事件\"><a href=\"#DOM0级事件\" class=\"headerlink\" title=\"DOM0级事件\"></a>DOM0级事件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p onclick=&quot;alert(1)&quot;&gt;&lt;/p&gt;</div></pre></td></tr></table></figure>\n<p>缺点：</p>\n<ul>\n<li>HTML和JS耦合在一起</li>\n<li>同一个元素不能绑定多个事件</li>\n</ul>\n<h2 id=\"DOM2\"><a href=\"#DOM2\" class=\"headerlink\" title=\"DOM2\"></a>DOM2</h2><p>el.addEventListener(eventName, callback, capture)<br>兼容性问题这里不多谈</p>\n<h2 id=\"DOM3级事件\"><a href=\"#DOM3级事件\" class=\"headerlink\" title=\"DOM3级事件\"></a>DOM3级事件</h2><p>增加了很多事件类型</p>\n<ol>\n<li>UI事件，如：scroll、load</li>\n<li>焦点事件： blur、focus</li>\n<li>鼠标事件： dbclick、mouseup</li>\n<li>滚轮事件： mousewheel</li>\n<li>文本事件： textInput</li>\n<li>键盘事件： keydown等<br>……</li>\n</ol>\n<h2 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h2><p>为什么会出现事件流，当我们给子父级同时绑定事件的时候，事件执行顺序的过程该是怎样的呢，所以这个事件执行的过程就是事件流动的过程</p>\n<h2 id=\"事件阶段\"><a href=\"#事件阶段\" class=\"headerlink\" title=\"事件阶段\"></a>事件阶段</h2><p>事件流的三个阶段：</p>\n<ul>\n<li>捕获阶段</li>\n<li>目标阶段</li>\n<li>冒泡阶段</li>\n</ul>\n<h2 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h2><p>绑定事件过多造成的问题</p>\n<ul>\n<li>函数是对象，会占用内存，内存中的对象越多，浏览器性能越差</li>\n<li>注册的事件一般都会指定DOM元素，事件越多，导致DOM元素访问次数越多，会延迟页面交互就绪时间。</li>\n<li>删除子元素的时候不用考虑删除绑定事件<br>为了减少事件的注册，我们使用一个代理元素是代理它内部所有子元素事件</li>\n</ul>\n<p>无论是Capture是true还是false，事件都会触发，那么事件代理和事件没有关系吗？(参考这里)[<a href=\"http://coderlt.coding.me/2016/11/22/js-event/\" target=\"_blank\" rel=\"external\">http://coderlt.coding.me/2016/11/22/js-event/</a>]</p>\n<h2 id=\"e-target-vs-e-currentTarget\"><a href=\"#e-target-vs-e-currentTarget\" class=\"headerlink\" title=\"e.target vs e.currentTarget\"></a>e.target vs e.currentTarget</h2><ul>\n<li>e.target返回触发事件的节点</li>\n<li>e.currentTarget 返回监听触发事件的节点，在冒泡和捕获阶段是非常有用的</li>\n<li>在事件代理中，e.target 是当前点击的目标元素，而 e.currentTarget 始终是事件的代理元素</li>\n</ul>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><p>on，one，off，emit<br>one的情况单独用个数组存放</p>\n"},{"title":"JavaScript的函数队列","type":"categories","_content":"\n##### @函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\n\n##### #解决方案： 定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next()开始执行下一个函数\n\n```\n\t1.先写个next函数吧\n\n\tlet stack = []\n\tlet index = 0\n\tfunction next() {\n\t\tlet fn = stack[index]\n\t\tindex += 1\n\t\tif(typeof fn === 'function') fn()\n\t}\n```\n\n```\n\tfunction one() {\n\t\tconsole.log('one')\n\t\tnext()\n\t}\n\tstack.push(one)\n\n\tfunction two() {\n\t\tsetTimeout(function(){\n\t\t\tconsole.log('two')\n\t\t\tnext()\n\t\t\t//小伙伴们注意next()后面的执行的程序不能保证执行顺序了，换句话说next()一定是函数执行的末尾\n\t\t})\n\t\t//比如在这里cosole.log(xxxxx)\n\t}\n\tstack.push(two)\n```\n\n```\n\t//开始执行\n\tnext()  // 打印出 one、two\n\n```\n\n\n","source":"_posts/js/foundation/JavaScript的函数队列.md","raw":"---\ntitle: JavaScript的函数队列\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n##### @函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\n\n##### #解决方案： 定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next()开始执行下一个函数\n\n```\n\t1.先写个next函数吧\n\n\tlet stack = []\n\tlet index = 0\n\tfunction next() {\n\t\tlet fn = stack[index]\n\t\tindex += 1\n\t\tif(typeof fn === 'function') fn()\n\t}\n```\n\n```\n\tfunction one() {\n\t\tconsole.log('one')\n\t\tnext()\n\t}\n\tstack.push(one)\n\n\tfunction two() {\n\t\tsetTimeout(function(){\n\t\t\tconsole.log('two')\n\t\t\tnext()\n\t\t\t//小伙伴们注意next()后面的执行的程序不能保证执行顺序了，换句话说next()一定是函数执行的末尾\n\t\t})\n\t\t//比如在这里cosole.log(xxxxx)\n\t}\n\tstack.push(two)\n```\n\n```\n\t//开始执行\n\tnext()  // 打印出 one、two\n\n```\n\n\n","slug":"js-foundation-JavaScript的函数队列","published":1,"date":"2017-04-23T11:10:19.000Z","updated":"2017-04-23T11:10:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ch1003fkzy61uy1b32c","content":"<h5 id=\"函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\"><a href=\"#函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\" class=\"headerlink\" title=\"@函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\"></a>@函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢</h5><h5 id=\"解决方案：-定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next-开始执行下一个函数\"><a href=\"#解决方案：-定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next-开始执行下一个函数\" class=\"headerlink\" title=\"#解决方案： 定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next()开始执行下一个函数\"></a>#解决方案： 定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next()开始执行下一个函数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.先写个next函数吧</div><div class=\"line\"></div><div class=\"line\">let stack = []</div><div class=\"line\">let index = 0</div><div class=\"line\">function next() &#123;</div><div class=\"line\">\tlet fn = stack[index]</div><div class=\"line\">\tindex += 1</div><div class=\"line\">\tif(typeof fn === &apos;function&apos;) fn()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function one() &#123;</div><div class=\"line\">\tconsole.log(&apos;one&apos;)</div><div class=\"line\">\tnext()</div><div class=\"line\">&#125;</div><div class=\"line\">stack.push(one)</div><div class=\"line\"></div><div class=\"line\">function two() &#123;</div><div class=\"line\">\tsetTimeout(function()&#123;</div><div class=\"line\">\t\tconsole.log(&apos;two&apos;)</div><div class=\"line\">\t\tnext()</div><div class=\"line\">\t\t//小伙伴们注意next()后面的执行的程序不能保证执行顺序了，换句话说next()一定是函数执行的末尾</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t//比如在这里cosole.log(xxxxx)</div><div class=\"line\">&#125;</div><div class=\"line\">stack.push(two)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//开始执行</div><div class=\"line\">next()  // 打印出 one、two</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\"><a href=\"#函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\" class=\"headerlink\" title=\"@函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢\"></a>@函数队列一开始你会想到什么，用个数组来存取一个一个函数，然后依次执行，但是函数是异步的，就不会按照我们想要的顺序执行了，可能你会想到在函数体内执行下一个函数，可惜下一个函数还没定义，怎么能执行，就算定义了，能执行，但是有个问题，我们在遍历函数的时候，是不是又重复了一遍，一下感觉没辙了，有没有？那我们换种思路吧，那么如何解决呢，node里有个connect中间件就可以实现队列，那么如何做到的呢</h5><h5 id=\"解决方案：-定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next-开始执行下一个函数\"><a href=\"#解决方案：-定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next-开始执行下一个函数\" class=\"headerlink\" title=\"#解决方案： 定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next()开始执行下一个函数\"></a>#解决方案： 定位到每个函数的末尾，然后找到下一个要执行的函数，即调用next()开始执行下一个函数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.先写个next函数吧</div><div class=\"line\"></div><div class=\"line\">let stack = []</div><div class=\"line\">let index = 0</div><div class=\"line\">function next() &#123;</div><div class=\"line\">\tlet fn = stack[index]</div><div class=\"line\">\tindex += 1</div><div class=\"line\">\tif(typeof fn === &apos;function&apos;) fn()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function one() &#123;</div><div class=\"line\">\tconsole.log(&apos;one&apos;)</div><div class=\"line\">\tnext()</div><div class=\"line\">&#125;</div><div class=\"line\">stack.push(one)</div><div class=\"line\"></div><div class=\"line\">function two() &#123;</div><div class=\"line\">\tsetTimeout(function()&#123;</div><div class=\"line\">\t\tconsole.log(&apos;two&apos;)</div><div class=\"line\">\t\tnext()</div><div class=\"line\">\t\t//小伙伴们注意next()后面的执行的程序不能保证执行顺序了，换句话说next()一定是函数执行的末尾</div><div class=\"line\">\t&#125;)</div><div class=\"line\">\t//比如在这里cosole.log(xxxxx)</div><div class=\"line\">&#125;</div><div class=\"line\">stack.push(two)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">//开始执行</div><div class=\"line\">next()  // 打印出 one、two</div></pre></td></tr></table></figure>\n"},{"title":"bind函数的深入实现","type":"categories","_content":"\n## 背景（this的绑定）\n\n### 隐式绑定\n\n首先要清楚调用栈和调用域的概念\n```\n\nfunction foo() {\n\t//调用栈 baz\n\t//调用域 baz\n\tconsole.log(\"foo\")\n}\n\nfunction bar() {\n\t//调用栈 window\n\t//调用域 window\n\tconsole.log(\"baz\")\n\tbaz()\n}\n\nfunction baz() {\n\t//调用栈 bar\n\t//调用域 bar\n\tconsole.log(\"baz\")\n\tfoo()\n}\n\nbar()\n```\n\n所以其实\n\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj2 = {\n    a: 42,\n    foo: foo\n};\n\nvar obj1 = {\n    a: 2,\n    obj2: obj2\n};\n\nobj1.obj2.foo(); // 42 调用的是自己作用域的属性，即obj2\n\n```\n\n但是容易造成**隐式丢失**\n\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nvar bar = obj.foo; \n\nvar a = \"oops, global\"; \nbar();\n\n```\n以上你觉得会输出什么，相信你一定会说\"oops, global\"吧，那就对了！！！这种调用方式只是把foo的引用委托给bar了而已，其实bar的作用域还是window，所以答案就是\"oops, global\"，\n\n\n### 默认绑定\n作为一个独立函数调用\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // 2\n\n```\n严格模式下绑定无效\n```\nfunction foo() {\n    \"use strict\";\n\n    console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // TypeError: `this` is `undefined`\n```\n\n### 显示绑定（call(),apply())\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call( obj ); // 2\n```\n### 硬绑定\n就是在显示绑定外面包了一层函数，这样之后的操作都不影响之前的绑定\n\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    foo.call( obj );\n};\n\nbar(); // 2\nsetTimeout( bar, 100 ); // 2\n\n// `bar` hard binds `foo`'s `this` to `obj`\n// so that it cannot be overriden\nbar.call( window ); // 2\n```\n#### 硬绑定之辅助函数（接受参数，并返回值）\n```\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\n// simple `bind` helper\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply( obj, arguments );\n    };\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n### new绑定\n\n```\nfunction foo(n) {\n    this.age = n;\n    this.name = 'wbcz'\n}\n  \nvar bar =  new foo(1)\n\nconsole.log(bar) // foo {age: 1, name: \"wbcz\"}\n\n//如果foo原型链上也有内容，比如添加\n\nfoo.prototype.getName = function() {\n    return this.name;\n}\n//在控制台打印出的proto中，就有getName属性\n\n```\n温习一下new关键字的时候，发生了什么\n- 创建一个新的对象\n- 这个对象会被[prototype]连接\n- this会绑定到这个函数上\n- 如果函数没有返回新的对象，那么就将this作为新的对象返回\n\n\n### 优先级比较（new绑定>显示绑定>隐式绑定）\n\n**显示绑定call vs .绑定**\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj1 = {\n    a: 2,\n    foo: foo\n};\n\nvar obj2 = {\n    a: 3,\n    foo: foo\n};\n\nobj1.foo(); // 2\nobj2.foo(); // 3\n\nobj1.foo.call( obj2 ); // 3  输出的值是obj2下作用域的属性值，显然call的优先级高\nobj2.foo.call( obj1 ); // 2\n\n```\nnew绑定 vs 显示绑定\n\n```\nfunction foo(n) {\n\tthis.a = n\n}\n\nvar obj1 = {}\nvar bar = foo.bind(obj1)\nbar(2) \nconsole.log(obj1.a)  //2\n\nvar baz = new bar(3)\nconsole.log(baz.a)  //3\nconsole.log(obj1.a)  //2\n//new修改了硬绑定调用bar()中的this\n```\n\n## bind函数的解析\n\n有了上面的基础，来解析bind函数也就不难了，首先你要知道bind拿来做什么？没做他主要是拿来做this的指定和参数的传递，实现函数柯里化\n\n```\nfunction add(a, b, c) {\n    var i = a+b+c;\n    console.log(i);\n    return i;\n}\n\nvar func = add.bind(undefined, 100);//给add()传了第一个参数a\nfunc(1, 2);//103，继续传入b和c\n\nvar func2 = func.bind(undefined, 200);//给func2传入第一个参数，也就是b，此前func已有参数a=100\nfunc2(10);//310,继续传入c，100+200+10\n\n//由上可以看出add被重用了，并且有初始化配置某几项，用bind先进行绑定，将复杂的函数拆分为简单的子函数\n```\n\n```\nif(!Function.prototype.bind) {\n\tFunction.prototype.bind = function (oThis) {//传递执行的作用域的对象\n\t\tif(typeof this != \"function\") {//如果不是bind的对象不是一个函数\n\t\t\tthrow new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t\t}\n\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 1),//函数被调用执行的时候的arguments转为数组，因为第一个参数是绑定作用域的对象，所以要去掉\n\t\tfTobind = this\n\t\tfNOP = function() {}\n\t\tfBound = function() {\n\t\t\treturn fTobind.apply(\n\t\t\t\tthis instanoThisceof fNOP ? this //当用new方式调用的时候\n\t\t\t\t: oThis || this, \n\t\t\t\taArgs.concat(Array.prototype.slice.call(arguments)) //此处的arguments和上面的arguments不一样，最后通过concat所有函数添加到一起\n\t\t\t)\n\t\t}\n\t\tfNOP.prototype = this.prototype //为了将当前的函数的属性委托给新的对象,防止没法获取需要绑定的函数的属性，见如下实例\n\t\tfBound.prototype = new fNOP() \n\t\treturn fBound\n\t}\n}\n\nfunction foo(n) {\n\tconsole.log(this.a)\n\treturn this.a + n\n}\n\nvar func = foo.bind({a: 1}, 10) //1\nvar obj = new func({a: 1}, 40)\nconsole.log(obj.a)  // undefined\n```\n","source":"_posts/js/foundation/bind函数的深入实现.md","raw":"---\ntitle: bind函数的深入实现\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n## 背景（this的绑定）\n\n### 隐式绑定\n\n首先要清楚调用栈和调用域的概念\n```\n\nfunction foo() {\n\t//调用栈 baz\n\t//调用域 baz\n\tconsole.log(\"foo\")\n}\n\nfunction bar() {\n\t//调用栈 window\n\t//调用域 window\n\tconsole.log(\"baz\")\n\tbaz()\n}\n\nfunction baz() {\n\t//调用栈 bar\n\t//调用域 bar\n\tconsole.log(\"baz\")\n\tfoo()\n}\n\nbar()\n```\n\n所以其实\n\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj2 = {\n    a: 42,\n    foo: foo\n};\n\nvar obj1 = {\n    a: 2,\n    obj2: obj2\n};\n\nobj1.obj2.foo(); // 42 调用的是自己作用域的属性，即obj2\n\n```\n\n但是容易造成**隐式丢失**\n\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nvar bar = obj.foo; \n\nvar a = \"oops, global\"; \nbar();\n\n```\n以上你觉得会输出什么，相信你一定会说\"oops, global\"吧，那就对了！！！这种调用方式只是把foo的引用委托给bar了而已，其实bar的作用域还是window，所以答案就是\"oops, global\"，\n\n\n### 默认绑定\n作为一个独立函数调用\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // 2\n\n```\n严格模式下绑定无效\n```\nfunction foo() {\n    \"use strict\";\n\n    console.log( this.a );\n}\n\nvar a = 2;\n\nfoo(); // TypeError: `this` is `undefined`\n```\n\n### 显示绑定（call(),apply())\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nfoo.call( obj ); // 2\n```\n### 硬绑定\n就是在显示绑定外面包了一层函数，这样之后的操作都不影响之前的绑定\n\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = function() {\n    foo.call( obj );\n};\n\nbar(); // 2\nsetTimeout( bar, 100 ); // 2\n\n// `bar` hard binds `foo`'s `this` to `obj`\n// so that it cannot be overriden\nbar.call( window ); // 2\n```\n#### 硬绑定之辅助函数（接受参数，并返回值）\n```\nfunction foo(something) {\n    console.log( this.a, something );\n    return this.a + something;\n}\n\n// simple `bind` helper\nfunction bind(fn, obj) {\n    return function() {\n        return fn.apply( obj, arguments );\n    };\n}\n\nvar obj = {\n    a: 2\n};\n\nvar bar = bind( foo, obj );\n\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n### new绑定\n\n```\nfunction foo(n) {\n    this.age = n;\n    this.name = 'wbcz'\n}\n  \nvar bar =  new foo(1)\n\nconsole.log(bar) // foo {age: 1, name: \"wbcz\"}\n\n//如果foo原型链上也有内容，比如添加\n\nfoo.prototype.getName = function() {\n    return this.name;\n}\n//在控制台打印出的proto中，就有getName属性\n\n```\n温习一下new关键字的时候，发生了什么\n- 创建一个新的对象\n- 这个对象会被[prototype]连接\n- this会绑定到这个函数上\n- 如果函数没有返回新的对象，那么就将this作为新的对象返回\n\n\n### 优先级比较（new绑定>显示绑定>隐式绑定）\n\n**显示绑定call vs .绑定**\n```\nfunction foo() {\n    console.log( this.a );\n}\n\nvar obj1 = {\n    a: 2,\n    foo: foo\n};\n\nvar obj2 = {\n    a: 3,\n    foo: foo\n};\n\nobj1.foo(); // 2\nobj2.foo(); // 3\n\nobj1.foo.call( obj2 ); // 3  输出的值是obj2下作用域的属性值，显然call的优先级高\nobj2.foo.call( obj1 ); // 2\n\n```\nnew绑定 vs 显示绑定\n\n```\nfunction foo(n) {\n\tthis.a = n\n}\n\nvar obj1 = {}\nvar bar = foo.bind(obj1)\nbar(2) \nconsole.log(obj1.a)  //2\n\nvar baz = new bar(3)\nconsole.log(baz.a)  //3\nconsole.log(obj1.a)  //2\n//new修改了硬绑定调用bar()中的this\n```\n\n## bind函数的解析\n\n有了上面的基础，来解析bind函数也就不难了，首先你要知道bind拿来做什么？没做他主要是拿来做this的指定和参数的传递，实现函数柯里化\n\n```\nfunction add(a, b, c) {\n    var i = a+b+c;\n    console.log(i);\n    return i;\n}\n\nvar func = add.bind(undefined, 100);//给add()传了第一个参数a\nfunc(1, 2);//103，继续传入b和c\n\nvar func2 = func.bind(undefined, 200);//给func2传入第一个参数，也就是b，此前func已有参数a=100\nfunc2(10);//310,继续传入c，100+200+10\n\n//由上可以看出add被重用了，并且有初始化配置某几项，用bind先进行绑定，将复杂的函数拆分为简单的子函数\n```\n\n```\nif(!Function.prototype.bind) {\n\tFunction.prototype.bind = function (oThis) {//传递执行的作用域的对象\n\t\tif(typeof this != \"function\") {//如果不是bind的对象不是一个函数\n\t\t\tthrow new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t\t}\n\n\t\tvar aArgs = Array.prototype.slice.call(arguments, 1),//函数被调用执行的时候的arguments转为数组，因为第一个参数是绑定作用域的对象，所以要去掉\n\t\tfTobind = this\n\t\tfNOP = function() {}\n\t\tfBound = function() {\n\t\t\treturn fTobind.apply(\n\t\t\t\tthis instanoThisceof fNOP ? this //当用new方式调用的时候\n\t\t\t\t: oThis || this, \n\t\t\t\taArgs.concat(Array.prototype.slice.call(arguments)) //此处的arguments和上面的arguments不一样，最后通过concat所有函数添加到一起\n\t\t\t)\n\t\t}\n\t\tfNOP.prototype = this.prototype //为了将当前的函数的属性委托给新的对象,防止没法获取需要绑定的函数的属性，见如下实例\n\t\tfBound.prototype = new fNOP() \n\t\treturn fBound\n\t}\n}\n\nfunction foo(n) {\n\tconsole.log(this.a)\n\treturn this.a + n\n}\n\nvar func = foo.bind({a: 1}, 10) //1\nvar obj = new func({a: 1}, 40)\nconsole.log(obj.a)  // undefined\n```\n","slug":"js-foundation-bind函数的深入实现","published":1,"date":"2017-04-23T11:10:09.000Z","updated":"2017-04-23T11:10:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ch3003gkzy6fw5kjs7x","content":"<h2 id=\"背景（this的绑定）\"><a href=\"#背景（this的绑定）\" class=\"headerlink\" title=\"背景（this的绑定）\"></a>背景（this的绑定）</h2><h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>首先要清楚调用栈和调用域的概念<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function foo() &#123;</div><div class=\"line\">\t//调用栈 baz</div><div class=\"line\">\t//调用域 baz</div><div class=\"line\">\tconsole.log(&quot;foo&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function bar() &#123;</div><div class=\"line\">\t//调用栈 window</div><div class=\"line\">\t//调用域 window</div><div class=\"line\">\tconsole.log(&quot;baz&quot;)</div><div class=\"line\">\tbaz()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function baz() &#123;</div><div class=\"line\">\t//调用栈 bar</div><div class=\"line\">\t//调用域 bar</div><div class=\"line\">\tconsole.log(&quot;baz&quot;)</div><div class=\"line\">\tfoo()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar()</div></pre></td></tr></table></figure></p>\n<p>所以其实</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">    a: 42,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">    a: 2,</div><div class=\"line\">    obj2: obj2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">obj1.obj2.foo(); // 42 调用的是自己作用域的属性，即obj2</div></pre></td></tr></table></figure>\n<p>但是容易造成<strong>隐式丢失</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var bar = obj.foo; </div><div class=\"line\"></div><div class=\"line\">var a = &quot;oops, global&quot;; </div><div class=\"line\">bar();</div></pre></td></tr></table></figure>\n<p>以上你觉得会输出什么，相信你一定会说”oops, global”吧，那就对了！！！这种调用方式只是把foo的引用委托给bar了而已，其实bar的作用域还是window，所以答案就是”oops, global”，</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>作为一个独立函数调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var a = 2;</div><div class=\"line\"></div><div class=\"line\">foo(); // 2</div></pre></td></tr></table></figure></p>\n<p>严格模式下绑定无效<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    &quot;use strict&quot;;</div><div class=\"line\"></div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var a = 2;</div><div class=\"line\"></div><div class=\"line\">foo(); // TypeError: `this` is `undefined`</div></pre></td></tr></table></figure></p>\n<h3 id=\"显示绑定（call-apply\"><a href=\"#显示绑定（call-apply\" class=\"headerlink\" title=\"显示绑定（call(),apply())\"></a>显示绑定（call(),apply())</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">foo.call( obj ); // 2</div></pre></td></tr></table></figure>\n<h3 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h3><p>就是在显示绑定外面包了一层函数，这样之后的操作都不影响之前的绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var bar = function() &#123;</div><div class=\"line\">    foo.call( obj );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">bar(); // 2</div><div class=\"line\">setTimeout( bar, 100 ); // 2</div><div class=\"line\"></div><div class=\"line\">// `bar` hard binds `foo`&apos;s `this` to `obj`</div><div class=\"line\">// so that it cannot be overriden</div><div class=\"line\">bar.call( window ); // 2</div></pre></td></tr></table></figure>\n<h4 id=\"硬绑定之辅助函数（接受参数，并返回值）\"><a href=\"#硬绑定之辅助函数（接受参数，并返回值）\" class=\"headerlink\" title=\"硬绑定之辅助函数（接受参数，并返回值）\"></a>硬绑定之辅助函数（接受参数，并返回值）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(something) &#123;</div><div class=\"line\">    console.log( this.a, something );</div><div class=\"line\">    return this.a + something;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// simple `bind` helper</div><div class=\"line\">function bind(fn, obj) &#123;</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        return fn.apply( obj, arguments );</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var bar = bind( foo, obj );</div><div class=\"line\"></div><div class=\"line\">var b = bar( 3 ); // 2 3</div><div class=\"line\">console.log( b ); // 5</div></pre></td></tr></table></figure>\n<h3 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(n) &#123;</div><div class=\"line\">    this.age = n;</div><div class=\"line\">    this.name = &apos;wbcz&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">var bar =  new foo(1)</div><div class=\"line\"></div><div class=\"line\">console.log(bar) // foo &#123;age: 1, name: &quot;wbcz&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">//如果foo原型链上也有内容，比如添加</div><div class=\"line\"></div><div class=\"line\">foo.prototype.getName = function() &#123;</div><div class=\"line\">    return this.name;</div><div class=\"line\">&#125;</div><div class=\"line\">//在控制台打印出的proto中，就有getName属性</div></pre></td></tr></table></figure>\n<p>温习一下new关键字的时候，发生了什么</p>\n<ul>\n<li>创建一个新的对象</li>\n<li>这个对象会被[prototype]连接</li>\n<li>this会绑定到这个函数上</li>\n<li>如果函数没有返回新的对象，那么就将this作为新的对象返回</li>\n</ul>\n<h3 id=\"优先级比较（new绑定-gt-显示绑定-gt-隐式绑定）\"><a href=\"#优先级比较（new绑定-gt-显示绑定-gt-隐式绑定）\" class=\"headerlink\" title=\"优先级比较（new绑定&gt;显示绑定&gt;隐式绑定）\"></a>优先级比较（new绑定&gt;显示绑定&gt;隐式绑定）</h3><p><strong>显示绑定call vs .绑定</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">    a: 2,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">    a: 3,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">obj1.foo(); // 2</div><div class=\"line\">obj2.foo(); // 3</div><div class=\"line\"></div><div class=\"line\">obj1.foo.call( obj2 ); // 3  输出的值是obj2下作用域的属性值，显然call的优先级高</div><div class=\"line\">obj2.foo.call( obj1 ); // 2</div></pre></td></tr></table></figure></p>\n<p>new绑定 vs 显示绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(n) &#123;</div><div class=\"line\">\tthis.a = n</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj1 = &#123;&#125;</div><div class=\"line\">var bar = foo.bind(obj1)</div><div class=\"line\">bar(2) </div><div class=\"line\">console.log(obj1.a)  //2</div><div class=\"line\"></div><div class=\"line\">var baz = new bar(3)</div><div class=\"line\">console.log(baz.a)  //3</div><div class=\"line\">console.log(obj1.a)  //2</div><div class=\"line\">//new修改了硬绑定调用bar()中的this</div></pre></td></tr></table></figure>\n<h2 id=\"bind函数的解析\"><a href=\"#bind函数的解析\" class=\"headerlink\" title=\"bind函数的解析\"></a>bind函数的解析</h2><p>有了上面的基础，来解析bind函数也就不难了，首先你要知道bind拿来做什么？没做他主要是拿来做this的指定和参数的传递，实现函数柯里化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(a, b, c) &#123;</div><div class=\"line\">    var i = a+b+c;</div><div class=\"line\">    console.log(i);</div><div class=\"line\">    return i;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var func = add.bind(undefined, 100);//给add()传了第一个参数a</div><div class=\"line\">func(1, 2);//103，继续传入b和c</div><div class=\"line\"></div><div class=\"line\">var func2 = func.bind(undefined, 200);//给func2传入第一个参数，也就是b，此前func已有参数a=100</div><div class=\"line\">func2(10);//310,继续传入c，100+200+10</div><div class=\"line\"></div><div class=\"line\">//由上可以看出add被重用了，并且有初始化配置某几项，用bind先进行绑定，将复杂的函数拆分为简单的子函数</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(!Function.prototype.bind) &#123;</div><div class=\"line\">\tFunction.prototype.bind = function (oThis) &#123;//传递执行的作用域的对象</div><div class=\"line\">\t\tif(typeof this != &quot;function&quot;) &#123;//如果不是bind的对象不是一个函数</div><div class=\"line\">\t\t\tthrow new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tvar aArgs = Array.prototype.slice.call(arguments, 1),//函数被调用执行的时候的arguments转为数组，因为第一个参数是绑定作用域的对象，所以要去掉</div><div class=\"line\">\t\tfTobind = this</div><div class=\"line\">\t\tfNOP = function() &#123;&#125;</div><div class=\"line\">\t\tfBound = function() &#123;</div><div class=\"line\">\t\t\treturn fTobind.apply(</div><div class=\"line\">\t\t\t\tthis instanoThisceof fNOP ? this //当用new方式调用的时候</div><div class=\"line\">\t\t\t\t: oThis || this, </div><div class=\"line\">\t\t\t\taArgs.concat(Array.prototype.slice.call(arguments)) //此处的arguments和上面的arguments不一样，最后通过concat所有函数添加到一起</div><div class=\"line\">\t\t\t)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfNOP.prototype = this.prototype //为了将当前的函数的属性委托给新的对象,防止没法获取需要绑定的函数的属性，见如下实例</div><div class=\"line\">\t\tfBound.prototype = new fNOP() </div><div class=\"line\">\t\treturn fBound</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function foo(n) &#123;</div><div class=\"line\">\tconsole.log(this.a)</div><div class=\"line\">\treturn this.a + n</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var func = foo.bind(&#123;a: 1&#125;, 10) //1</div><div class=\"line\">var obj = new func(&#123;a: 1&#125;, 40)</div><div class=\"line\">console.log(obj.a)  // undefined</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景（this的绑定）\"><a href=\"#背景（this的绑定）\" class=\"headerlink\" title=\"背景（this的绑定）\"></a>背景（this的绑定）</h2><h3 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h3><p>首先要清楚调用栈和调用域的概念<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">function foo() &#123;</div><div class=\"line\">\t//调用栈 baz</div><div class=\"line\">\t//调用域 baz</div><div class=\"line\">\tconsole.log(&quot;foo&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function bar() &#123;</div><div class=\"line\">\t//调用栈 window</div><div class=\"line\">\t//调用域 window</div><div class=\"line\">\tconsole.log(&quot;baz&quot;)</div><div class=\"line\">\tbaz()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function baz() &#123;</div><div class=\"line\">\t//调用栈 bar</div><div class=\"line\">\t//调用域 bar</div><div class=\"line\">\tconsole.log(&quot;baz&quot;)</div><div class=\"line\">\tfoo()</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bar()</div></pre></td></tr></table></figure></p>\n<p>所以其实</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">    a: 42,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">    a: 2,</div><div class=\"line\">    obj2: obj2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">obj1.obj2.foo(); // 42 调用的是自己作用域的属性，即obj2</div></pre></td></tr></table></figure>\n<p>但是容易造成<strong>隐式丢失</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var bar = obj.foo; </div><div class=\"line\"></div><div class=\"line\">var a = &quot;oops, global&quot;; </div><div class=\"line\">bar();</div></pre></td></tr></table></figure>\n<p>以上你觉得会输出什么，相信你一定会说”oops, global”吧，那就对了！！！这种调用方式只是把foo的引用委托给bar了而已，其实bar的作用域还是window，所以答案就是”oops, global”，</p>\n<h3 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h3><p>作为一个独立函数调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var a = 2;</div><div class=\"line\"></div><div class=\"line\">foo(); // 2</div></pre></td></tr></table></figure></p>\n<p>严格模式下绑定无效<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    &quot;use strict&quot;;</div><div class=\"line\"></div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var a = 2;</div><div class=\"line\"></div><div class=\"line\">foo(); // TypeError: `this` is `undefined`</div></pre></td></tr></table></figure></p>\n<h3 id=\"显示绑定（call-apply\"><a href=\"#显示绑定（call-apply\" class=\"headerlink\" title=\"显示绑定（call(),apply())\"></a>显示绑定（call(),apply())</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">foo.call( obj ); // 2</div></pre></td></tr></table></figure>\n<h3 id=\"硬绑定\"><a href=\"#硬绑定\" class=\"headerlink\" title=\"硬绑定\"></a>硬绑定</h3><p>就是在显示绑定外面包了一层函数，这样之后的操作都不影响之前的绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var bar = function() &#123;</div><div class=\"line\">    foo.call( obj );</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">bar(); // 2</div><div class=\"line\">setTimeout( bar, 100 ); // 2</div><div class=\"line\"></div><div class=\"line\">// `bar` hard binds `foo`&apos;s `this` to `obj`</div><div class=\"line\">// so that it cannot be overriden</div><div class=\"line\">bar.call( window ); // 2</div></pre></td></tr></table></figure>\n<h4 id=\"硬绑定之辅助函数（接受参数，并返回值）\"><a href=\"#硬绑定之辅助函数（接受参数，并返回值）\" class=\"headerlink\" title=\"硬绑定之辅助函数（接受参数，并返回值）\"></a>硬绑定之辅助函数（接受参数，并返回值）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(something) &#123;</div><div class=\"line\">    console.log( this.a, something );</div><div class=\"line\">    return this.a + something;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// simple `bind` helper</div><div class=\"line\">function bind(fn, obj) &#123;</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        return fn.apply( obj, arguments );</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj = &#123;</div><div class=\"line\">    a: 2</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var bar = bind( foo, obj );</div><div class=\"line\"></div><div class=\"line\">var b = bar( 3 ); // 2 3</div><div class=\"line\">console.log( b ); // 5</div></pre></td></tr></table></figure>\n<h3 id=\"new绑定\"><a href=\"#new绑定\" class=\"headerlink\" title=\"new绑定\"></a>new绑定</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(n) &#123;</div><div class=\"line\">    this.age = n;</div><div class=\"line\">    this.name = &apos;wbcz&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">  </div><div class=\"line\">var bar =  new foo(1)</div><div class=\"line\"></div><div class=\"line\">console.log(bar) // foo &#123;age: 1, name: &quot;wbcz&quot;&#125;</div><div class=\"line\"></div><div class=\"line\">//如果foo原型链上也有内容，比如添加</div><div class=\"line\"></div><div class=\"line\">foo.prototype.getName = function() &#123;</div><div class=\"line\">    return this.name;</div><div class=\"line\">&#125;</div><div class=\"line\">//在控制台打印出的proto中，就有getName属性</div></pre></td></tr></table></figure>\n<p>温习一下new关键字的时候，发生了什么</p>\n<ul>\n<li>创建一个新的对象</li>\n<li>这个对象会被[prototype]连接</li>\n<li>this会绑定到这个函数上</li>\n<li>如果函数没有返回新的对象，那么就将this作为新的对象返回</li>\n</ul>\n<h3 id=\"优先级比较（new绑定-gt-显示绑定-gt-隐式绑定）\"><a href=\"#优先级比较（new绑定-gt-显示绑定-gt-隐式绑定）\" class=\"headerlink\" title=\"优先级比较（new绑定&gt;显示绑定&gt;隐式绑定）\"></a>优先级比较（new绑定&gt;显示绑定&gt;隐式绑定）</h3><p><strong>显示绑定call vs .绑定</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo() &#123;</div><div class=\"line\">    console.log( this.a );</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj1 = &#123;</div><div class=\"line\">    a: 2,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">var obj2 = &#123;</div><div class=\"line\">    a: 3,</div><div class=\"line\">    foo: foo</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">obj1.foo(); // 2</div><div class=\"line\">obj2.foo(); // 3</div><div class=\"line\"></div><div class=\"line\">obj1.foo.call( obj2 ); // 3  输出的值是obj2下作用域的属性值，显然call的优先级高</div><div class=\"line\">obj2.foo.call( obj1 ); // 2</div></pre></td></tr></table></figure></p>\n<p>new绑定 vs 显示绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function foo(n) &#123;</div><div class=\"line\">\tthis.a = n</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var obj1 = &#123;&#125;</div><div class=\"line\">var bar = foo.bind(obj1)</div><div class=\"line\">bar(2) </div><div class=\"line\">console.log(obj1.a)  //2</div><div class=\"line\"></div><div class=\"line\">var baz = new bar(3)</div><div class=\"line\">console.log(baz.a)  //3</div><div class=\"line\">console.log(obj1.a)  //2</div><div class=\"line\">//new修改了硬绑定调用bar()中的this</div></pre></td></tr></table></figure>\n<h2 id=\"bind函数的解析\"><a href=\"#bind函数的解析\" class=\"headerlink\" title=\"bind函数的解析\"></a>bind函数的解析</h2><p>有了上面的基础，来解析bind函数也就不难了，首先你要知道bind拿来做什么？没做他主要是拿来做this的指定和参数的传递，实现函数柯里化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function add(a, b, c) &#123;</div><div class=\"line\">    var i = a+b+c;</div><div class=\"line\">    console.log(i);</div><div class=\"line\">    return i;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var func = add.bind(undefined, 100);//给add()传了第一个参数a</div><div class=\"line\">func(1, 2);//103，继续传入b和c</div><div class=\"line\"></div><div class=\"line\">var func2 = func.bind(undefined, 200);//给func2传入第一个参数，也就是b，此前func已有参数a=100</div><div class=\"line\">func2(10);//310,继续传入c，100+200+10</div><div class=\"line\"></div><div class=\"line\">//由上可以看出add被重用了，并且有初始化配置某几项，用bind先进行绑定，将复杂的函数拆分为简单的子函数</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">if(!Function.prototype.bind) &#123;</div><div class=\"line\">\tFunction.prototype.bind = function (oThis) &#123;//传递执行的作用域的对象</div><div class=\"line\">\t\tif(typeof this != &quot;function&quot;) &#123;//如果不是bind的对象不是一个函数</div><div class=\"line\">\t\t\tthrow new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tvar aArgs = Array.prototype.slice.call(arguments, 1),//函数被调用执行的时候的arguments转为数组，因为第一个参数是绑定作用域的对象，所以要去掉</div><div class=\"line\">\t\tfTobind = this</div><div class=\"line\">\t\tfNOP = function() &#123;&#125;</div><div class=\"line\">\t\tfBound = function() &#123;</div><div class=\"line\">\t\t\treturn fTobind.apply(</div><div class=\"line\">\t\t\t\tthis instanoThisceof fNOP ? this //当用new方式调用的时候</div><div class=\"line\">\t\t\t\t: oThis || this, </div><div class=\"line\">\t\t\t\taArgs.concat(Array.prototype.slice.call(arguments)) //此处的arguments和上面的arguments不一样，最后通过concat所有函数添加到一起</div><div class=\"line\">\t\t\t)</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfNOP.prototype = this.prototype //为了将当前的函数的属性委托给新的对象,防止没法获取需要绑定的函数的属性，见如下实例</div><div class=\"line\">\t\tfBound.prototype = new fNOP() </div><div class=\"line\">\t\treturn fBound</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function foo(n) &#123;</div><div class=\"line\">\tconsole.log(this.a)</div><div class=\"line\">\treturn this.a + n</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var func = foo.bind(&#123;a: 1&#125;, 10) //1</div><div class=\"line\">var obj = new func(&#123;a: 1&#125;, 40)</div><div class=\"line\">console.log(obj.a)  // undefined</div></pre></td></tr></table></figure>\n"},{"title":"Javascript动画实现原理","type":"categories","_content":"\n## 运动的本质\n> 让某个元素的某个属性到目标上去中小数精度问题：所以用整数做运算\n\n### 步骤\n> 第一步清除定时器；\n第二步开启定时器\n第三部改变坐标，运动\n定时器和坐标\n匀速运动必须保持距离恰好能整除速度\n点一下开一个定时器，重复点击的bug，所以事先就要清除定时器，每次只能开一个\n定时器的清除：不同的物体用各自的定时器，防止互相影响\n\n## 运动的形式\n\n###  摩擦运动\n> 逐渐变慢，到停止\n\n### 缓冲运动\n> 可以精确到某个目的点，距离越远，速度越大\n> 速度 = （目标值 - 当前值）/缩放系数\n> bug: 速度取整， 值取整\n\n问题：\n```\n\t1.如果让speed--，但是为负数的时候会跑回来\n\t2.所以可以让speed/正数，或者speed*（0-1）的数，就可以是减速运动，但是不能准确到达目标点\n```\n\n解决方案：\n```\nspeed = （500-offsetLeft）*0.8  //按常理来说是无限接近终点\n但是还是不能准确到终点\n为什么会造成这情况呢\n```\n```\n上面的代码中，我们只加入了一行代码，用于监控Div的当前位置（这是一种常用的调试手段）：\ndocument.title=oDiv.offsetLeft;\n运行这段代码后，我们看到物体的位置，最终停在293像素的位置，不再向前走了，这是为什么呢？\n实际上，当物体距离目标点非常近的时候，距离可能会小于缩放系数，这时速度会是一个小数。而浏览器能接受的都是整数（像素），给他一个小数，会自动忽略小数部分，物体不会发生实际的移动。\n\n因为offsetWidth是经过js内部运算过后的，是没有单位的，他运算方式是四舍五入运算\n\n当速度小于0.5的时候，会一直处于舍得状态，所以一直到达不了终点，所以需要我们代码解决\n所以对速度进行向上取整Math.ceil(speed)\n\n但是到大于-0.5了如果从远返回的时候，speed为负值\n所以负数要向下取整Math.floor(speed)\n```\n## 总结：\n> 让某个元素的属性到目标上去\n> 运动的形式和速度无关，和算法有关","source":"_posts/js/foundation/Javascript动画实现原理.md","raw":"---\ntitle: Javascript动画实现原理\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n## 运动的本质\n> 让某个元素的某个属性到目标上去中小数精度问题：所以用整数做运算\n\n### 步骤\n> 第一步清除定时器；\n第二步开启定时器\n第三部改变坐标，运动\n定时器和坐标\n匀速运动必须保持距离恰好能整除速度\n点一下开一个定时器，重复点击的bug，所以事先就要清除定时器，每次只能开一个\n定时器的清除：不同的物体用各自的定时器，防止互相影响\n\n## 运动的形式\n\n###  摩擦运动\n> 逐渐变慢，到停止\n\n### 缓冲运动\n> 可以精确到某个目的点，距离越远，速度越大\n> 速度 = （目标值 - 当前值）/缩放系数\n> bug: 速度取整， 值取整\n\n问题：\n```\n\t1.如果让speed--，但是为负数的时候会跑回来\n\t2.所以可以让speed/正数，或者speed*（0-1）的数，就可以是减速运动，但是不能准确到达目标点\n```\n\n解决方案：\n```\nspeed = （500-offsetLeft）*0.8  //按常理来说是无限接近终点\n但是还是不能准确到终点\n为什么会造成这情况呢\n```\n```\n上面的代码中，我们只加入了一行代码，用于监控Div的当前位置（这是一种常用的调试手段）：\ndocument.title=oDiv.offsetLeft;\n运行这段代码后，我们看到物体的位置，最终停在293像素的位置，不再向前走了，这是为什么呢？\n实际上，当物体距离目标点非常近的时候，距离可能会小于缩放系数，这时速度会是一个小数。而浏览器能接受的都是整数（像素），给他一个小数，会自动忽略小数部分，物体不会发生实际的移动。\n\n因为offsetWidth是经过js内部运算过后的，是没有单位的，他运算方式是四舍五入运算\n\n当速度小于0.5的时候，会一直处于舍得状态，所以一直到达不了终点，所以需要我们代码解决\n所以对速度进行向上取整Math.ceil(speed)\n\n但是到大于-0.5了如果从远返回的时候，speed为负值\n所以负数要向下取整Math.floor(speed)\n```\n## 总结：\n> 让某个元素的属性到目标上去\n> 运动的形式和速度无关，和算法有关","slug":"js-foundation-Javascript动画实现原理","published":1,"date":"2017-04-23T11:10:15.000Z","updated":"2017-04-23T11:10:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ch5003jkzy621e6zjze","content":"<h2 id=\"运动的本质\"><a href=\"#运动的本质\" class=\"headerlink\" title=\"运动的本质\"></a>运动的本质</h2><blockquote>\n<p>让某个元素的某个属性到目标上去中小数精度问题：所以用整数做运算</p>\n</blockquote>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><blockquote>\n<p>第一步清除定时器；<br>第二步开启定时器<br>第三部改变坐标，运动<br>定时器和坐标<br>匀速运动必须保持距离恰好能整除速度<br>点一下开一个定时器，重复点击的bug，所以事先就要清除定时器，每次只能开一个<br>定时器的清除：不同的物体用各自的定时器，防止互相影响</p>\n</blockquote>\n<h2 id=\"运动的形式\"><a href=\"#运动的形式\" class=\"headerlink\" title=\"运动的形式\"></a>运动的形式</h2><h3 id=\"摩擦运动\"><a href=\"#摩擦运动\" class=\"headerlink\" title=\"摩擦运动\"></a>摩擦运动</h3><blockquote>\n<p>逐渐变慢，到停止</p>\n</blockquote>\n<h3 id=\"缓冲运动\"><a href=\"#缓冲运动\" class=\"headerlink\" title=\"缓冲运动\"></a>缓冲运动</h3><blockquote>\n<p>可以精确到某个目的点，距离越远，速度越大<br>速度 = （目标值 - 当前值）/缩放系数<br>bug: 速度取整， 值取整</p>\n</blockquote>\n<p>问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.如果让speed--，但是为负数的时候会跑回来</div><div class=\"line\">2.所以可以让speed/正数，或者speed*（0-1）的数，就可以是减速运动，但是不能准确到达目标点</div></pre></td></tr></table></figure></p>\n<p>解决方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">speed = （500-offsetLeft）*0.8  //按常理来说是无限接近终点</div><div class=\"line\">但是还是不能准确到终点</div><div class=\"line\">为什么会造成这情况呢</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">上面的代码中，我们只加入了一行代码，用于监控Div的当前位置（这是一种常用的调试手段）：</div><div class=\"line\">document.title=oDiv.offsetLeft;</div><div class=\"line\">运行这段代码后，我们看到物体的位置，最终停在293像素的位置，不再向前走了，这是为什么呢？</div><div class=\"line\">实际上，当物体距离目标点非常近的时候，距离可能会小于缩放系数，这时速度会是一个小数。而浏览器能接受的都是整数（像素），给他一个小数，会自动忽略小数部分，物体不会发生实际的移动。</div><div class=\"line\"></div><div class=\"line\">因为offsetWidth是经过js内部运算过后的，是没有单位的，他运算方式是四舍五入运算</div><div class=\"line\"></div><div class=\"line\">当速度小于0.5的时候，会一直处于舍得状态，所以一直到达不了终点，所以需要我们代码解决</div><div class=\"line\">所以对速度进行向上取整Math.ceil(speed)</div><div class=\"line\"></div><div class=\"line\">但是到大于-0.5了如果从远返回的时候，speed为负值</div><div class=\"line\">所以负数要向下取整Math.floor(speed)</div></pre></td></tr></table></figure>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><blockquote>\n<p>让某个元素的属性到目标上去<br>运动的形式和速度无关，和算法有关</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"运动的本质\"><a href=\"#运动的本质\" class=\"headerlink\" title=\"运动的本质\"></a>运动的本质</h2><blockquote>\n<p>让某个元素的某个属性到目标上去中小数精度问题：所以用整数做运算</p>\n</blockquote>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><blockquote>\n<p>第一步清除定时器；<br>第二步开启定时器<br>第三部改变坐标，运动<br>定时器和坐标<br>匀速运动必须保持距离恰好能整除速度<br>点一下开一个定时器，重复点击的bug，所以事先就要清除定时器，每次只能开一个<br>定时器的清除：不同的物体用各自的定时器，防止互相影响</p>\n</blockquote>\n<h2 id=\"运动的形式\"><a href=\"#运动的形式\" class=\"headerlink\" title=\"运动的形式\"></a>运动的形式</h2><h3 id=\"摩擦运动\"><a href=\"#摩擦运动\" class=\"headerlink\" title=\"摩擦运动\"></a>摩擦运动</h3><blockquote>\n<p>逐渐变慢，到停止</p>\n</blockquote>\n<h3 id=\"缓冲运动\"><a href=\"#缓冲运动\" class=\"headerlink\" title=\"缓冲运动\"></a>缓冲运动</h3><blockquote>\n<p>可以精确到某个目的点，距离越远，速度越大<br>速度 = （目标值 - 当前值）/缩放系数<br>bug: 速度取整， 值取整</p>\n</blockquote>\n<p>问题：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.如果让speed--，但是为负数的时候会跑回来</div><div class=\"line\">2.所以可以让speed/正数，或者speed*（0-1）的数，就可以是减速运动，但是不能准确到达目标点</div></pre></td></tr></table></figure></p>\n<p>解决方案：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">speed = （500-offsetLeft）*0.8  //按常理来说是无限接近终点</div><div class=\"line\">但是还是不能准确到终点</div><div class=\"line\">为什么会造成这情况呢</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">上面的代码中，我们只加入了一行代码，用于监控Div的当前位置（这是一种常用的调试手段）：</div><div class=\"line\">document.title=oDiv.offsetLeft;</div><div class=\"line\">运行这段代码后，我们看到物体的位置，最终停在293像素的位置，不再向前走了，这是为什么呢？</div><div class=\"line\">实际上，当物体距离目标点非常近的时候，距离可能会小于缩放系数，这时速度会是一个小数。而浏览器能接受的都是整数（像素），给他一个小数，会自动忽略小数部分，物体不会发生实际的移动。</div><div class=\"line\"></div><div class=\"line\">因为offsetWidth是经过js内部运算过后的，是没有单位的，他运算方式是四舍五入运算</div><div class=\"line\"></div><div class=\"line\">当速度小于0.5的时候，会一直处于舍得状态，所以一直到达不了终点，所以需要我们代码解决</div><div class=\"line\">所以对速度进行向上取整Math.ceil(speed)</div><div class=\"line\"></div><div class=\"line\">但是到大于-0.5了如果从远返回的时候，speed为负值</div><div class=\"line\">所以负数要向下取整Math.floor(speed)</div></pre></td></tr></table></figure>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><blockquote>\n<p>让某个元素的属性到目标上去<br>运动的形式和速度无关，和算法有关</p>\n</blockquote>\n"},{"title":"js与浏览器","type":"categories","_content":"\n## js为什么能在浏览器上跑起来\n\n- 因为浏览器是一个解释器，对这门语言做出解释，执行指令，按照编译原理的步骤，经过词法分析，语法分析等等\n- 但是不同的浏览器可能解析JS的引擎不一样，所以就有不用的解释出现，所以就会在不同的浏览器出现不一样的效果，存在兼容性问题\n- 后来为了统一规范，制定了统一的ECMAScript标准，让各个浏览器都来遵循这个标准\n\n##  JavaScript单线程\n总所周知，JavaScript是以单线程的方式运行的。那为什么js是单线程的呢，这与它的用途有关，js用于互动和操作DOM，如果两个多线程同时控制一个DOM元素，势必会乱掉，但是如果引入锁的概念，会提高复杂性，所以js原来设计的时候就是基于单线程的。因为是单线程，在某一时间只能执行特定的任务，并且会阻塞其他任务的执行，遇到类似I/O耗时的任务就很坑，所以异步回调就出来啦，这些耗时的任务就由回调的方式处理，但是为了避免特别繁重的耗时操作（运算等）HTML5提供了一个web worker，他会基于主线程创造一个新的开辟线程来加载特定的js文件，这两个线程之间不会互相影响，这个worker类提供了与主线程数据交换的接口：postMessage和onMessage事件，但是web worker是不能操作DOM的，任何操作DOM的操作都需要委托给js主线程来处理，但任然改变不了js单线程的本质\n\n## 并发模式与Event Loop\n<img src=\"/images/bf.png\">\n单线程有**并发**注意是并发而不是并行，**所谓“并发”是指两个或两个以上的事件在同一时间间隔中发生**由于计算机系统只有一个CPU，故ABC三个程序从“微观”上是交替使用CPU，但交替时间很短，用户察觉不到，形成了“宏观”意义上的并发操作。\n\n## Runtime 概念\n\n<img src=\"/images/runtime.png\">\n### 栈 stack\n\n这里放着JavaScript正在执行的任务。每个任务被称为帧（stack of frames）\n\n```\nfunction f(b){\n  var a = 12;\n  return a+b+35;\n}\n\nfunction g(x){\n  var m = 4;\n  return f(m*x);\n}\n\ng(21);\n\n```\n上述代码调用 g 时，创建栈的第一帧，该帧包含了 g 的参数和局部变量。当 g 调用 f 时，第二帧就会被创建，并且置于第一帧之上，当然，该帧也包含了 f 的参数和局部变量。当 f 返回时，其对应的帧就会出栈。同理，当 g 返回时，栈就为空了（栈的特定就是后进先出 Last-in first-out (LIFO)）\n\n### Heap（堆）\n\n一个用来表示内存中一大片非结构化区域的名字，对象都被分配在这。\n\n### Queue（队列）\n\n一个 JavaScript runtime 包含了一个任务队列，该队列是由一系列待处理的任务组成。而每个任务都有相对应的函数。当栈为空时，就会从任务队列中取出一个任务，并处理之。该处理会调用与该任务相关联的一系列函数（因此会创建一个初始栈帧）。当该任务处理完毕后，栈就会再次为空。（Queue的特点是先进先出 First-in First-out (FIFO)）。\n\n- Stack栈为主线程\n- Queue队列为任务队列（等待调度到主线程执行）\n\nOK，上述知识点帮助我们理清了一个 JavaScript runtime (JS 引擎）的相关概念，这有助于接下来的分析。\n\n### Event Loop\n\n“任务队列”是一个事件的队列，如果I/O设备完成任务或用户触发事件（该事件指定了回调函数），那么相关事件处理函数就会进入“任务队列”，当主线程空闲时，就会调度“任务队列”里第一个待处理任务，（FIFO）。当然，对于定时器，当到达其指定时间时，才会把相应任务插到“任务队列”尾部。\n\n#### “执行至完成”\n\n每当某个任务执行完后，其它任务才会被执行。也就是说，当一个函数运行时，它不能被取代且会在其它代码运行前先完成。\n当然，这也是Event Loop的一个缺点：当一个任务完成时间过长，那么应用就不能及时处理用户的交互（如点击事件），甚至导致该应用奔溃。一个比较好解决方案是：将任务完成时间缩短，或者尽可能将一个任务分成多个任务执行。\n\n#### 绝不阻塞\nJavaScript与其它语言不同，其Event Loop的一个特性是永不阻塞。I/O操作通常是通过事件和回调函数处理。所以，当应用等待 indexedDB 或 XHR 异步请求返回时，其仍能处理其它操作（如用户输入）\n\n## 深入了解定时器\n\n零延迟 setTimeout(func, 0)\n\n零延迟并不是意味着回调函数立刻执行。它取决于主线程当前是否空闲与“任务队列”里其前面正在等待的任务。\n```\n(function () {\n\n  console.log('this is the start');\n\n  setTimeout(function cb() {\n    console.log('this is a msg from call back');\n  });\n\n  console.log('this is just a message');\n\n  setTimeout(function cb1() {\n    console.log('this is a msg from call back1');\n  }, 0);\n\n  console.log('this is the  end');\n\n})();\n\n// 输出如下：\nthis is the start\nthis is just a message\nthis is the end\nundefined // 立即调用函数的返回值\nthis is a msg from callback\nthis is a msg from a callback1\n```\nsetTimeout(func, 0)的起了改变执行顺序的作用\n\n### 正版与翻版setInterval的区别\n```\n// 利用setTimeout模仿setInterval\nsetTimeout(function(){\n    /* 执行一些操作. */\n    setTimeout(arguments.callee, 1000);\n}, 1000);\n\nsetInterval(function(){\n    /* 执行一些操作 */\n}, 1000);\n\n```\n可能你认为这没什么区别。的确，当回调函数里的操作耗时很短时，并不能看出它们有什么区别。其实：上面案例中的 setTimeout 总是会在其回调函数执行后延迟 1000ms（或者更多，但不可能少）再次执行回调函数，从而实现setInterval的效果，而 setInterval 总是 1000ms 执行一次，而不管它的回调函数执行多久。\n\n所以，如果 setInterval 的回调函数执行时间比你指定的间隔时间相等或者更长，那么其回调函数会连在一起执行。\n\n```\nvar counter = 0;\nvar initTime = new Date().getTime();\nvar timer = setInterval(function(){\n    if(counter===2){\n        clearInterval(timer);\n    }\n    if(counter === 0){\n        for(var i = 0; i < 1990000000; i++){\n            ;\n        }\n    }\n\n    console.log(\"第\"+counter+\"次：\" + (new Date().getTime() - initTime) + \" ms\");\n\n    counter++;\n},1000);\n```\nChrome浏览器的输入如下：\n```\n第0次：2007 ms\n第1次：2013 ms\n第2次：3008 ms\n```\n从上面的执行结果可看出，第一次和第二次执行间隔很短（不足1000ms）。\n\n\n## 浏览器\n\n**浏览器不是单线程的**\n\n上面说了这么多关于 JavaScript 是单线程的，下面说说其宿主环境——浏览器。\n\n浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：\n- JavaScript引擎线程：JavaScript引擎是基于事件驱动单线程执行的，JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理。\n- GUI 渲染线程：GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。但需要注意 GUI 渲染线程与 JavaScript 引擎是互斥的，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。\n- 浏览器事件触发线程：事件触发线程，当一个事件被触发时该线程会把事件添加到“任务队列”的队尾，等待JavaScript引擎的处理。这些事件可来自 JavaScript 引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于 JavaScript 是单线程执行的，所有这些事件都得排队等待 JavaScript 引擎处理。\n\n在 Chrome 浏览器中，为了防止因一个标签页奔溃而影响整个浏览器，其每个标签页都是一个进程（Renderer Process）。当然，对于同一域名下的标签页是能够相互通讯的，具体可看 浏览器跨标签通讯。在 Chrome 设计中存在很多的进程，并利用进程间通讯来完成它们之间的同步，因此这也是 Chrome 快速的法宝之一。对于 Ajax 的请求也需要特殊线程来执行，当需要发送一个 Ajax 请求时，浏览器会开辟一个新的线程来执行HTTP的请求，它并不会阻塞 JavaScript 线程的执行，当 HTTP 请求状态变更时，相应事件会被作为回调放入到“任务队列”中等待被执行。\n\n```\ndocument.onclick = function(){\n    console.log(\"click\")\n}\n\nfor(var i = 0; i< 100000000; i++);\n\n```\n解释一下代码：首先向 document 注册了一个 click 事件，然后就执行了一段耗时的 for 循环，在这段 for 循环结束前，你可以尝试点击页面。当耗时操作结束后，console 控制台就会输出之前点击事件的 \"click\" 语句。这证明了点击事件（也包括其它各种事件）是由额外单独的线程触发的，事件触发后就会将回调函数放进了“任务队列”的末尾，等待着 JavaScript 主线程的执行。\n\n## 总结\n\n- JavaScript是单线程的，同一时刻只能执行特定的任务。而浏览器是多线程的\n- 异步任务（各种浏览器事件、定时器等）都是先添加到“任务队列”（定时器则到达其指定参数时）。当Stack栈（JavaScript 线程）为空时，就会读取 Queue 队列（任务队列）的第一个任务（队首），然后执行。\n\n## 内存泄露\n[参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内存泄露)\n\n\n","source":"_posts/js/foundation/js与浏览器.md","raw":"---\ntitle: js与浏览器\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n## js为什么能在浏览器上跑起来\n\n- 因为浏览器是一个解释器，对这门语言做出解释，执行指令，按照编译原理的步骤，经过词法分析，语法分析等等\n- 但是不同的浏览器可能解析JS的引擎不一样，所以就有不用的解释出现，所以就会在不同的浏览器出现不一样的效果，存在兼容性问题\n- 后来为了统一规范，制定了统一的ECMAScript标准，让各个浏览器都来遵循这个标准\n\n##  JavaScript单线程\n总所周知，JavaScript是以单线程的方式运行的。那为什么js是单线程的呢，这与它的用途有关，js用于互动和操作DOM，如果两个多线程同时控制一个DOM元素，势必会乱掉，但是如果引入锁的概念，会提高复杂性，所以js原来设计的时候就是基于单线程的。因为是单线程，在某一时间只能执行特定的任务，并且会阻塞其他任务的执行，遇到类似I/O耗时的任务就很坑，所以异步回调就出来啦，这些耗时的任务就由回调的方式处理，但是为了避免特别繁重的耗时操作（运算等）HTML5提供了一个web worker，他会基于主线程创造一个新的开辟线程来加载特定的js文件，这两个线程之间不会互相影响，这个worker类提供了与主线程数据交换的接口：postMessage和onMessage事件，但是web worker是不能操作DOM的，任何操作DOM的操作都需要委托给js主线程来处理，但任然改变不了js单线程的本质\n\n## 并发模式与Event Loop\n<img src=\"/images/bf.png\">\n单线程有**并发**注意是并发而不是并行，**所谓“并发”是指两个或两个以上的事件在同一时间间隔中发生**由于计算机系统只有一个CPU，故ABC三个程序从“微观”上是交替使用CPU，但交替时间很短，用户察觉不到，形成了“宏观”意义上的并发操作。\n\n## Runtime 概念\n\n<img src=\"/images/runtime.png\">\n### 栈 stack\n\n这里放着JavaScript正在执行的任务。每个任务被称为帧（stack of frames）\n\n```\nfunction f(b){\n  var a = 12;\n  return a+b+35;\n}\n\nfunction g(x){\n  var m = 4;\n  return f(m*x);\n}\n\ng(21);\n\n```\n上述代码调用 g 时，创建栈的第一帧，该帧包含了 g 的参数和局部变量。当 g 调用 f 时，第二帧就会被创建，并且置于第一帧之上，当然，该帧也包含了 f 的参数和局部变量。当 f 返回时，其对应的帧就会出栈。同理，当 g 返回时，栈就为空了（栈的特定就是后进先出 Last-in first-out (LIFO)）\n\n### Heap（堆）\n\n一个用来表示内存中一大片非结构化区域的名字，对象都被分配在这。\n\n### Queue（队列）\n\n一个 JavaScript runtime 包含了一个任务队列，该队列是由一系列待处理的任务组成。而每个任务都有相对应的函数。当栈为空时，就会从任务队列中取出一个任务，并处理之。该处理会调用与该任务相关联的一系列函数（因此会创建一个初始栈帧）。当该任务处理完毕后，栈就会再次为空。（Queue的特点是先进先出 First-in First-out (FIFO)）。\n\n- Stack栈为主线程\n- Queue队列为任务队列（等待调度到主线程执行）\n\nOK，上述知识点帮助我们理清了一个 JavaScript runtime (JS 引擎）的相关概念，这有助于接下来的分析。\n\n### Event Loop\n\n“任务队列”是一个事件的队列，如果I/O设备完成任务或用户触发事件（该事件指定了回调函数），那么相关事件处理函数就会进入“任务队列”，当主线程空闲时，就会调度“任务队列”里第一个待处理任务，（FIFO）。当然，对于定时器，当到达其指定时间时，才会把相应任务插到“任务队列”尾部。\n\n#### “执行至完成”\n\n每当某个任务执行完后，其它任务才会被执行。也就是说，当一个函数运行时，它不能被取代且会在其它代码运行前先完成。\n当然，这也是Event Loop的一个缺点：当一个任务完成时间过长，那么应用就不能及时处理用户的交互（如点击事件），甚至导致该应用奔溃。一个比较好解决方案是：将任务完成时间缩短，或者尽可能将一个任务分成多个任务执行。\n\n#### 绝不阻塞\nJavaScript与其它语言不同，其Event Loop的一个特性是永不阻塞。I/O操作通常是通过事件和回调函数处理。所以，当应用等待 indexedDB 或 XHR 异步请求返回时，其仍能处理其它操作（如用户输入）\n\n## 深入了解定时器\n\n零延迟 setTimeout(func, 0)\n\n零延迟并不是意味着回调函数立刻执行。它取决于主线程当前是否空闲与“任务队列”里其前面正在等待的任务。\n```\n(function () {\n\n  console.log('this is the start');\n\n  setTimeout(function cb() {\n    console.log('this is a msg from call back');\n  });\n\n  console.log('this is just a message');\n\n  setTimeout(function cb1() {\n    console.log('this is a msg from call back1');\n  }, 0);\n\n  console.log('this is the  end');\n\n})();\n\n// 输出如下：\nthis is the start\nthis is just a message\nthis is the end\nundefined // 立即调用函数的返回值\nthis is a msg from callback\nthis is a msg from a callback1\n```\nsetTimeout(func, 0)的起了改变执行顺序的作用\n\n### 正版与翻版setInterval的区别\n```\n// 利用setTimeout模仿setInterval\nsetTimeout(function(){\n    /* 执行一些操作. */\n    setTimeout(arguments.callee, 1000);\n}, 1000);\n\nsetInterval(function(){\n    /* 执行一些操作 */\n}, 1000);\n\n```\n可能你认为这没什么区别。的确，当回调函数里的操作耗时很短时，并不能看出它们有什么区别。其实：上面案例中的 setTimeout 总是会在其回调函数执行后延迟 1000ms（或者更多，但不可能少）再次执行回调函数，从而实现setInterval的效果，而 setInterval 总是 1000ms 执行一次，而不管它的回调函数执行多久。\n\n所以，如果 setInterval 的回调函数执行时间比你指定的间隔时间相等或者更长，那么其回调函数会连在一起执行。\n\n```\nvar counter = 0;\nvar initTime = new Date().getTime();\nvar timer = setInterval(function(){\n    if(counter===2){\n        clearInterval(timer);\n    }\n    if(counter === 0){\n        for(var i = 0; i < 1990000000; i++){\n            ;\n        }\n    }\n\n    console.log(\"第\"+counter+\"次：\" + (new Date().getTime() - initTime) + \" ms\");\n\n    counter++;\n},1000);\n```\nChrome浏览器的输入如下：\n```\n第0次：2007 ms\n第1次：2013 ms\n第2次：3008 ms\n```\n从上面的执行结果可看出，第一次和第二次执行间隔很短（不足1000ms）。\n\n\n## 浏览器\n\n**浏览器不是单线程的**\n\n上面说了这么多关于 JavaScript 是单线程的，下面说说其宿主环境——浏览器。\n\n浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：\n- JavaScript引擎线程：JavaScript引擎是基于事件驱动单线程执行的，JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理。\n- GUI 渲染线程：GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。但需要注意 GUI 渲染线程与 JavaScript 引擎是互斥的，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。\n- 浏览器事件触发线程：事件触发线程，当一个事件被触发时该线程会把事件添加到“任务队列”的队尾，等待JavaScript引擎的处理。这些事件可来自 JavaScript 引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于 JavaScript 是单线程执行的，所有这些事件都得排队等待 JavaScript 引擎处理。\n\n在 Chrome 浏览器中，为了防止因一个标签页奔溃而影响整个浏览器，其每个标签页都是一个进程（Renderer Process）。当然，对于同一域名下的标签页是能够相互通讯的，具体可看 浏览器跨标签通讯。在 Chrome 设计中存在很多的进程，并利用进程间通讯来完成它们之间的同步，因此这也是 Chrome 快速的法宝之一。对于 Ajax 的请求也需要特殊线程来执行，当需要发送一个 Ajax 请求时，浏览器会开辟一个新的线程来执行HTTP的请求，它并不会阻塞 JavaScript 线程的执行，当 HTTP 请求状态变更时，相应事件会被作为回调放入到“任务队列”中等待被执行。\n\n```\ndocument.onclick = function(){\n    console.log(\"click\")\n}\n\nfor(var i = 0; i< 100000000; i++);\n\n```\n解释一下代码：首先向 document 注册了一个 click 事件，然后就执行了一段耗时的 for 循环，在这段 for 循环结束前，你可以尝试点击页面。当耗时操作结束后，console 控制台就会输出之前点击事件的 \"click\" 语句。这证明了点击事件（也包括其它各种事件）是由额外单独的线程触发的，事件触发后就会将回调函数放进了“任务队列”的末尾，等待着 JavaScript 主线程的执行。\n\n## 总结\n\n- JavaScript是单线程的，同一时刻只能执行特定的任务。而浏览器是多线程的\n- 异步任务（各种浏览器事件、定时器等）都是先添加到“任务队列”（定时器则到达其指定参数时）。当Stack栈（JavaScript 线程）为空时，就会读取 Queue 队列（任务队列）的第一个任务（队首），然后执行。\n\n## 内存泄露\n[参考](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内存泄露)\n\n\n","slug":"js-foundation-js与浏览器","published":1,"date":"2017-04-23T11:10:23.000Z","updated":"2017-04-23T11:10:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ch9003lkzy6uukrytat","content":"<h2 id=\"js为什么能在浏览器上跑起来\"><a href=\"#js为什么能在浏览器上跑起来\" class=\"headerlink\" title=\"js为什么能在浏览器上跑起来\"></a>js为什么能在浏览器上跑起来</h2><ul>\n<li>因为浏览器是一个解释器，对这门语言做出解释，执行指令，按照编译原理的步骤，经过词法分析，语法分析等等</li>\n<li>但是不同的浏览器可能解析JS的引擎不一样，所以就有不用的解释出现，所以就会在不同的浏览器出现不一样的效果，存在兼容性问题</li>\n<li>后来为了统一规范，制定了统一的ECMAScript标准，让各个浏览器都来遵循这个标准</li>\n</ul>\n<h2 id=\"JavaScript单线程\"><a href=\"#JavaScript单线程\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>总所周知，JavaScript是以单线程的方式运行的。那为什么js是单线程的呢，这与它的用途有关，js用于互动和操作DOM，如果两个多线程同时控制一个DOM元素，势必会乱掉，但是如果引入锁的概念，会提高复杂性，所以js原来设计的时候就是基于单线程的。因为是单线程，在某一时间只能执行特定的任务，并且会阻塞其他任务的执行，遇到类似I/O耗时的任务就很坑，所以异步回调就出来啦，这些耗时的任务就由回调的方式处理，但是为了避免特别繁重的耗时操作（运算等）HTML5提供了一个web worker，他会基于主线程创造一个新的开辟线程来加载特定的js文件，这两个线程之间不会互相影响，这个worker类提供了与主线程数据交换的接口：postMessage和onMessage事件，但是web worker是不能操作DOM的，任何操作DOM的操作都需要委托给js主线程来处理，但任然改变不了js单线程的本质</p>\n<h2 id=\"并发模式与Event-Loop\"><a href=\"#并发模式与Event-Loop\" class=\"headerlink\" title=\"并发模式与Event Loop\"></a>并发模式与Event Loop</h2><p><img src=\"/images/bf.png\"><br>单线程有<strong>并发</strong>注意是并发而不是并行，<strong>所谓“并发”是指两个或两个以上的事件在同一时间间隔中发生</strong>由于计算机系统只有一个CPU，故ABC三个程序从“微观”上是交替使用CPU，但交替时间很短，用户察觉不到，形成了“宏观”意义上的并发操作。</p>\n<h2 id=\"Runtime-概念\"><a href=\"#Runtime-概念\" class=\"headerlink\" title=\"Runtime 概念\"></a>Runtime 概念</h2><p><img src=\"/images/runtime.png\"></p>\n<h3 id=\"栈-stack\"><a href=\"#栈-stack\" class=\"headerlink\" title=\"栈 stack\"></a>栈 stack</h3><p>这里放着JavaScript正在执行的任务。每个任务被称为帧（stack of frames）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f(b)&#123;</div><div class=\"line\">  var a = 12;</div><div class=\"line\">  return a+b+35;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function g(x)&#123;</div><div class=\"line\">  var m = 4;</div><div class=\"line\">  return f(m*x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">g(21);</div></pre></td></tr></table></figure>\n<p>上述代码调用 g 时，创建栈的第一帧，该帧包含了 g 的参数和局部变量。当 g 调用 f 时，第二帧就会被创建，并且置于第一帧之上，当然，该帧也包含了 f 的参数和局部变量。当 f 返回时，其对应的帧就会出栈。同理，当 g 返回时，栈就为空了（栈的特定就是后进先出 Last-in first-out (LIFO)）</p>\n<h3 id=\"Heap（堆）\"><a href=\"#Heap（堆）\" class=\"headerlink\" title=\"Heap（堆）\"></a>Heap（堆）</h3><p>一个用来表示内存中一大片非结构化区域的名字，对象都被分配在这。</p>\n<h3 id=\"Queue（队列）\"><a href=\"#Queue（队列）\" class=\"headerlink\" title=\"Queue（队列）\"></a>Queue（队列）</h3><p>一个 JavaScript runtime 包含了一个任务队列，该队列是由一系列待处理的任务组成。而每个任务都有相对应的函数。当栈为空时，就会从任务队列中取出一个任务，并处理之。该处理会调用与该任务相关联的一系列函数（因此会创建一个初始栈帧）。当该任务处理完毕后，栈就会再次为空。（Queue的特点是先进先出 First-in First-out (FIFO)）。</p>\n<ul>\n<li>Stack栈为主线程</li>\n<li>Queue队列为任务队列（等待调度到主线程执行）</li>\n</ul>\n<p>OK，上述知识点帮助我们理清了一个 JavaScript runtime (JS 引擎）的相关概念，这有助于接下来的分析。</p>\n<h3 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h3><p>“任务队列”是一个事件的队列，如果I/O设备完成任务或用户触发事件（该事件指定了回调函数），那么相关事件处理函数就会进入“任务队列”，当主线程空闲时，就会调度“任务队列”里第一个待处理任务，（FIFO）。当然，对于定时器，当到达其指定时间时，才会把相应任务插到“任务队列”尾部。</p>\n<h4 id=\"“执行至完成”\"><a href=\"#“执行至完成”\" class=\"headerlink\" title=\"“执行至完成”\"></a>“执行至完成”</h4><p>每当某个任务执行完后，其它任务才会被执行。也就是说，当一个函数运行时，它不能被取代且会在其它代码运行前先完成。<br>当然，这也是Event Loop的一个缺点：当一个任务完成时间过长，那么应用就不能及时处理用户的交互（如点击事件），甚至导致该应用奔溃。一个比较好解决方案是：将任务完成时间缩短，或者尽可能将一个任务分成多个任务执行。</p>\n<h4 id=\"绝不阻塞\"><a href=\"#绝不阻塞\" class=\"headerlink\" title=\"绝不阻塞\"></a>绝不阻塞</h4><p>JavaScript与其它语言不同，其Event Loop的一个特性是永不阻塞。I/O操作通常是通过事件和回调函数处理。所以，当应用等待 indexedDB 或 XHR 异步请求返回时，其仍能处理其它操作（如用户输入）</p>\n<h2 id=\"深入了解定时器\"><a href=\"#深入了解定时器\" class=\"headerlink\" title=\"深入了解定时器\"></a>深入了解定时器</h2><p>零延迟 setTimeout(func, 0)</p>\n<p>零延迟并不是意味着回调函数立刻执行。它取决于主线程当前是否空闲与“任务队列”里其前面正在等待的任务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function () &#123;</div><div class=\"line\"></div><div class=\"line\">  console.log(&apos;this is the start&apos;);</div><div class=\"line\"></div><div class=\"line\">  setTimeout(function cb() &#123;</div><div class=\"line\">    console.log(&apos;this is a msg from call back&apos;);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  console.log(&apos;this is just a message&apos;);</div><div class=\"line\"></div><div class=\"line\">  setTimeout(function cb1() &#123;</div><div class=\"line\">    console.log(&apos;this is a msg from call back1&apos;);</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\"></div><div class=\"line\">  console.log(&apos;this is the  end&apos;);</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">// 输出如下：</div><div class=\"line\">this is the start</div><div class=\"line\">this is just a message</div><div class=\"line\">this is the end</div><div class=\"line\">undefined // 立即调用函数的返回值</div><div class=\"line\">this is a msg from callback</div><div class=\"line\">this is a msg from a callback1</div></pre></td></tr></table></figure></p>\n<p>setTimeout(func, 0)的起了改变执行顺序的作用</p>\n<h3 id=\"正版与翻版setInterval的区别\"><a href=\"#正版与翻版setInterval的区别\" class=\"headerlink\" title=\"正版与翻版setInterval的区别\"></a>正版与翻版setInterval的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 利用setTimeout模仿setInterval</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">    /* 执行一些操作. */</div><div class=\"line\">    setTimeout(arguments.callee, 1000);</div><div class=\"line\">&#125;, 1000);</div><div class=\"line\"></div><div class=\"line\">setInterval(function()&#123;</div><div class=\"line\">    /* 执行一些操作 */</div><div class=\"line\">&#125;, 1000);</div></pre></td></tr></table></figure>\n<p>可能你认为这没什么区别。的确，当回调函数里的操作耗时很短时，并不能看出它们有什么区别。其实：上面案例中的 setTimeout 总是会在其回调函数执行后延迟 1000ms（或者更多，但不可能少）再次执行回调函数，从而实现setInterval的效果，而 setInterval 总是 1000ms 执行一次，而不管它的回调函数执行多久。</p>\n<p>所以，如果 setInterval 的回调函数执行时间比你指定的间隔时间相等或者更长，那么其回调函数会连在一起执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">var counter = 0;</div><div class=\"line\">var initTime = new Date().getTime();</div><div class=\"line\">var timer = setInterval(function()&#123;</div><div class=\"line\">    if(counter===2)&#123;</div><div class=\"line\">        clearInterval(timer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if(counter === 0)&#123;</div><div class=\"line\">        for(var i = 0; i &lt; 1990000000; i++)&#123;</div><div class=\"line\">            ;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    console.log(&quot;第&quot;+counter+&quot;次：&quot; + (new Date().getTime() - initTime) + &quot; ms&quot;);</div><div class=\"line\"></div><div class=\"line\">    counter++;</div><div class=\"line\">&#125;,1000);</div></pre></td></tr></table></figure>\n<p>Chrome浏览器的输入如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">第0次：2007 ms</div><div class=\"line\">第1次：2013 ms</div><div class=\"line\">第2次：3008 ms</div></pre></td></tr></table></figure></p>\n<p>从上面的执行结果可看出，第一次和第二次执行间隔很短（不足1000ms）。</p>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p><strong>浏览器不是单线程的</strong></p>\n<p>上面说了这么多关于 JavaScript 是单线程的，下面说说其宿主环境——浏览器。</p>\n<p>浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：</p>\n<ul>\n<li>JavaScript引擎线程：JavaScript引擎是基于事件驱动单线程执行的，JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理。</li>\n<li>GUI 渲染线程：GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。但需要注意 GUI 渲染线程与 JavaScript 引擎是互斥的，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。</li>\n<li>浏览器事件触发线程：事件触发线程，当一个事件被触发时该线程会把事件添加到“任务队列”的队尾，等待JavaScript引擎的处理。这些事件可来自 JavaScript 引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于 JavaScript 是单线程执行的，所有这些事件都得排队等待 JavaScript 引擎处理。</li>\n</ul>\n<p>在 Chrome 浏览器中，为了防止因一个标签页奔溃而影响整个浏览器，其每个标签页都是一个进程（Renderer Process）。当然，对于同一域名下的标签页是能够相互通讯的，具体可看 浏览器跨标签通讯。在 Chrome 设计中存在很多的进程，并利用进程间通讯来完成它们之间的同步，因此这也是 Chrome 快速的法宝之一。对于 Ajax 的请求也需要特殊线程来执行，当需要发送一个 Ajax 请求时，浏览器会开辟一个新的线程来执行HTTP的请求，它并不会阻塞 JavaScript 线程的执行，当 HTTP 请求状态变更时，相应事件会被作为回调放入到“任务队列”中等待被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.onclick = function()&#123;</div><div class=\"line\">    console.log(&quot;click&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for(var i = 0; i&lt; 100000000; i++);</div></pre></td></tr></table></figure>\n<p>解释一下代码：首先向 document 注册了一个 click 事件，然后就执行了一段耗时的 for 循环，在这段 for 循环结束前，你可以尝试点击页面。当耗时操作结束后，console 控制台就会输出之前点击事件的 “click” 语句。这证明了点击事件（也包括其它各种事件）是由额外单独的线程触发的，事件触发后就会将回调函数放进了“任务队列”的末尾，等待着 JavaScript 主线程的执行。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>JavaScript是单线程的，同一时刻只能执行特定的任务。而浏览器是多线程的</li>\n<li>异步任务（各种浏览器事件、定时器等）都是先添加到“任务队列”（定时器则到达其指定参数时）。当Stack栈（JavaScript 线程）为空时，就会读取 Queue 队列（任务队列）的第一个任务（队首），然后执行。</li>\n</ul>\n<h2 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内存泄露\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"js为什么能在浏览器上跑起来\"><a href=\"#js为什么能在浏览器上跑起来\" class=\"headerlink\" title=\"js为什么能在浏览器上跑起来\"></a>js为什么能在浏览器上跑起来</h2><ul>\n<li>因为浏览器是一个解释器，对这门语言做出解释，执行指令，按照编译原理的步骤，经过词法分析，语法分析等等</li>\n<li>但是不同的浏览器可能解析JS的引擎不一样，所以就有不用的解释出现，所以就会在不同的浏览器出现不一样的效果，存在兼容性问题</li>\n<li>后来为了统一规范，制定了统一的ECMAScript标准，让各个浏览器都来遵循这个标准</li>\n</ul>\n<h2 id=\"JavaScript单线程\"><a href=\"#JavaScript单线程\" class=\"headerlink\" title=\"JavaScript单线程\"></a>JavaScript单线程</h2><p>总所周知，JavaScript是以单线程的方式运行的。那为什么js是单线程的呢，这与它的用途有关，js用于互动和操作DOM，如果两个多线程同时控制一个DOM元素，势必会乱掉，但是如果引入锁的概念，会提高复杂性，所以js原来设计的时候就是基于单线程的。因为是单线程，在某一时间只能执行特定的任务，并且会阻塞其他任务的执行，遇到类似I/O耗时的任务就很坑，所以异步回调就出来啦，这些耗时的任务就由回调的方式处理，但是为了避免特别繁重的耗时操作（运算等）HTML5提供了一个web worker，他会基于主线程创造一个新的开辟线程来加载特定的js文件，这两个线程之间不会互相影响，这个worker类提供了与主线程数据交换的接口：postMessage和onMessage事件，但是web worker是不能操作DOM的，任何操作DOM的操作都需要委托给js主线程来处理，但任然改变不了js单线程的本质</p>\n<h2 id=\"并发模式与Event-Loop\"><a href=\"#并发模式与Event-Loop\" class=\"headerlink\" title=\"并发模式与Event Loop\"></a>并发模式与Event Loop</h2><p><img src=\"/images/bf.png\"><br>单线程有<strong>并发</strong>注意是并发而不是并行，<strong>所谓“并发”是指两个或两个以上的事件在同一时间间隔中发生</strong>由于计算机系统只有一个CPU，故ABC三个程序从“微观”上是交替使用CPU，但交替时间很短，用户察觉不到，形成了“宏观”意义上的并发操作。</p>\n<h2 id=\"Runtime-概念\"><a href=\"#Runtime-概念\" class=\"headerlink\" title=\"Runtime 概念\"></a>Runtime 概念</h2><p><img src=\"/images/runtime.png\"></p>\n<h3 id=\"栈-stack\"><a href=\"#栈-stack\" class=\"headerlink\" title=\"栈 stack\"></a>栈 stack</h3><p>这里放着JavaScript正在执行的任务。每个任务被称为帧（stack of frames）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">function f(b)&#123;</div><div class=\"line\">  var a = 12;</div><div class=\"line\">  return a+b+35;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">function g(x)&#123;</div><div class=\"line\">  var m = 4;</div><div class=\"line\">  return f(m*x);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">g(21);</div></pre></td></tr></table></figure>\n<p>上述代码调用 g 时，创建栈的第一帧，该帧包含了 g 的参数和局部变量。当 g 调用 f 时，第二帧就会被创建，并且置于第一帧之上，当然，该帧也包含了 f 的参数和局部变量。当 f 返回时，其对应的帧就会出栈。同理，当 g 返回时，栈就为空了（栈的特定就是后进先出 Last-in first-out (LIFO)）</p>\n<h3 id=\"Heap（堆）\"><a href=\"#Heap（堆）\" class=\"headerlink\" title=\"Heap（堆）\"></a>Heap（堆）</h3><p>一个用来表示内存中一大片非结构化区域的名字，对象都被分配在这。</p>\n<h3 id=\"Queue（队列）\"><a href=\"#Queue（队列）\" class=\"headerlink\" title=\"Queue（队列）\"></a>Queue（队列）</h3><p>一个 JavaScript runtime 包含了一个任务队列，该队列是由一系列待处理的任务组成。而每个任务都有相对应的函数。当栈为空时，就会从任务队列中取出一个任务，并处理之。该处理会调用与该任务相关联的一系列函数（因此会创建一个初始栈帧）。当该任务处理完毕后，栈就会再次为空。（Queue的特点是先进先出 First-in First-out (FIFO)）。</p>\n<ul>\n<li>Stack栈为主线程</li>\n<li>Queue队列为任务队列（等待调度到主线程执行）</li>\n</ul>\n<p>OK，上述知识点帮助我们理清了一个 JavaScript runtime (JS 引擎）的相关概念，这有助于接下来的分析。</p>\n<h3 id=\"Event-Loop\"><a href=\"#Event-Loop\" class=\"headerlink\" title=\"Event Loop\"></a>Event Loop</h3><p>“任务队列”是一个事件的队列，如果I/O设备完成任务或用户触发事件（该事件指定了回调函数），那么相关事件处理函数就会进入“任务队列”，当主线程空闲时，就会调度“任务队列”里第一个待处理任务，（FIFO）。当然，对于定时器，当到达其指定时间时，才会把相应任务插到“任务队列”尾部。</p>\n<h4 id=\"“执行至完成”\"><a href=\"#“执行至完成”\" class=\"headerlink\" title=\"“执行至完成”\"></a>“执行至完成”</h4><p>每当某个任务执行完后，其它任务才会被执行。也就是说，当一个函数运行时，它不能被取代且会在其它代码运行前先完成。<br>当然，这也是Event Loop的一个缺点：当一个任务完成时间过长，那么应用就不能及时处理用户的交互（如点击事件），甚至导致该应用奔溃。一个比较好解决方案是：将任务完成时间缩短，或者尽可能将一个任务分成多个任务执行。</p>\n<h4 id=\"绝不阻塞\"><a href=\"#绝不阻塞\" class=\"headerlink\" title=\"绝不阻塞\"></a>绝不阻塞</h4><p>JavaScript与其它语言不同，其Event Loop的一个特性是永不阻塞。I/O操作通常是通过事件和回调函数处理。所以，当应用等待 indexedDB 或 XHR 异步请求返回时，其仍能处理其它操作（如用户输入）</p>\n<h2 id=\"深入了解定时器\"><a href=\"#深入了解定时器\" class=\"headerlink\" title=\"深入了解定时器\"></a>深入了解定时器</h2><p>零延迟 setTimeout(func, 0)</p>\n<p>零延迟并不是意味着回调函数立刻执行。它取决于主线程当前是否空闲与“任务队列”里其前面正在等待的任务。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function () &#123;</div><div class=\"line\"></div><div class=\"line\">  console.log(&apos;this is the start&apos;);</div><div class=\"line\"></div><div class=\"line\">  setTimeout(function cb() &#123;</div><div class=\"line\">    console.log(&apos;this is a msg from call back&apos;);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  console.log(&apos;this is just a message&apos;);</div><div class=\"line\"></div><div class=\"line\">  setTimeout(function cb1() &#123;</div><div class=\"line\">    console.log(&apos;this is a msg from call back1&apos;);</div><div class=\"line\">  &#125;, 0);</div><div class=\"line\"></div><div class=\"line\">  console.log(&apos;this is the  end&apos;);</div><div class=\"line\"></div><div class=\"line\">&#125;)();</div><div class=\"line\"></div><div class=\"line\">// 输出如下：</div><div class=\"line\">this is the start</div><div class=\"line\">this is just a message</div><div class=\"line\">this is the end</div><div class=\"line\">undefined // 立即调用函数的返回值</div><div class=\"line\">this is a msg from callback</div><div class=\"line\">this is a msg from a callback1</div></pre></td></tr></table></figure></p>\n<p>setTimeout(func, 0)的起了改变执行顺序的作用</p>\n<h3 id=\"正版与翻版setInterval的区别\"><a href=\"#正版与翻版setInterval的区别\" class=\"headerlink\" title=\"正版与翻版setInterval的区别\"></a>正版与翻版setInterval的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 利用setTimeout模仿setInterval</div><div class=\"line\">setTimeout(function()&#123;</div><div class=\"line\">    /* 执行一些操作. */</div><div class=\"line\">    setTimeout(arguments.callee, 1000);</div><div class=\"line\">&#125;, 1000);</div><div class=\"line\"></div><div class=\"line\">setInterval(function()&#123;</div><div class=\"line\">    /* 执行一些操作 */</div><div class=\"line\">&#125;, 1000);</div></pre></td></tr></table></figure>\n<p>可能你认为这没什么区别。的确，当回调函数里的操作耗时很短时，并不能看出它们有什么区别。其实：上面案例中的 setTimeout 总是会在其回调函数执行后延迟 1000ms（或者更多，但不可能少）再次执行回调函数，从而实现setInterval的效果，而 setInterval 总是 1000ms 执行一次，而不管它的回调函数执行多久。</p>\n<p>所以，如果 setInterval 的回调函数执行时间比你指定的间隔时间相等或者更长，那么其回调函数会连在一起执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">var counter = 0;</div><div class=\"line\">var initTime = new Date().getTime();</div><div class=\"line\">var timer = setInterval(function()&#123;</div><div class=\"line\">    if(counter===2)&#123;</div><div class=\"line\">        clearInterval(timer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if(counter === 0)&#123;</div><div class=\"line\">        for(var i = 0; i &lt; 1990000000; i++)&#123;</div><div class=\"line\">            ;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    console.log(&quot;第&quot;+counter+&quot;次：&quot; + (new Date().getTime() - initTime) + &quot; ms&quot;);</div><div class=\"line\"></div><div class=\"line\">    counter++;</div><div class=\"line\">&#125;,1000);</div></pre></td></tr></table></figure>\n<p>Chrome浏览器的输入如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">第0次：2007 ms</div><div class=\"line\">第1次：2013 ms</div><div class=\"line\">第2次：3008 ms</div></pre></td></tr></table></figure></p>\n<p>从上面的执行结果可看出，第一次和第二次执行间隔很短（不足1000ms）。</p>\n<h2 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h2><p><strong>浏览器不是单线程的</strong></p>\n<p>上面说了这么多关于 JavaScript 是单线程的，下面说说其宿主环境——浏览器。</p>\n<p>浏览器的内核是多线程的，它们在内核制控下相互配合以保持同步，一个浏览器至少实现三个常驻线程：</p>\n<ul>\n<li>JavaScript引擎线程：JavaScript引擎是基于事件驱动单线程执行的，JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理。</li>\n<li>GUI 渲染线程：GUI渲染线程负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。但需要注意 GUI 渲染线程与 JavaScript 引擎是互斥的，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行。</li>\n<li>浏览器事件触发线程：事件触发线程，当一个事件被触发时该线程会把事件添加到“任务队列”的队尾，等待JavaScript引擎的处理。这些事件可来自 JavaScript 引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于 JavaScript 是单线程执行的，所有这些事件都得排队等待 JavaScript 引擎处理。</li>\n</ul>\n<p>在 Chrome 浏览器中，为了防止因一个标签页奔溃而影响整个浏览器，其每个标签页都是一个进程（Renderer Process）。当然，对于同一域名下的标签页是能够相互通讯的，具体可看 浏览器跨标签通讯。在 Chrome 设计中存在很多的进程，并利用进程间通讯来完成它们之间的同步，因此这也是 Chrome 快速的法宝之一。对于 Ajax 的请求也需要特殊线程来执行，当需要发送一个 Ajax 请求时，浏览器会开辟一个新的线程来执行HTTP的请求，它并不会阻塞 JavaScript 线程的执行，当 HTTP 请求状态变更时，相应事件会被作为回调放入到“任务队列”中等待被执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">document.onclick = function()&#123;</div><div class=\"line\">    console.log(&quot;click&quot;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">for(var i = 0; i&lt; 100000000; i++);</div></pre></td></tr></table></figure>\n<p>解释一下代码：首先向 document 注册了一个 click 事件，然后就执行了一段耗时的 for 循环，在这段 for 循环结束前，你可以尝试点击页面。当耗时操作结束后，console 控制台就会输出之前点击事件的 “click” 语句。这证明了点击事件（也包括其它各种事件）是由额外单独的线程触发的，事件触发后就会将回调函数放进了“任务队列”的末尾，等待着 JavaScript 主线程的执行。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>JavaScript是单线程的，同一时刻只能执行特定的任务。而浏览器是多线程的</li>\n<li>异步任务（各种浏览器事件、定时器等）都是先添加到“任务队列”（定时器则到达其指定参数时）。当Stack栈（JavaScript 线程）为空时，就会读取 Queue 队列（任务队列）的第一个任务（队首），然后执行。</li>\n</ul>\n<h2 id=\"内存泄露\"><a href=\"#内存泄露\" class=\"headerlink\" title=\"内存泄露\"></a>内存泄露</h2><p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#内存泄露\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"js浮点数问题","type":"categories","_content":"\n```\n### 对精度要求不高可用toFixed(),toPrecision()，\n### 或者转换成整数\n### 或者移步math.js\n\n```\n```\n(function() {\n\tconsole.log(0.1 + 0.2 === 0.3)  //false\n}())\n\nNumber.prototype.floatCalculate = Number.prototype.floatCalculate || function(number=10) {\n\t//number should <= 16\n\treturn this.toFixed(number)\n};\n```","source":"_posts/js/foundation/js浮点数问题.md","raw":"---\ntitle: js浮点数问题\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n```\n### 对精度要求不高可用toFixed(),toPrecision()，\n### 或者转换成整数\n### 或者移步math.js\n\n```\n```\n(function() {\n\tconsole.log(0.1 + 0.2 === 0.3)  //false\n}())\n\nNumber.prototype.floatCalculate = Number.prototype.floatCalculate || function(number=10) {\n\t//number should <= 16\n\treturn this.toFixed(number)\n};\n```","slug":"js-foundation-js浮点数问题","published":1,"date":"2017-04-23T11:10:26.000Z","updated":"2017-04-23T11:10:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cha003okzy6s3191tfq","content":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">### 对精度要求不高可用toFixed(),toPrecision()，</div><div class=\"line\">### 或者转换成整数</div><div class=\"line\">### 或者移步math.js</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function() &#123;</div><div class=\"line\">\tconsole.log(0.1 + 0.2 === 0.3)  //false</div><div class=\"line\">&#125;())</div><div class=\"line\"></div><div class=\"line\">Number.prototype.floatCalculate = Number.prototype.floatCalculate || function(number=10) &#123;</div><div class=\"line\">\t//number should &lt;= 16</div><div class=\"line\">\treturn this.toFixed(number)</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">### 对精度要求不高可用toFixed(),toPrecision()，</div><div class=\"line\">### 或者转换成整数</div><div class=\"line\">### 或者移步math.js</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function() &#123;</div><div class=\"line\">\tconsole.log(0.1 + 0.2 === 0.3)  //false</div><div class=\"line\">&#125;())</div><div class=\"line\"></div><div class=\"line\">Number.prototype.floatCalculate = Number.prototype.floatCalculate || function(number=10) &#123;</div><div class=\"line\">\t//number should &lt;= 16</div><div class=\"line\">\treturn this.toFixed(number)</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>"},{"title":"object变成类数组对象","type":"categories","_content":"\n先看JQ如何做的\n```\njQuery.fn = jQuery.prototype = {\n    // The default length of a jQuery object is 0\n    length: 0,\n    splice: arr.splice\n};\n\n\n```\n为什么会jquery返回的是一个数组，看代码你就明白了\n```\n var a = {\n    id: 1,\n    name: \"wbcz\"\n  };\n  for (var i = 0; i < a.length; i++) {\n    console.log(a[i]) \n  }\n  //没有打印，因为a.length为undefined\n```\n再次该进一下呢\n```\n var a = {\n    id: 1,\n    name: \"wbcz\"\n  };\n  for (var i = 0; i < a.length; i++) {\n    console.log(a[i]) \n  }\n  //1\n  //wbcz\n  //对象获取属性的值本来就可以通过[]来获取。\n```\n\n再改进一下\n```\nvar a = {\n    0: 1,\n    1: \"wbcz\",\n    length: 2,\n    splice: [].splice\n};\nfor (var i = 0; i < a.length; i++) {\n\tconsole.log(a[i])\n}\n//1\n//wbcz\n```\n","source":"_posts/js/foundation/object变成类数组对象.md","raw":"---\ntitle: object变成类数组对象\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n先看JQ如何做的\n```\njQuery.fn = jQuery.prototype = {\n    // The default length of a jQuery object is 0\n    length: 0,\n    splice: arr.splice\n};\n\n\n```\n为什么会jquery返回的是一个数组，看代码你就明白了\n```\n var a = {\n    id: 1,\n    name: \"wbcz\"\n  };\n  for (var i = 0; i < a.length; i++) {\n    console.log(a[i]) \n  }\n  //没有打印，因为a.length为undefined\n```\n再次该进一下呢\n```\n var a = {\n    id: 1,\n    name: \"wbcz\"\n  };\n  for (var i = 0; i < a.length; i++) {\n    console.log(a[i]) \n  }\n  //1\n  //wbcz\n  //对象获取属性的值本来就可以通过[]来获取。\n```\n\n再改进一下\n```\nvar a = {\n    0: 1,\n    1: \"wbcz\",\n    length: 2,\n    splice: [].splice\n};\nfor (var i = 0; i < a.length; i++) {\n\tconsole.log(a[i])\n}\n//1\n//wbcz\n```\n","slug":"js-foundation-object变成类数组对象","published":1,"date":"2017-04-23T23:47:34.000Z","updated":"2017-04-23T23:47:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chd003qkzy658loq289","content":"<p>先看JQ如何做的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.fn = jQuery.prototype = &#123;</div><div class=\"line\">    // The default length of a jQuery object is 0</div><div class=\"line\">    length: 0,</div><div class=\"line\">    splice: arr.splice</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>为什么会jquery返回的是一个数组，看代码你就明白了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123;</div><div class=\"line\">   id: 1,</div><div class=\"line\">   name: &quot;wbcz&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> for (var i = 0; i &lt; a.length; i++) &#123;</div><div class=\"line\">   console.log(a[i]) </div><div class=\"line\"> &#125;</div><div class=\"line\"> //没有打印，因为a.length为undefined</div></pre></td></tr></table></figure></p>\n<p>再次该进一下呢<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123;</div><div class=\"line\">   id: 1,</div><div class=\"line\">   name: &quot;wbcz&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> for (var i = 0; i &lt; a.length; i++) &#123;</div><div class=\"line\">   console.log(a[i]) </div><div class=\"line\"> &#125;</div><div class=\"line\"> //1</div><div class=\"line\"> //wbcz</div><div class=\"line\"> //对象获取属性的值本来就可以通过[]来获取。</div></pre></td></tr></table></figure></p>\n<p>再改进一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123;</div><div class=\"line\">    0: 1,</div><div class=\"line\">    1: &quot;wbcz&quot;,</div><div class=\"line\">    length: 2,</div><div class=\"line\">    splice: [].splice</div><div class=\"line\">&#125;;</div><div class=\"line\">for (var i = 0; i &lt; a.length; i++) &#123;</div><div class=\"line\">\tconsole.log(a[i])</div><div class=\"line\">&#125;</div><div class=\"line\">//1</div><div class=\"line\">//wbcz</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>先看JQ如何做的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">jQuery.fn = jQuery.prototype = &#123;</div><div class=\"line\">    // The default length of a jQuery object is 0</div><div class=\"line\">    length: 0,</div><div class=\"line\">    splice: arr.splice</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>为什么会jquery返回的是一个数组，看代码你就明白了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123;</div><div class=\"line\">   id: 1,</div><div class=\"line\">   name: &quot;wbcz&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> for (var i = 0; i &lt; a.length; i++) &#123;</div><div class=\"line\">   console.log(a[i]) </div><div class=\"line\"> &#125;</div><div class=\"line\"> //没有打印，因为a.length为undefined</div></pre></td></tr></table></figure></p>\n<p>再次该进一下呢<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123;</div><div class=\"line\">   id: 1,</div><div class=\"line\">   name: &quot;wbcz&quot;</div><div class=\"line\"> &#125;;</div><div class=\"line\"> for (var i = 0; i &lt; a.length; i++) &#123;</div><div class=\"line\">   console.log(a[i]) </div><div class=\"line\"> &#125;</div><div class=\"line\"> //1</div><div class=\"line\"> //wbcz</div><div class=\"line\"> //对象获取属性的值本来就可以通过[]来获取。</div></pre></td></tr></table></figure></p>\n<p>再改进一下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var a = &#123;</div><div class=\"line\">    0: 1,</div><div class=\"line\">    1: &quot;wbcz&quot;,</div><div class=\"line\">    length: 2,</div><div class=\"line\">    splice: [].splice</div><div class=\"line\">&#125;;</div><div class=\"line\">for (var i = 0; i &lt; a.length; i++) &#123;</div><div class=\"line\">\tconsole.log(a[i])</div><div class=\"line\">&#125;</div><div class=\"line\">//1</div><div class=\"line\">//wbcz</div></pre></td></tr></table></figure></p>\n"},{"title":"this隐式丢失","type":"categories","_content":"\n### this的上下文\n\n```\nlet person = {\n\tcount: 1,\n\tgetCount: function() {\n\t\treturn this.count;\n\t}\n}\n\nconsole.log(person.getCount())\n\n//但是当:\n\n  let func = person.getCount //this 丢失了\n\n  console.log(funct())  // undefined\n\n //如何解决呢\n\n let func = person.getCount.bind(person)\n\n \tconsole.log(funct())  // 1\n\n```\n\n\n```\n\nFunction.prototype.bind = Function.prototype.bind || function(context) {\n \tlet self = this\n \treturn function() {\n \t\tlet args = Array.prototype.slice.call(arguments)\n \t\tself.apply(context, args)\n \t}\n}\n\nlet person = {\n\tcount: 1,\n\tgetCount: function() {\n\t\tconsole.log(arguments) //[2, 6]\n\t\treturn this.count;\n\t}\n}\n\nlet func = person.getCount.bind(person)\n\nfunc(2,6)\n\n```","source":"_posts/js/foundation/this隐式丢失.md","raw":"---\ntitle: this隐式丢失\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n### this的上下文\n\n```\nlet person = {\n\tcount: 1,\n\tgetCount: function() {\n\t\treturn this.count;\n\t}\n}\n\nconsole.log(person.getCount())\n\n//但是当:\n\n  let func = person.getCount //this 丢失了\n\n  console.log(funct())  // undefined\n\n //如何解决呢\n\n let func = person.getCount.bind(person)\n\n \tconsole.log(funct())  // 1\n\n```\n\n\n```\n\nFunction.prototype.bind = Function.prototype.bind || function(context) {\n \tlet self = this\n \treturn function() {\n \t\tlet args = Array.prototype.slice.call(arguments)\n \t\tself.apply(context, args)\n \t}\n}\n\nlet person = {\n\tcount: 1,\n\tgetCount: function() {\n\t\tconsole.log(arguments) //[2, 6]\n\t\treturn this.count;\n\t}\n}\n\nlet func = person.getCount.bind(person)\n\nfunc(2,6)\n\n```","slug":"js-foundation-this隐式丢失","published":1,"date":"2017-04-23T11:10:37.000Z","updated":"2017-04-23T11:10:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11che003tkzy61w26laj3","content":"<h3 id=\"this的上下文\"><a href=\"#this的上下文\" class=\"headerlink\" title=\"this的上下文\"></a>this的上下文</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">let person = &#123;</div><div class=\"line\">\tcount: 1,</div><div class=\"line\">\tgetCount: function() &#123;</div><div class=\"line\">\t\treturn this.count;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(person.getCount())</div><div class=\"line\"></div><div class=\"line\">//但是当:</div><div class=\"line\"></div><div class=\"line\">  let func = person.getCount //this 丢失了</div><div class=\"line\"></div><div class=\"line\">  console.log(funct())  // undefined</div><div class=\"line\"></div><div class=\"line\"> //如何解决呢</div><div class=\"line\"></div><div class=\"line\"> let func = person.getCount.bind(person)</div><div class=\"line\"></div><div class=\"line\"> \tconsole.log(funct())  // 1</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Function.prototype.bind = Function.prototype.bind || function(context) &#123;</div><div class=\"line\"> \tlet self = this</div><div class=\"line\"> \treturn function() &#123;</div><div class=\"line\"> \t\tlet args = Array.prototype.slice.call(arguments)</div><div class=\"line\"> \t\tself.apply(context, args)</div><div class=\"line\"> \t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let person = &#123;</div><div class=\"line\">\tcount: 1,</div><div class=\"line\">\tgetCount: function() &#123;</div><div class=\"line\">\t\tconsole.log(arguments) //[2, 6]</div><div class=\"line\">\t\treturn this.count;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let func = person.getCount.bind(person)</div><div class=\"line\"></div><div class=\"line\">func(2,6)</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"this的上下文\"><a href=\"#this的上下文\" class=\"headerlink\" title=\"this的上下文\"></a>this的上下文</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">let person = &#123;</div><div class=\"line\">\tcount: 1,</div><div class=\"line\">\tgetCount: function() &#123;</div><div class=\"line\">\t\treturn this.count;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(person.getCount())</div><div class=\"line\"></div><div class=\"line\">//但是当:</div><div class=\"line\"></div><div class=\"line\">  let func = person.getCount //this 丢失了</div><div class=\"line\"></div><div class=\"line\">  console.log(funct())  // undefined</div><div class=\"line\"></div><div class=\"line\"> //如何解决呢</div><div class=\"line\"></div><div class=\"line\"> let func = person.getCount.bind(person)</div><div class=\"line\"></div><div class=\"line\"> \tconsole.log(funct())  // 1</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">Function.prototype.bind = Function.prototype.bind || function(context) &#123;</div><div class=\"line\"> \tlet self = this</div><div class=\"line\"> \treturn function() &#123;</div><div class=\"line\"> \t\tlet args = Array.prototype.slice.call(arguments)</div><div class=\"line\"> \t\tself.apply(context, args)</div><div class=\"line\"> \t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let person = &#123;</div><div class=\"line\">\tcount: 1,</div><div class=\"line\">\tgetCount: function() &#123;</div><div class=\"line\">\t\tconsole.log(arguments) //[2, 6]</div><div class=\"line\">\t\treturn this.count;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let func = person.getCount.bind(person)</div><div class=\"line\"></div><div class=\"line\">func(2,6)</div></pre></td></tr></table></figure>"},{"title":"代码优化之道","type":"categories","_content":"\n### 抛弃掉你的循环和push吧！\n\nlet persons = [\n\t{ name: 'wb', age: 22 },\n\t{ name: 'zz', age: 32 },\n\t{ name: 'yy', age: 14 },\n]\n\nconst isGetAge = item => item.age > 20\nconst getName = item => item.name\nconst getReqNames = names => names.filter(isGetAge).map(getName)\n\nlet result = getReqNames(persons)\n\nconsole.log(result)","source":"_posts/js/foundation/代码优化之道.md","raw":"---\ntitle: 代码优化之道\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n### 抛弃掉你的循环和push吧！\n\nlet persons = [\n\t{ name: 'wb', age: 22 },\n\t{ name: 'zz', age: 32 },\n\t{ name: 'yy', age: 14 },\n]\n\nconst isGetAge = item => item.age > 20\nconst getName = item => item.name\nconst getReqNames = names => names.filter(isGetAge).map(getName)\n\nlet result = getReqNames(persons)\n\nconsole.log(result)","slug":"js-foundation-代码优化之道","published":1,"date":"2017-04-23T11:08:58.000Z","updated":"2017-04-23T11:08:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chg003vkzy68xw5ikei","content":"<h3 id=\"抛弃掉你的循环和push吧！\"><a href=\"#抛弃掉你的循环和push吧！\" class=\"headerlink\" title=\"抛弃掉你的循环和push吧！\"></a>抛弃掉你的循环和push吧！</h3><p>let persons = [<br>    { name: ‘wb’, age: 22 },<br>    { name: ‘zz’, age: 32 },<br>    { name: ‘yy’, age: 14 },<br>]</p>\n<p>const isGetAge = item =&gt; item.age &gt; 20<br>const getName = item =&gt; item.name<br>const getReqNames = names =&gt; names.filter(isGetAge).map(getName)</p>\n<p>let result = getReqNames(persons)</p>\n<p>console.log(result)</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"抛弃掉你的循环和push吧！\"><a href=\"#抛弃掉你的循环和push吧！\" class=\"headerlink\" title=\"抛弃掉你的循环和push吧！\"></a>抛弃掉你的循环和push吧！</h3><p>let persons = [<br>    { name: ‘wb’, age: 22 },<br>    { name: ‘zz’, age: 32 },<br>    { name: ‘yy’, age: 14 },<br>]</p>\n<p>const isGetAge = item =&gt; item.age &gt; 20<br>const getName = item =&gt; item.name<br>const getReqNames = names =&gt; names.filter(isGetAge).map(getName)</p>\n<p>let result = getReqNames(persons)</p>\n<p>console.log(result)</p>\n"},{"title":"传递引用非引用传递","type":"categories","_content":"\n### js没有引用传递，只有传递引用，you know ?\n\n```\nfunction changeStuff(a, b, c)\n{\n  a = a * 10;\n  b.item = \"changed\";\n  c = {item: \"changed\"};\n}\n\nvar num = 10; //值传递\nvar obj1 = {item: \"unchanged\"}; //传递引用\nvar obj2 = {item: \"unchanged\"}; \n\nchangeStuff(num, obj1, obj2);\n\nconsole.log(num); //10\nconsole.log(obj1.item);  // changed\nconsole.log(obj2.item);\t // unchanged\n\n```\n\n","source":"_posts/js/foundation/传递引用非引用传递.md","raw":"---\ntitle: 传递引用非引用传递\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n### js没有引用传递，只有传递引用，you know ?\n\n```\nfunction changeStuff(a, b, c)\n{\n  a = a * 10;\n  b.item = \"changed\";\n  c = {item: \"changed\"};\n}\n\nvar num = 10; //值传递\nvar obj1 = {item: \"unchanged\"}; //传递引用\nvar obj2 = {item: \"unchanged\"}; \n\nchangeStuff(num, obj1, obj2);\n\nconsole.log(num); //10\nconsole.log(obj1.item);  // changed\nconsole.log(obj2.item);\t // unchanged\n\n```\n\n","slug":"js-foundation-传递引用非引用传递","published":1,"date":"2017-04-23T11:09:05.000Z","updated":"2017-04-23T11:09:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chi003ykzy6fwuuh18i","content":"<h3 id=\"js没有引用传递，只有传递引用，you-know\"><a href=\"#js没有引用传递，只有传递引用，you-know\" class=\"headerlink\" title=\"js没有引用传递，只有传递引用，you know ?\"></a>js没有引用传递，只有传递引用，you know ?</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function changeStuff(a, b, c)</div><div class=\"line\">&#123;</div><div class=\"line\">  a = a * 10;</div><div class=\"line\">  b.item = &quot;changed&quot;;</div><div class=\"line\">  c = &#123;item: &quot;changed&quot;&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var num = 10; //值传递</div><div class=\"line\">var obj1 = &#123;item: &quot;unchanged&quot;&#125;; //传递引用</div><div class=\"line\">var obj2 = &#123;item: &quot;unchanged&quot;&#125;; </div><div class=\"line\"></div><div class=\"line\">changeStuff(num, obj1, obj2);</div><div class=\"line\"></div><div class=\"line\">console.log(num); //10</div><div class=\"line\">console.log(obj1.item);  // changed</div><div class=\"line\">console.log(obj2.item);\t // unchanged</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"js没有引用传递，只有传递引用，you-know\"><a href=\"#js没有引用传递，只有传递引用，you-know\" class=\"headerlink\" title=\"js没有引用传递，只有传递引用，you know ?\"></a>js没有引用传递，只有传递引用，you know ?</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function changeStuff(a, b, c)</div><div class=\"line\">&#123;</div><div class=\"line\">  a = a * 10;</div><div class=\"line\">  b.item = &quot;changed&quot;;</div><div class=\"line\">  c = &#123;item: &quot;changed&quot;&#125;;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var num = 10; //值传递</div><div class=\"line\">var obj1 = &#123;item: &quot;unchanged&quot;&#125;; //传递引用</div><div class=\"line\">var obj2 = &#123;item: &quot;unchanged&quot;&#125;; </div><div class=\"line\"></div><div class=\"line\">changeStuff(num, obj1, obj2);</div><div class=\"line\"></div><div class=\"line\">console.log(num); //10</div><div class=\"line\">console.log(obj1.item);  // changed</div><div class=\"line\">console.log(obj2.item);\t // unchanged</div></pre></td></tr></table></figure>\n"},{"title":"函数","type":"categories","_content":"\nJavascript函数式为何如此重要\n\n### 浏览器的事件轮询（单线程）\n浏览器事件，如当一个页面加载完成的时候\n网络事件，如响应ajax请求\n用户事件： 鼠标点击\n计时器事件： 如超时\n\n这些事件都可能是穿插进行，先进先出，其实我们维护的就是一个事件队列\n\n### 函数调用\n- 作为函数调用\n- 作为方法调用 \n- 作为构造器调用\n- 使用call()和apply()方法进行调用","source":"_posts/js/foundation/函数.md","raw":"---\ntitle: 函数\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\nJavascript函数式为何如此重要\n\n### 浏览器的事件轮询（单线程）\n浏览器事件，如当一个页面加载完成的时候\n网络事件，如响应ajax请求\n用户事件： 鼠标点击\n计时器事件： 如超时\n\n这些事件都可能是穿插进行，先进先出，其实我们维护的就是一个事件队列\n\n### 函数调用\n- 作为函数调用\n- 作为方法调用 \n- 作为构造器调用\n- 使用call()和apply()方法进行调用","slug":"js-foundation-函数","published":1,"date":"2017-04-23T11:09:12.000Z","updated":"2017-04-23T11:09:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chj0040kzy6pfbzfaep","content":"<p>Javascript函数式为何如此重要</p>\n<h3 id=\"浏览器的事件轮询（单线程）\"><a href=\"#浏览器的事件轮询（单线程）\" class=\"headerlink\" title=\"浏览器的事件轮询（单线程）\"></a>浏览器的事件轮询（单线程）</h3><p>浏览器事件，如当一个页面加载完成的时候<br>网络事件，如响应ajax请求<br>用户事件： 鼠标点击<br>计时器事件： 如超时</p>\n<p>这些事件都可能是穿插进行，先进先出，其实我们维护的就是一个事件队列</p>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><ul>\n<li>作为函数调用</li>\n<li>作为方法调用 </li>\n<li>作为构造器调用</li>\n<li>使用call()和apply()方法进行调用</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Javascript函数式为何如此重要</p>\n<h3 id=\"浏览器的事件轮询（单线程）\"><a href=\"#浏览器的事件轮询（单线程）\" class=\"headerlink\" title=\"浏览器的事件轮询（单线程）\"></a>浏览器的事件轮询（单线程）</h3><p>浏览器事件，如当一个页面加载完成的时候<br>网络事件，如响应ajax请求<br>用户事件： 鼠标点击<br>计时器事件： 如超时</p>\n<p>这些事件都可能是穿插进行，先进先出，其实我们维护的就是一个事件队列</p>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><ul>\n<li>作为函数调用</li>\n<li>作为方法调用 </li>\n<li>作为构造器调用</li>\n<li>使用call()和apply()方法进行调用</li>\n</ul>\n"},{"title":"单页路由的实现","type":"categories","_content":"\n### 简单聊聊前端路由实现\n\n#### 1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\n\n```\n\tclass Router {\n\n\t    constructor() {\n\t        this.routes = {} //存储所有路由\n\t        this.currentUrl = ''\n\n\t        this.init()\n\t    }\n\n\t    route(url, callback) {\n\t        this.routes[url] = callback || function(){}\n\t    }\n\n\t    refresh() {\n\t        this.currentUrl = location.hash.substr(1) || '/'\n\t        this.routes[this.currentUrl]()\n\t    }\n\n\t    init() {\n\t        window.addEventListener('load', this.refresh.bind(this))\n\t        window.addEventListener('hashchange', this.refresh.bind(this))\n\t    }\n\t}\n\n\tlet routers = new Router();\n\n\trouters.route('/',function() {\n\t    oDiv1.innerHTML = '欢迎回到成都'\n\t})\n\trouters.route('shanghai',function() {\n\t    oDiv1.innerHTML = '欢迎来到上海'\n\t})\n\trouters.route('beijing',function() {\n\t    oDiv1.innerHTML = '欢迎来到北京'\n\t})\n\n```\n\n### HTML5中 history.pushState、history.replaceState() 和 onpopstate 事件 \n\n```\n\t前两个都有三个参数，第一个传递的状态对象(数据），第二个标题，第三个是URL（绝对路径和相对路径都可以）\n\thistory.pushState()不会主动触发，需要用事件触发来执行\n\thistory.replaceState()主要用于当用户再次刷新页面的时候，将原来保存的数据，然后重新加载\n\n\tonpopstate中event.state保存着一个状态对象的拷贝，浏览器返回前进的时候会触发\n\t页面重新加载，onload事件触发的时候，onpopstate也不会触发，但是如果你想获得state的状态属性，可以直接通过history.state,不需要等待onpopstate事件\n\n\n\t另外补充几个API：history.go(),history.back(),history.forward()\n```\n\n\n### 先简单的谈到这里，后续会再次深入了解\n\n\n\n\n","source":"_posts/js/foundation/单页路由的实现.md","raw":"---\ntitle: 单页路由的实现\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n### 简单聊聊前端路由实现\n\n#### 1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\n\n```\n\tclass Router {\n\n\t    constructor() {\n\t        this.routes = {} //存储所有路由\n\t        this.currentUrl = ''\n\n\t        this.init()\n\t    }\n\n\t    route(url, callback) {\n\t        this.routes[url] = callback || function(){}\n\t    }\n\n\t    refresh() {\n\t        this.currentUrl = location.hash.substr(1) || '/'\n\t        this.routes[this.currentUrl]()\n\t    }\n\n\t    init() {\n\t        window.addEventListener('load', this.refresh.bind(this))\n\t        window.addEventListener('hashchange', this.refresh.bind(this))\n\t    }\n\t}\n\n\tlet routers = new Router();\n\n\trouters.route('/',function() {\n\t    oDiv1.innerHTML = '欢迎回到成都'\n\t})\n\trouters.route('shanghai',function() {\n\t    oDiv1.innerHTML = '欢迎来到上海'\n\t})\n\trouters.route('beijing',function() {\n\t    oDiv1.innerHTML = '欢迎来到北京'\n\t})\n\n```\n\n### HTML5中 history.pushState、history.replaceState() 和 onpopstate 事件 \n\n```\n\t前两个都有三个参数，第一个传递的状态对象(数据），第二个标题，第三个是URL（绝对路径和相对路径都可以）\n\thistory.pushState()不会主动触发，需要用事件触发来执行\n\thistory.replaceState()主要用于当用户再次刷新页面的时候，将原来保存的数据，然后重新加载\n\n\tonpopstate中event.state保存着一个状态对象的拷贝，浏览器返回前进的时候会触发\n\t页面重新加载，onload事件触发的时候，onpopstate也不会触发，但是如果你想获得state的状态属性，可以直接通过history.state,不需要等待onpopstate事件\n\n\n\t另外补充几个API：history.go(),history.back(),history.forward()\n```\n\n\n### 先简单的谈到这里，后续会再次深入了解\n\n\n\n\n","slug":"js-foundation-单页路由的实现","published":1,"date":"2017-04-23T11:09:16.000Z","updated":"2017-04-23T11:09:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chk0043kzy6gfuadjsw","content":"<h3 id=\"简单聊聊前端路由实现\"><a href=\"#简单聊聊前端路由实现\" class=\"headerlink\" title=\"简单聊聊前端路由实现\"></a>简单聊聊前端路由实现</h3><h4 id=\"1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\"><a href=\"#1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\" class=\"headerlink\" title=\"1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\"></a>1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Router &#123;</div><div class=\"line\"></div><div class=\"line\">    constructor() &#123;</div><div class=\"line\">        this.routes = &#123;&#125; //存储所有路由</div><div class=\"line\">        this.currentUrl = &apos;&apos;</div><div class=\"line\"></div><div class=\"line\">        this.init()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    route(url, callback) &#123;</div><div class=\"line\">        this.routes[url] = callback || function()&#123;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    refresh() &#123;</div><div class=\"line\">        this.currentUrl = location.hash.substr(1) || &apos;/&apos;</div><div class=\"line\">        this.routes[this.currentUrl]()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    init() &#123;</div><div class=\"line\">        window.addEventListener(&apos;load&apos;, this.refresh.bind(this))</div><div class=\"line\">        window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let routers = new Router();</div><div class=\"line\"></div><div class=\"line\">routers.route(&apos;/&apos;,function() &#123;</div><div class=\"line\">    oDiv1.innerHTML = &apos;欢迎回到成都&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">routers.route(&apos;shanghai&apos;,function() &#123;</div><div class=\"line\">    oDiv1.innerHTML = &apos;欢迎来到上海&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">routers.route(&apos;beijing&apos;,function() &#123;</div><div class=\"line\">    oDiv1.innerHTML = &apos;欢迎来到北京&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"HTML5中-history-pushState、history-replaceState-和-onpopstate-事件\"><a href=\"#HTML5中-history-pushState、history-replaceState-和-onpopstate-事件\" class=\"headerlink\" title=\"HTML5中 history.pushState、history.replaceState() 和 onpopstate 事件\"></a>HTML5中 history.pushState、history.replaceState() 和 onpopstate 事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">前两个都有三个参数，第一个传递的状态对象(数据），第二个标题，第三个是URL（绝对路径和相对路径都可以）</div><div class=\"line\">history.pushState()不会主动触发，需要用事件触发来执行</div><div class=\"line\">history.replaceState()主要用于当用户再次刷新页面的时候，将原来保存的数据，然后重新加载</div><div class=\"line\"></div><div class=\"line\">onpopstate中event.state保存着一个状态对象的拷贝，浏览器返回前进的时候会触发</div><div class=\"line\">页面重新加载，onload事件触发的时候，onpopstate也不会触发，但是如果你想获得state的状态属性，可以直接通过history.state,不需要等待onpopstate事件</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">另外补充几个API：history.go(),history.back(),history.forward()</div></pre></td></tr></table></figure>\n<h3 id=\"先简单的谈到这里，后续会再次深入了解\"><a href=\"#先简单的谈到这里，后续会再次深入了解\" class=\"headerlink\" title=\"先简单的谈到这里，后续会再次深入了解\"></a>先简单的谈到这里，后续会再次深入了解</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简单聊聊前端路由实现\"><a href=\"#简单聊聊前端路由实现\" class=\"headerlink\" title=\"简单聊聊前端路由实现\"></a>简单聊聊前端路由实现</h3><h4 id=\"1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\"><a href=\"#1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\" class=\"headerlink\" title=\"1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理\"></a>1、古老的onhashchange实现，但是兼容性很好哟，本质在于地址和函数的匹配存储，类似于观察者模式的实现原理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Router &#123;</div><div class=\"line\"></div><div class=\"line\">    constructor() &#123;</div><div class=\"line\">        this.routes = &#123;&#125; //存储所有路由</div><div class=\"line\">        this.currentUrl = &apos;&apos;</div><div class=\"line\"></div><div class=\"line\">        this.init()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    route(url, callback) &#123;</div><div class=\"line\">        this.routes[url] = callback || function()&#123;&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    refresh() &#123;</div><div class=\"line\">        this.currentUrl = location.hash.substr(1) || &apos;/&apos;</div><div class=\"line\">        this.routes[this.currentUrl]()</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    init() &#123;</div><div class=\"line\">        window.addEventListener(&apos;load&apos;, this.refresh.bind(this))</div><div class=\"line\">        window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this))</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let routers = new Router();</div><div class=\"line\"></div><div class=\"line\">routers.route(&apos;/&apos;,function() &#123;</div><div class=\"line\">    oDiv1.innerHTML = &apos;欢迎回到成都&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">routers.route(&apos;shanghai&apos;,function() &#123;</div><div class=\"line\">    oDiv1.innerHTML = &apos;欢迎来到上海&apos;</div><div class=\"line\">&#125;)</div><div class=\"line\">routers.route(&apos;beijing&apos;,function() &#123;</div><div class=\"line\">    oDiv1.innerHTML = &apos;欢迎来到北京&apos;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"HTML5中-history-pushState、history-replaceState-和-onpopstate-事件\"><a href=\"#HTML5中-history-pushState、history-replaceState-和-onpopstate-事件\" class=\"headerlink\" title=\"HTML5中 history.pushState、history.replaceState() 和 onpopstate 事件\"></a>HTML5中 history.pushState、history.replaceState() 和 onpopstate 事件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">前两个都有三个参数，第一个传递的状态对象(数据），第二个标题，第三个是URL（绝对路径和相对路径都可以）</div><div class=\"line\">history.pushState()不会主动触发，需要用事件触发来执行</div><div class=\"line\">history.replaceState()主要用于当用户再次刷新页面的时候，将原来保存的数据，然后重新加载</div><div class=\"line\"></div><div class=\"line\">onpopstate中event.state保存着一个状态对象的拷贝，浏览器返回前进的时候会触发</div><div class=\"line\">页面重新加载，onload事件触发的时候，onpopstate也不会触发，但是如果你想获得state的状态属性，可以直接通过history.state,不需要等待onpopstate事件</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">另外补充几个API：history.go(),history.back(),history.forward()</div></pre></td></tr></table></figure>\n<h3 id=\"先简单的谈到这里，后续会再次深入了解\"><a href=\"#先简单的谈到这里，后续会再次深入了解\" class=\"headerlink\" title=\"先简单的谈到这里，后续会再次深入了解\"></a>先简单的谈到这里，后续会再次深入了解</h3>"},{"title":"如何写组件","type":"categories","_content":"\n# 为什么要写组件\n原因很简单，就是为了复用，减少代码冗余，容易维护\n\n# 组件的组成形式\n - model负责接收数据\n - view负责填充数据\n - controller负责交互行为\n\n# 什么是好的组件\n方便拓展，依赖少，复用性强\n\n# 组件注意要点\n业务组件需要把业务逻辑的部分留个占位的，以便处理更多奇葩的需求","source":"_posts/js/foundation/如何写组件.md","raw":"---\ntitle: 如何写组件\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n# 为什么要写组件\n原因很简单，就是为了复用，减少代码冗余，容易维护\n\n# 组件的组成形式\n - model负责接收数据\n - view负责填充数据\n - controller负责交互行为\n\n# 什么是好的组件\n方便拓展，依赖少，复用性强\n\n# 组件注意要点\n业务组件需要把业务逻辑的部分留个占位的，以便处理更多奇葩的需求","slug":"js-foundation-如何写组件","published":1,"date":"2017-05-13T10:46:25.000Z","updated":"2017-05-13T10:46:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chm0045kzy6y7ouldzy","content":"<h1 id=\"为什么要写组件\"><a href=\"#为什么要写组件\" class=\"headerlink\" title=\"为什么要写组件\"></a>为什么要写组件</h1><p>原因很简单，就是为了复用，减少代码冗余，容易维护</p>\n<h1 id=\"组件的组成形式\"><a href=\"#组件的组成形式\" class=\"headerlink\" title=\"组件的组成形式\"></a>组件的组成形式</h1><ul>\n<li>model负责接收数据</li>\n<li>view负责填充数据</li>\n<li>controller负责交互行为</li>\n</ul>\n<h1 id=\"什么是好的组件\"><a href=\"#什么是好的组件\" class=\"headerlink\" title=\"什么是好的组件\"></a>什么是好的组件</h1><p>方便拓展，依赖少，复用性强</p>\n<h1 id=\"组件注意要点\"><a href=\"#组件注意要点\" class=\"headerlink\" title=\"组件注意要点\"></a>组件注意要点</h1><p>业务组件需要把业务逻辑的部分留个占位的，以便处理更多奇葩的需求</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"为什么要写组件\"><a href=\"#为什么要写组件\" class=\"headerlink\" title=\"为什么要写组件\"></a>为什么要写组件</h1><p>原因很简单，就是为了复用，减少代码冗余，容易维护</p>\n<h1 id=\"组件的组成形式\"><a href=\"#组件的组成形式\" class=\"headerlink\" title=\"组件的组成形式\"></a>组件的组成形式</h1><ul>\n<li>model负责接收数据</li>\n<li>view负责填充数据</li>\n<li>controller负责交互行为</li>\n</ul>\n<h1 id=\"什么是好的组件\"><a href=\"#什么是好的组件\" class=\"headerlink\" title=\"什么是好的组件\"></a>什么是好的组件</h1><p>方便拓展，依赖少，复用性强</p>\n<h1 id=\"组件注意要点\"><a href=\"#组件注意要点\" class=\"headerlink\" title=\"组件注意要点\"></a>组件注意要点</h1><p>业务组件需要把业务逻辑的部分留个占位的，以便处理更多奇葩的需求</p>\n"},{"title":"文档流","type":"categories","_content":"\n## 定位流\n## 浮动流\n## 普通流（BFC)\nblock formatting context 块格式化上下文，他是页面中一块渲染区域，有一套渲染规则，决定了将子元素如何布局，以及其他元素之间的关系和作用\n\n## 触发条件\n满足条件之一就可以触发BFC\n1.根元素，即HTML元素\n2.float的值不为none\n3。overflow的值不为visible\n4.display的值为inline-block、table-cell、table-caption\n5.position的值为absolute或fixed\n\n[参考](http://www.cnblogs.com/xiaohuochai/p/5248536.html)\n","source":"_posts/js/foundation/文档流.md","raw":"---\ntitle: 文档流\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n## 定位流\n## 浮动流\n## 普通流（BFC)\nblock formatting context 块格式化上下文，他是页面中一块渲染区域，有一套渲染规则，决定了将子元素如何布局，以及其他元素之间的关系和作用\n\n## 触发条件\n满足条件之一就可以触发BFC\n1.根元素，即HTML元素\n2.float的值不为none\n3。overflow的值不为visible\n4.display的值为inline-block、table-cell、table-caption\n5.position的值为absolute或fixed\n\n[参考](http://www.cnblogs.com/xiaohuochai/p/5248536.html)\n","slug":"js-foundation-文档流","published":1,"date":"2017-04-23T11:09:22.000Z","updated":"2017-04-23T11:09:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chs0048kzy6bb8z8vmx","content":"<h2 id=\"定位流\"><a href=\"#定位流\" class=\"headerlink\" title=\"定位流\"></a>定位流</h2><h2 id=\"浮动流\"><a href=\"#浮动流\" class=\"headerlink\" title=\"浮动流\"></a>浮动流</h2><h2 id=\"普通流（BFC\"><a href=\"#普通流（BFC\" class=\"headerlink\" title=\"普通流（BFC)\"></a>普通流（BFC)</h2><p>block formatting context 块格式化上下文，他是页面中一块渲染区域，有一套渲染规则，决定了将子元素如何布局，以及其他元素之间的关系和作用</p>\n<h2 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h2><p>满足条件之一就可以触发BFC<br>1.根元素，即HTML元素<br>2.float的值不为none<br>3。overflow的值不为visible<br>4.display的值为inline-block、table-cell、table-caption<br>5.position的值为absolute或fixed</p>\n<p><a href=\"http://www.cnblogs.com/xiaohuochai/p/5248536.html\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"定位流\"><a href=\"#定位流\" class=\"headerlink\" title=\"定位流\"></a>定位流</h2><h2 id=\"浮动流\"><a href=\"#浮动流\" class=\"headerlink\" title=\"浮动流\"></a>浮动流</h2><h2 id=\"普通流（BFC\"><a href=\"#普通流（BFC\" class=\"headerlink\" title=\"普通流（BFC)\"></a>普通流（BFC)</h2><p>block formatting context 块格式化上下文，他是页面中一块渲染区域，有一套渲染规则，决定了将子元素如何布局，以及其他元素之间的关系和作用</p>\n<h2 id=\"触发条件\"><a href=\"#触发条件\" class=\"headerlink\" title=\"触发条件\"></a>触发条件</h2><p>满足条件之一就可以触发BFC<br>1.根元素，即HTML元素<br>2.float的值不为none<br>3。overflow的值不为visible<br>4.display的值为inline-block、table-cell、table-caption<br>5.position的值为absolute或fixed</p>\n<p><a href=\"http://www.cnblogs.com/xiaohuochai/p/5248536.html\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"JS中的柯里化","type":"categories","_content":"## 柯里化概念\n\n柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\n\n```\nvar currying = function(fn) {\n    // fn 指官员消化老婆的手段\n    var args = [].slice.call(arguments, 1);\n    // args 指的是那个合法老婆\n    return function() {\n        // 已经有的老婆和新搞定的老婆们合成一体，方便控制\n        var newArgs = args.concat([].slice.call(arguments));\n        // 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回\n        return fn.apply(null, newArgs);\n    };\n};\n\n// 下为官员如何搞定7个老婆的测试\n// 获得合法老婆\nvar getWife = currying(function() {\n    var allWife = [].slice.call(arguments);\n    // allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆\n    console.log(allWife.join(\";\"));\n}, \"合法老婆\");\n\n// 获得其他6个老婆\ngetWife(\"大老婆\",\"小老婆\",\"俏老婆\",\"刁蛮老婆\",\"乖老婆\",\"送上门老婆\");\n\n// 换一批老婆\ngetWife(\"超越韦小宝的老婆\");\n```\n\n```\nvar smallKenan = function(action) {\n    var bigKenan = function(doing) {\n        var result = \"\";\n        if (action === \"take drugs\") {\n            if (doing === \"bathWithGirlFriend\") {\n                result = \"尖叫，新一，你这个色狼，然后一巴掌，脸煮熟了~\";\n            } else if (doing === \"pointOutKiller\") {\n                result = \"新一，这个案子就交给你的，快点找出谁是凶手吧~\";\n            }\n        } else {\n            if (doing === \"bathWithGirlFriend\") {\n                result = \"来吧，柯南，一起洗澡吧~\";\n            } else if (doing === \"pointOutKiller\") {\n                result = \"小孩子家，滚一边去！\";\n            }\n        }\n        console.log(result);\n        return arguments.callee; // 等同于return bigKenan\n    };\n    return bigKenan;\n};\n\n// 小柯南吃药了，然后和毛利兰洗澡，凶案现场指证犯人；结果是……\nsmallKenan(\"take drugs\")(\"bathWithGirlFriend\")(\"pointOutKiller\");\n```\n“吃药”、“洗澡”、“指出凶手”就可以看成三个参数，其中，“吃药”确实是小柯南使用的，而后面的是“洗澡”、“指出凶手”虽然跟在smallKenan()后面，实际上是大柯南使用的。这个就是柯里化，参数部分使用。外部函数处理部分应用，剩下的由外部函数的返回函数处理。\n\n\n## 柯里化的作用\n\n### 参数复用(示例见上)\n\n### 提前返回\n```\nvar addEvent = function(element, type, fn, capture) {\n\tif(window.addEventListener) {\n\t\telement.addEventListener(type, function(e) {\n\t\t\tfn.call(element, e)\n\t\t}, capture)\n\t} else if(window.attachEvent) {\n\t\telement.attachEvent('on'+ type, function(e) {\n\t\t\tfn.call(element, e)\n\t\t})\n\t}\n}\n\n```\n上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，(eg. IE6/IE7)都会走一遍if...else if ...，其实只要一次判定就可以了，怎么做？–柯里化。改为下面这样子的代码：\n\n```\nvar addEvent = (function(){\n    if (window.addEventListener) {\n        return function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        return function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n})();\n\n```\n初始addEvent的执行其实值实现了部分的应用（只有一次的if...else if...判定），而剩余的参数应用都是其返回函数实现的，典型的柯里化。\n\n### 延迟计算\n\n```\n//常规写法\nvar fishWeight = 0;\nvar addWeight = function(weight) {\n    fishWeight += weight;\n};\n\naddWeight(2.3);\naddWeight(6.5);\naddWeight(1.2);\naddWeight(2.5);\n\nconsole.log(fishWeight);   // 12.5\n```\n\n### 柯里化的实现\n\n```\nvar curryweight = function(fn) {\n\tvar _fishWeight = []\n\treturn function() {\n\t\tif(arguments.length === 0) {\n\t\t\treturn fn.apply(null, _fishWeight)\n\t\t} else {\n\t\t\t_fishWeight = _fishWeight.concat([].slice.call(arguments))\n\t\t}\n\t}\n}\n\nvar _fishWeight = 0\nvar addweight = curryweight(function() {\n    var i=0; len = arguments.length;\n    for (i; i<len; i+=1) {\n    \tfishWeight += arguments[i];\n    }\n})\n```\n确实，柯里化的实现似乎啰嗦了点。老妈的啰嗦显然不是用来消耗多余的口水的。这里的curryWeight方法啰嗦的意义在于柯里化的复用。比方说，我还想知道平均每次钓货的重量，则：\n\n```\nvar averageWeight = 0;\nvar addWeight = curryWeight(function() {\n    var i=0; len = arguments.length;\n    for (i; i<len; i+=1) {\n        averageWeight += arguments[i]/len;\n    }\n});\n\naddWeight(2.3);\naddWeight(6.5);\naddWeight(1.2);\naddWeight(2.5);\naddWeight();    //  这里才计算\n\nconsole.log(averageWeight);    // 3.125\n```","source":"_posts/js/foundation/柯里化.md","raw":"---\ntitle: JS中的柯里化\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n## 柯里化概念\n\n柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。\n\n```\nvar currying = function(fn) {\n    // fn 指官员消化老婆的手段\n    var args = [].slice.call(arguments, 1);\n    // args 指的是那个合法老婆\n    return function() {\n        // 已经有的老婆和新搞定的老婆们合成一体，方便控制\n        var newArgs = args.concat([].slice.call(arguments));\n        // 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回\n        return fn.apply(null, newArgs);\n    };\n};\n\n// 下为官员如何搞定7个老婆的测试\n// 获得合法老婆\nvar getWife = currying(function() {\n    var allWife = [].slice.call(arguments);\n    // allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆\n    console.log(allWife.join(\";\"));\n}, \"合法老婆\");\n\n// 获得其他6个老婆\ngetWife(\"大老婆\",\"小老婆\",\"俏老婆\",\"刁蛮老婆\",\"乖老婆\",\"送上门老婆\");\n\n// 换一批老婆\ngetWife(\"超越韦小宝的老婆\");\n```\n\n```\nvar smallKenan = function(action) {\n    var bigKenan = function(doing) {\n        var result = \"\";\n        if (action === \"take drugs\") {\n            if (doing === \"bathWithGirlFriend\") {\n                result = \"尖叫，新一，你这个色狼，然后一巴掌，脸煮熟了~\";\n            } else if (doing === \"pointOutKiller\") {\n                result = \"新一，这个案子就交给你的，快点找出谁是凶手吧~\";\n            }\n        } else {\n            if (doing === \"bathWithGirlFriend\") {\n                result = \"来吧，柯南，一起洗澡吧~\";\n            } else if (doing === \"pointOutKiller\") {\n                result = \"小孩子家，滚一边去！\";\n            }\n        }\n        console.log(result);\n        return arguments.callee; // 等同于return bigKenan\n    };\n    return bigKenan;\n};\n\n// 小柯南吃药了，然后和毛利兰洗澡，凶案现场指证犯人；结果是……\nsmallKenan(\"take drugs\")(\"bathWithGirlFriend\")(\"pointOutKiller\");\n```\n“吃药”、“洗澡”、“指出凶手”就可以看成三个参数，其中，“吃药”确实是小柯南使用的，而后面的是“洗澡”、“指出凶手”虽然跟在smallKenan()后面，实际上是大柯南使用的。这个就是柯里化，参数部分使用。外部函数处理部分应用，剩下的由外部函数的返回函数处理。\n\n\n## 柯里化的作用\n\n### 参数复用(示例见上)\n\n### 提前返回\n```\nvar addEvent = function(element, type, fn, capture) {\n\tif(window.addEventListener) {\n\t\telement.addEventListener(type, function(e) {\n\t\t\tfn.call(element, e)\n\t\t}, capture)\n\t} else if(window.attachEvent) {\n\t\telement.attachEvent('on'+ type, function(e) {\n\t\t\tfn.call(element, e)\n\t\t})\n\t}\n}\n\n```\n上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，(eg. IE6/IE7)都会走一遍if...else if ...，其实只要一次判定就可以了，怎么做？–柯里化。改为下面这样子的代码：\n\n```\nvar addEvent = (function(){\n    if (window.addEventListener) {\n        return function(el, sType, fn, capture) {\n            el.addEventListener(sType, function(e) {\n                fn.call(el, e);\n            }, (capture));\n        };\n    } else if (window.attachEvent) {\n        return function(el, sType, fn, capture) {\n            el.attachEvent(\"on\" + sType, function(e) {\n                fn.call(el, e);\n            });\n        };\n    }\n})();\n\n```\n初始addEvent的执行其实值实现了部分的应用（只有一次的if...else if...判定），而剩余的参数应用都是其返回函数实现的，典型的柯里化。\n\n### 延迟计算\n\n```\n//常规写法\nvar fishWeight = 0;\nvar addWeight = function(weight) {\n    fishWeight += weight;\n};\n\naddWeight(2.3);\naddWeight(6.5);\naddWeight(1.2);\naddWeight(2.5);\n\nconsole.log(fishWeight);   // 12.5\n```\n\n### 柯里化的实现\n\n```\nvar curryweight = function(fn) {\n\tvar _fishWeight = []\n\treturn function() {\n\t\tif(arguments.length === 0) {\n\t\t\treturn fn.apply(null, _fishWeight)\n\t\t} else {\n\t\t\t_fishWeight = _fishWeight.concat([].slice.call(arguments))\n\t\t}\n\t}\n}\n\nvar _fishWeight = 0\nvar addweight = curryweight(function() {\n    var i=0; len = arguments.length;\n    for (i; i<len; i+=1) {\n    \tfishWeight += arguments[i];\n    }\n})\n```\n确实，柯里化的实现似乎啰嗦了点。老妈的啰嗦显然不是用来消耗多余的口水的。这里的curryWeight方法啰嗦的意义在于柯里化的复用。比方说，我还想知道平均每次钓货的重量，则：\n\n```\nvar averageWeight = 0;\nvar addWeight = curryWeight(function() {\n    var i=0; len = arguments.length;\n    for (i; i<len; i+=1) {\n        averageWeight += arguments[i]/len;\n    }\n});\n\naddWeight(2.3);\naddWeight(6.5);\naddWeight(1.2);\naddWeight(2.5);\naddWeight();    //  这里才计算\n\nconsole.log(averageWeight);    // 3.125\n```","slug":"js-foundation-柯里化","published":1,"date":"2017-04-23T11:09:24.000Z","updated":"2017-04-23T11:09:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chu004akzy6uieeo1ai","content":"<h2 id=\"柯里化概念\"><a href=\"#柯里化概念\" class=\"headerlink\" title=\"柯里化概念\"></a>柯里化概念</h2><p>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var currying = function(fn) &#123;</div><div class=\"line\">    // fn 指官员消化老婆的手段</div><div class=\"line\">    var args = [].slice.call(arguments, 1);</div><div class=\"line\">    // args 指的是那个合法老婆</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        // 已经有的老婆和新搞定的老婆们合成一体，方便控制</div><div class=\"line\">        var newArgs = args.concat([].slice.call(arguments));</div><div class=\"line\">        // 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回</div><div class=\"line\">        return fn.apply(null, newArgs);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 下为官员如何搞定7个老婆的测试</div><div class=\"line\">// 获得合法老婆</div><div class=\"line\">var getWife = currying(function() &#123;</div><div class=\"line\">    var allWife = [].slice.call(arguments);</div><div class=\"line\">    // allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆</div><div class=\"line\">    console.log(allWife.join(&quot;;&quot;));</div><div class=\"line\">&#125;, &quot;合法老婆&quot;);</div><div class=\"line\"></div><div class=\"line\">// 获得其他6个老婆</div><div class=\"line\">getWife(&quot;大老婆&quot;,&quot;小老婆&quot;,&quot;俏老婆&quot;,&quot;刁蛮老婆&quot;,&quot;乖老婆&quot;,&quot;送上门老婆&quot;);</div><div class=\"line\"></div><div class=\"line\">// 换一批老婆</div><div class=\"line\">getWife(&quot;超越韦小宝的老婆&quot;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">var smallKenan = function(action) &#123;</div><div class=\"line\">    var bigKenan = function(doing) &#123;</div><div class=\"line\">        var result = &quot;&quot;;</div><div class=\"line\">        if (action === &quot;take drugs&quot;) &#123;</div><div class=\"line\">            if (doing === &quot;bathWithGirlFriend&quot;) &#123;</div><div class=\"line\">                result = &quot;尖叫，新一，你这个色狼，然后一巴掌，脸煮熟了~&quot;;</div><div class=\"line\">            &#125; else if (doing === &quot;pointOutKiller&quot;) &#123;</div><div class=\"line\">                result = &quot;新一，这个案子就交给你的，快点找出谁是凶手吧~&quot;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (doing === &quot;bathWithGirlFriend&quot;) &#123;</div><div class=\"line\">                result = &quot;来吧，柯南，一起洗澡吧~&quot;;</div><div class=\"line\">            &#125; else if (doing === &quot;pointOutKiller&quot;) &#123;</div><div class=\"line\">                result = &quot;小孩子家，滚一边去！&quot;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        console.log(result);</div><div class=\"line\">        return arguments.callee; // 等同于return bigKenan</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return bigKenan;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 小柯南吃药了，然后和毛利兰洗澡，凶案现场指证犯人；结果是……</div><div class=\"line\">smallKenan(&quot;take drugs&quot;)(&quot;bathWithGirlFriend&quot;)(&quot;pointOutKiller&quot;);</div></pre></td></tr></table></figure>\n<p>“吃药”、“洗澡”、“指出凶手”就可以看成三个参数，其中，“吃药”确实是小柯南使用的，而后面的是“洗澡”、“指出凶手”虽然跟在smallKenan()后面，实际上是大柯南使用的。这个就是柯里化，参数部分使用。外部函数处理部分应用，剩下的由外部函数的返回函数处理。</p>\n<h2 id=\"柯里化的作用\"><a href=\"#柯里化的作用\" class=\"headerlink\" title=\"柯里化的作用\"></a>柯里化的作用</h2><h3 id=\"参数复用-示例见上\"><a href=\"#参数复用-示例见上\" class=\"headerlink\" title=\"参数复用(示例见上)\"></a>参数复用(示例见上)</h3><h3 id=\"提前返回\"><a href=\"#提前返回\" class=\"headerlink\" title=\"提前返回\"></a>提前返回</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = function(element, type, fn, capture) &#123;</div><div class=\"line\">\tif(window.addEventListener) &#123;</div><div class=\"line\">\t\telement.addEventListener(type, function(e) &#123;</div><div class=\"line\">\t\t\tfn.call(element, e)</div><div class=\"line\">\t\t&#125;, capture)</div><div class=\"line\">\t&#125; else if(window.attachEvent) &#123;</div><div class=\"line\">\t\telement.attachEvent(&apos;on&apos;+ type, function(e) &#123;</div><div class=\"line\">\t\t\tfn.call(element, e)</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，(eg. IE6/IE7)都会走一遍if…else if …，其实只要一次判定就可以了，怎么做？–柯里化。改为下面这样子的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = (function()&#123;</div><div class=\"line\">    if (window.addEventListener) &#123;</div><div class=\"line\">        return function(el, sType, fn, capture) &#123;</div><div class=\"line\">            el.addEventListener(sType, function(e) &#123;</div><div class=\"line\">                fn.call(el, e);</div><div class=\"line\">            &#125;, (capture));</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125; else if (window.attachEvent) &#123;</div><div class=\"line\">        return function(el, sType, fn, capture) &#123;</div><div class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</div><div class=\"line\">                fn.call(el, e);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>初始addEvent的执行其实值实现了部分的应用（只有一次的if…else if…判定），而剩余的参数应用都是其返回函数实现的，典型的柯里化。</p>\n<h3 id=\"延迟计算\"><a href=\"#延迟计算\" class=\"headerlink\" title=\"延迟计算\"></a>延迟计算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//常规写法</div><div class=\"line\">var fishWeight = 0;</div><div class=\"line\">var addWeight = function(weight) &#123;</div><div class=\"line\">    fishWeight += weight;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">addWeight(2.3);</div><div class=\"line\">addWeight(6.5);</div><div class=\"line\">addWeight(1.2);</div><div class=\"line\">addWeight(2.5);</div><div class=\"line\"></div><div class=\"line\">console.log(fishWeight);   // 12.5</div></pre></td></tr></table></figure>\n<h3 id=\"柯里化的实现\"><a href=\"#柯里化的实现\" class=\"headerlink\" title=\"柯里化的实现\"></a>柯里化的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var curryweight = function(fn) &#123;</div><div class=\"line\">\tvar _fishWeight = []</div><div class=\"line\">\treturn function() &#123;</div><div class=\"line\">\t\tif(arguments.length === 0) &#123;</div><div class=\"line\">\t\t\treturn fn.apply(null, _fishWeight)</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t_fishWeight = _fishWeight.concat([].slice.call(arguments))</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var _fishWeight = 0</div><div class=\"line\">var addweight = curryweight(function() &#123;</div><div class=\"line\">    var i=0; len = arguments.length;</div><div class=\"line\">    for (i; i&lt;len; i+=1) &#123;</div><div class=\"line\">    \tfishWeight += arguments[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>确实，柯里化的实现似乎啰嗦了点。老妈的啰嗦显然不是用来消耗多余的口水的。这里的curryWeight方法啰嗦的意义在于柯里化的复用。比方说，我还想知道平均每次钓货的重量，则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var averageWeight = 0;</div><div class=\"line\">var addWeight = curryWeight(function() &#123;</div><div class=\"line\">    var i=0; len = arguments.length;</div><div class=\"line\">    for (i; i&lt;len; i+=1) &#123;</div><div class=\"line\">        averageWeight += arguments[i]/len;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">addWeight(2.3);</div><div class=\"line\">addWeight(6.5);</div><div class=\"line\">addWeight(1.2);</div><div class=\"line\">addWeight(2.5);</div><div class=\"line\">addWeight();    //  这里才计算</div><div class=\"line\"></div><div class=\"line\">console.log(averageWeight);    // 3.125</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"柯里化概念\"><a href=\"#柯里化概念\" class=\"headerlink\" title=\"柯里化概念\"></a>柯里化概念</h2><p>柯里化（Currying），又称部分求值（Partial Evaluation），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">var currying = function(fn) &#123;</div><div class=\"line\">    // fn 指官员消化老婆的手段</div><div class=\"line\">    var args = [].slice.call(arguments, 1);</div><div class=\"line\">    // args 指的是那个合法老婆</div><div class=\"line\">    return function() &#123;</div><div class=\"line\">        // 已经有的老婆和新搞定的老婆们合成一体，方便控制</div><div class=\"line\">        var newArgs = args.concat([].slice.call(arguments));</div><div class=\"line\">        // 这些老婆们用 fn 这个手段消化利用，完成韦小宝前辈的壮举并返回</div><div class=\"line\">        return fn.apply(null, newArgs);</div><div class=\"line\">    &#125;;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 下为官员如何搞定7个老婆的测试</div><div class=\"line\">// 获得合法老婆</div><div class=\"line\">var getWife = currying(function() &#123;</div><div class=\"line\">    var allWife = [].slice.call(arguments);</div><div class=\"line\">    // allwife 就是所有的老婆的，包括暗渡陈仓进来的老婆</div><div class=\"line\">    console.log(allWife.join(&quot;;&quot;));</div><div class=\"line\">&#125;, &quot;合法老婆&quot;);</div><div class=\"line\"></div><div class=\"line\">// 获得其他6个老婆</div><div class=\"line\">getWife(&quot;大老婆&quot;,&quot;小老婆&quot;,&quot;俏老婆&quot;,&quot;刁蛮老婆&quot;,&quot;乖老婆&quot;,&quot;送上门老婆&quot;);</div><div class=\"line\"></div><div class=\"line\">// 换一批老婆</div><div class=\"line\">getWife(&quot;超越韦小宝的老婆&quot;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">var smallKenan = function(action) &#123;</div><div class=\"line\">    var bigKenan = function(doing) &#123;</div><div class=\"line\">        var result = &quot;&quot;;</div><div class=\"line\">        if (action === &quot;take drugs&quot;) &#123;</div><div class=\"line\">            if (doing === &quot;bathWithGirlFriend&quot;) &#123;</div><div class=\"line\">                result = &quot;尖叫，新一，你这个色狼，然后一巴掌，脸煮熟了~&quot;;</div><div class=\"line\">            &#125; else if (doing === &quot;pointOutKiller&quot;) &#123;</div><div class=\"line\">                result = &quot;新一，这个案子就交给你的，快点找出谁是凶手吧~&quot;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            if (doing === &quot;bathWithGirlFriend&quot;) &#123;</div><div class=\"line\">                result = &quot;来吧，柯南，一起洗澡吧~&quot;;</div><div class=\"line\">            &#125; else if (doing === &quot;pointOutKiller&quot;) &#123;</div><div class=\"line\">                result = &quot;小孩子家，滚一边去！&quot;;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        console.log(result);</div><div class=\"line\">        return arguments.callee; // 等同于return bigKenan</div><div class=\"line\">    &#125;;</div><div class=\"line\">    return bigKenan;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">// 小柯南吃药了，然后和毛利兰洗澡，凶案现场指证犯人；结果是……</div><div class=\"line\">smallKenan(&quot;take drugs&quot;)(&quot;bathWithGirlFriend&quot;)(&quot;pointOutKiller&quot;);</div></pre></td></tr></table></figure>\n<p>“吃药”、“洗澡”、“指出凶手”就可以看成三个参数，其中，“吃药”确实是小柯南使用的，而后面的是“洗澡”、“指出凶手”虽然跟在smallKenan()后面，实际上是大柯南使用的。这个就是柯里化，参数部分使用。外部函数处理部分应用，剩下的由外部函数的返回函数处理。</p>\n<h2 id=\"柯里化的作用\"><a href=\"#柯里化的作用\" class=\"headerlink\" title=\"柯里化的作用\"></a>柯里化的作用</h2><h3 id=\"参数复用-示例见上\"><a href=\"#参数复用-示例见上\" class=\"headerlink\" title=\"参数复用(示例见上)\"></a>参数复用(示例见上)</h3><h3 id=\"提前返回\"><a href=\"#提前返回\" class=\"headerlink\" title=\"提前返回\"></a>提前返回</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = function(element, type, fn, capture) &#123;</div><div class=\"line\">\tif(window.addEventListener) &#123;</div><div class=\"line\">\t\telement.addEventListener(type, function(e) &#123;</div><div class=\"line\">\t\t\tfn.call(element, e)</div><div class=\"line\">\t\t&#125;, capture)</div><div class=\"line\">\t&#125; else if(window.attachEvent) &#123;</div><div class=\"line\">\t\telement.attachEvent(&apos;on&apos;+ type, function(e) &#123;</div><div class=\"line\">\t\t\tfn.call(element, e)</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的方法有什么问题呢？很显然，我们每次使用addEvent为元素添加事件的时候，(eg. IE6/IE7)都会走一遍if…else if …，其实只要一次判定就可以了，怎么做？–柯里化。改为下面这样子的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var addEvent = (function()&#123;</div><div class=\"line\">    if (window.addEventListener) &#123;</div><div class=\"line\">        return function(el, sType, fn, capture) &#123;</div><div class=\"line\">            el.addEventListener(sType, function(e) &#123;</div><div class=\"line\">                fn.call(el, e);</div><div class=\"line\">            &#125;, (capture));</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125; else if (window.attachEvent) &#123;</div><div class=\"line\">        return function(el, sType, fn, capture) &#123;</div><div class=\"line\">            el.attachEvent(&quot;on&quot; + sType, function(e) &#123;</div><div class=\"line\">                fn.call(el, e);</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)();</div></pre></td></tr></table></figure>\n<p>初始addEvent的执行其实值实现了部分的应用（只有一次的if…else if…判定），而剩余的参数应用都是其返回函数实现的，典型的柯里化。</p>\n<h3 id=\"延迟计算\"><a href=\"#延迟计算\" class=\"headerlink\" title=\"延迟计算\"></a>延迟计算</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//常规写法</div><div class=\"line\">var fishWeight = 0;</div><div class=\"line\">var addWeight = function(weight) &#123;</div><div class=\"line\">    fishWeight += weight;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">addWeight(2.3);</div><div class=\"line\">addWeight(6.5);</div><div class=\"line\">addWeight(1.2);</div><div class=\"line\">addWeight(2.5);</div><div class=\"line\"></div><div class=\"line\">console.log(fishWeight);   // 12.5</div></pre></td></tr></table></figure>\n<h3 id=\"柯里化的实现\"><a href=\"#柯里化的实现\" class=\"headerlink\" title=\"柯里化的实现\"></a>柯里化的实现</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">var curryweight = function(fn) &#123;</div><div class=\"line\">\tvar _fishWeight = []</div><div class=\"line\">\treturn function() &#123;</div><div class=\"line\">\t\tif(arguments.length === 0) &#123;</div><div class=\"line\">\t\t\treturn fn.apply(null, _fishWeight)</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t_fishWeight = _fishWeight.concat([].slice.call(arguments))</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">var _fishWeight = 0</div><div class=\"line\">var addweight = curryweight(function() &#123;</div><div class=\"line\">    var i=0; len = arguments.length;</div><div class=\"line\">    for (i; i&lt;len; i+=1) &#123;</div><div class=\"line\">    \tfishWeight += arguments[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>确实，柯里化的实现似乎啰嗦了点。老妈的啰嗦显然不是用来消耗多余的口水的。这里的curryWeight方法啰嗦的意义在于柯里化的复用。比方说，我还想知道平均每次钓货的重量，则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">var averageWeight = 0;</div><div class=\"line\">var addWeight = curryWeight(function() &#123;</div><div class=\"line\">    var i=0; len = arguments.length;</div><div class=\"line\">    for (i; i&lt;len; i+=1) &#123;</div><div class=\"line\">        averageWeight += arguments[i]/len;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">addWeight(2.3);</div><div class=\"line\">addWeight(6.5);</div><div class=\"line\">addWeight(1.2);</div><div class=\"line\">addWeight(2.5);</div><div class=\"line\">addWeight();    //  这里才计算</div><div class=\"line\"></div><div class=\"line\">console.log(averageWeight);    // 3.125</div></pre></td></tr></table></figure>"},{"title":"浏览器内核(渲染引擎，js引擎)","type":"categories","_content":"\n浏览器内核分为渲染引擎和js引擎，由于js引擎越来越独立，内核就倾向于渲染引擎，渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具\n\n常见渲染引擎：\n\tgecko引擎之firefox\n\tIE使用Trident引擎\n\topera最早使用Presto引擎，后来弃用\n\tchrome\\safari\\opera使用webkit引擎\n\t13年chrome和opera开始使用Blink引擎\n\nJS引擎：\n\t老版本IE使用Jscript引擎\n\tE9之后使用Chakra引擎\n\tedge浏览器仍然使用Chakra引擎\n\tfirefox使用monkey系列引擎\n\tsafari使用的SquirrelFish系列引擎\n\tOpera使用Carakan引擎\n\tchrome使用V8引擎。nodeJs其实就是封装了V8引擎\n","source":"_posts/js/foundation/浏览器内核(渲染引擎，js引擎).md","raw":"---\ntitle: 浏览器内核(渲染引擎，js引擎)\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n浏览器内核分为渲染引擎和js引擎，由于js引擎越来越独立，内核就倾向于渲染引擎，渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具\n\n常见渲染引擎：\n\tgecko引擎之firefox\n\tIE使用Trident引擎\n\topera最早使用Presto引擎，后来弃用\n\tchrome\\safari\\opera使用webkit引擎\n\t13年chrome和opera开始使用Blink引擎\n\nJS引擎：\n\t老版本IE使用Jscript引擎\n\tE9之后使用Chakra引擎\n\tedge浏览器仍然使用Chakra引擎\n\tfirefox使用monkey系列引擎\n\tsafari使用的SquirrelFish系列引擎\n\tOpera使用Carakan引擎\n\tchrome使用V8引擎。nodeJs其实就是封装了V8引擎\n","slug":"js-foundation-浏览器内核-渲染引擎，js引擎","published":1,"date":"2017-04-23T11:09:31.000Z","updated":"2017-04-23T11:09:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chv004dkzy6l2wtjrak","content":"<p>浏览器内核分为渲染引擎和js引擎，由于js引擎越来越独立，内核就倾向于渲染引擎，渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具</p>\n<p>常见渲染引擎：<br>    gecko引擎之firefox<br>    IE使用Trident引擎<br>    opera最早使用Presto引擎，后来弃用<br>    chrome\\safari\\opera使用webkit引擎<br>    13年chrome和opera开始使用Blink引擎</p>\n<p>JS引擎：<br>    老版本IE使用Jscript引擎<br>    E9之后使用Chakra引擎<br>    edge浏览器仍然使用Chakra引擎<br>    firefox使用monkey系列引擎<br>    safari使用的SquirrelFish系列引擎<br>    Opera使用Carakan引擎<br>    chrome使用V8引擎。nodeJs其实就是封装了V8引擎</p>\n","site":{"data":{}},"excerpt":"","more":"<p>浏览器内核分为渲染引擎和js引擎，由于js引擎越来越独立，内核就倾向于渲染引擎，渲染引擎是一种对HTML文档进行解析并将其显示在页面上的工具</p>\n<p>常见渲染引擎：<br>    gecko引擎之firefox<br>    IE使用Trident引擎<br>    opera最早使用Presto引擎，后来弃用<br>    chrome\\safari\\opera使用webkit引擎<br>    13年chrome和opera开始使用Blink引擎</p>\n<p>JS引擎：<br>    老版本IE使用Jscript引擎<br>    E9之后使用Chakra引擎<br>    edge浏览器仍然使用Chakra引擎<br>    firefox使用monkey系列引擎<br>    safari使用的SquirrelFish系列引擎<br>    Opera使用Carakan引擎<br>    chrome使用V8引擎。nodeJs其实就是封装了V8引擎</p>\n"},{"title":"浅析深浅拷贝","type":"categories","_content":"\n### 浅拷贝众所周知ES6提供了Object.assign(),js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的$.extend(),今天看看大概是如何实现的呢\n\n```\n//shallow 不传代表深拷贝，传递结果为true的值代表浅拷贝\n\nfunction clone(Obj, shallow) {\n\tvar buf, dataType = Object.prototype.toString.call(Obj).slice(8, -1)\n\tif(dataType === 'Array') {\n\t\tbuf = [];\n\t\tvar i = Obj.length;\n\t\twhile(i--) {\n\t\t\tif(shallow) {\n\t\t\t\tbuf[i] = Obj[i];\n\t\t\t} else {\n\t\t\t\tbuf[i] = clone(Obj[i]);\n\t\t\t}\n\t\t}\n\t\treturn buf;\n\t} else if(dataType === 'Object'){\n\t\tbuf = {};\n\t\tfor(var k in Obj) {\n\t\t\tif(Obj.hasOwnProperty(k)) {\n\t\t\t\tif(shallow) {\n\t\t\t\t\tbuf[k] = Obj[k];\n\t\t\t\t} else {\n\t\t\t\t\tbuf[k] = clone(Obj[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf;\n\t}else{\n\t\treturn Obj;\n\t}\n}\n\n```","source":"_posts/js/foundation/浅析深浅拷贝.md","raw":"\n---\ntitle: 浅析深浅拷贝\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n### 浅拷贝众所周知ES6提供了Object.assign(),js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的$.extend(),今天看看大概是如何实现的呢\n\n```\n//shallow 不传代表深拷贝，传递结果为true的值代表浅拷贝\n\nfunction clone(Obj, shallow) {\n\tvar buf, dataType = Object.prototype.toString.call(Obj).slice(8, -1)\n\tif(dataType === 'Array') {\n\t\tbuf = [];\n\t\tvar i = Obj.length;\n\t\twhile(i--) {\n\t\t\tif(shallow) {\n\t\t\t\tbuf[i] = Obj[i];\n\t\t\t} else {\n\t\t\t\tbuf[i] = clone(Obj[i]);\n\t\t\t}\n\t\t}\n\t\treturn buf;\n\t} else if(dataType === 'Object'){\n\t\tbuf = {};\n\t\tfor(var k in Obj) {\n\t\t\tif(Obj.hasOwnProperty(k)) {\n\t\t\t\tif(shallow) {\n\t\t\t\t\tbuf[k] = Obj[k];\n\t\t\t\t} else {\n\t\t\t\t\tbuf[k] = clone(Obj[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn buf;\n\t}else{\n\t\treturn Obj;\n\t}\n}\n\n```","slug":"js-foundation-浅析深浅拷贝","published":1,"date":"2017-04-23T11:09:27.000Z","updated":"2017-04-23T11:09:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chw004fkzy6fxuw8r0v","content":"<h3 id=\"浅拷贝众所周知ES6提供了Object-assign-js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的-extend-今天看看大概是如何实现的呢\"><a href=\"#浅拷贝众所周知ES6提供了Object-assign-js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的-extend-今天看看大概是如何实现的呢\" class=\"headerlink\" title=\"浅拷贝众所周知ES6提供了Object.assign(),js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的$.extend(),今天看看大概是如何实现的呢\"></a>浅拷贝众所周知ES6提供了Object.assign(),js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的$.extend(),今天看看大概是如何实现的呢</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//shallow 不传代表深拷贝，传递结果为true的值代表浅拷贝</div><div class=\"line\"></div><div class=\"line\">function clone(Obj, shallow) &#123;</div><div class=\"line\">\tvar buf, dataType = Object.prototype.toString.call(Obj).slice(8, -1)</div><div class=\"line\">\tif(dataType === &apos;Array&apos;) &#123;</div><div class=\"line\">\t\tbuf = [];</div><div class=\"line\">\t\tvar i = Obj.length;</div><div class=\"line\">\t\twhile(i--) &#123;</div><div class=\"line\">\t\t\tif(shallow) &#123;</div><div class=\"line\">\t\t\t\tbuf[i] = Obj[i];</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tbuf[i] = clone(Obj[i]);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn buf;</div><div class=\"line\">\t&#125; else if(dataType === &apos;Object&apos;)&#123;</div><div class=\"line\">\t\tbuf = &#123;&#125;;</div><div class=\"line\">\t\tfor(var k in Obj) &#123;</div><div class=\"line\">\t\t\tif(Obj.hasOwnProperty(k)) &#123;</div><div class=\"line\">\t\t\t\tif(shallow) &#123;</div><div class=\"line\">\t\t\t\t\tbuf[k] = Obj[k];</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\tbuf[k] = clone(Obj[k]);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn buf;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\treturn Obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"浅拷贝众所周知ES6提供了Object-assign-js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的-extend-今天看看大概是如何实现的呢\"><a href=\"#浅拷贝众所周知ES6提供了Object-assign-js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的-extend-今天看看大概是如何实现的呢\" class=\"headerlink\" title=\"浅拷贝众所周知ES6提供了Object.assign(),js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的$.extend(),今天看看大概是如何实现的呢\"></a>浅拷贝众所周知ES6提供了Object.assign(),js序列化也可以成为拷贝的方式，另外JQ提供了一个深浅的都行的$.extend(),今天看看大概是如何实现的呢</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">//shallow 不传代表深拷贝，传递结果为true的值代表浅拷贝</div><div class=\"line\"></div><div class=\"line\">function clone(Obj, shallow) &#123;</div><div class=\"line\">\tvar buf, dataType = Object.prototype.toString.call(Obj).slice(8, -1)</div><div class=\"line\">\tif(dataType === &apos;Array&apos;) &#123;</div><div class=\"line\">\t\tbuf = [];</div><div class=\"line\">\t\tvar i = Obj.length;</div><div class=\"line\">\t\twhile(i--) &#123;</div><div class=\"line\">\t\t\tif(shallow) &#123;</div><div class=\"line\">\t\t\t\tbuf[i] = Obj[i];</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\tbuf[i] = clone(Obj[i]);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn buf;</div><div class=\"line\">\t&#125; else if(dataType === &apos;Object&apos;)&#123;</div><div class=\"line\">\t\tbuf = &#123;&#125;;</div><div class=\"line\">\t\tfor(var k in Obj) &#123;</div><div class=\"line\">\t\t\tif(Obj.hasOwnProperty(k)) &#123;</div><div class=\"line\">\t\t\t\tif(shallow) &#123;</div><div class=\"line\">\t\t\t\t\tbuf[k] = Obj[k];</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\tbuf[k] = clone(Obj[k]);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn buf;</div><div class=\"line\">\t&#125;else&#123;</div><div class=\"line\">\t\treturn Obj;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"浏览器的工作原理","type":"categories","_content":"\n## 浏览器的功能\n 将用户选择的web资源呈现出来，需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、img以及其他格式，用户用URI来指定所请求资源的位置\n\n## 浏览器的结构\n用户接口：\n包括地址栏、标签栏、书签、返回等\n浏览器引擎： 查询与操作渲染引擎的接口\n渲染引擎： 显示CSS格式化、HTML和图片\n网络：用于网络请求，如http\nUI后端： 绘制基础元件，如组合框与窗口。。\nJS解释器： 用于解析执行JS代码\n数据存储： 浏览器需要把数据存到硬盘上，如cookies\n\n\n## 渲染引擎\nfirefox的gecko\nchrome和safari的webkit\n\n### 基本流程： 渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成=\n- 解析html构建dom树\n- 构造render树（css树）\n- 布局render树（\n- 绘制render树（插入节点会引起重绘（颜色的改变等）和回流（布局））\n\n### 特点\n为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树，它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n\n## 减少重绘和回流的方法\n\n- 一次性改变样式\n- 操作DOM节点，尽量一次性添加\n- 不要在内存中多次操作节点，完成后添加到文档\n- 为图片指定大小，减少回流\n- 压缩html\n- 不要使用table布局，一个小的改动会造成整个table重新布局，而且table渲染要3倍于同等元素时间\n\n## 优化网页的办法\n\n### html\n- 使用新标签，提高浏览器的识别能力\n- 减少html标签嵌套深度\n- 为图片指定大小，减少回流\n- 压缩html\n\n### css\n- cssspirte\n- 模块化css\n- 嵌套层数减少，最右边的选择器使用优先级较高的选择器\n- 避免使用css表达式\n- 不要使用@import\n- 合并和压缩css代码\n\n\n### js\n- 为需要多次重排的元素的position设置为fixed或absolute\n- 对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示\n- 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量中\n\n\n\n\n\n\n","source":"_posts/js/foundation/浏览器的工作原理.md","raw":"---\ntitle: 浏览器的工作原理\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n## 浏览器的功能\n 将用户选择的web资源呈现出来，需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、img以及其他格式，用户用URI来指定所请求资源的位置\n\n## 浏览器的结构\n用户接口：\n包括地址栏、标签栏、书签、返回等\n浏览器引擎： 查询与操作渲染引擎的接口\n渲染引擎： 显示CSS格式化、HTML和图片\n网络：用于网络请求，如http\nUI后端： 绘制基础元件，如组合框与窗口。。\nJS解释器： 用于解析执行JS代码\n数据存储： 浏览器需要把数据存到硬盘上，如cookies\n\n\n## 渲染引擎\nfirefox的gecko\nchrome和safari的webkit\n\n### 基本流程： 渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成=\n- 解析html构建dom树\n- 构造render树（css树）\n- 布局render树（\n- 绘制render树（插入节点会引起重绘（颜色的改变等）和回流（布局））\n\n### 特点\n为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树，它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。\n\n## 减少重绘和回流的方法\n\n- 一次性改变样式\n- 操作DOM节点，尽量一次性添加\n- 不要在内存中多次操作节点，完成后添加到文档\n- 为图片指定大小，减少回流\n- 压缩html\n- 不要使用table布局，一个小的改动会造成整个table重新布局，而且table渲染要3倍于同等元素时间\n\n## 优化网页的办法\n\n### html\n- 使用新标签，提高浏览器的识别能力\n- 减少html标签嵌套深度\n- 为图片指定大小，减少回流\n- 压缩html\n\n### css\n- cssspirte\n- 模块化css\n- 嵌套层数减少，最右边的选择器使用优先级较高的选择器\n- 避免使用css表达式\n- 不要使用@import\n- 合并和压缩css代码\n\n\n### js\n- 为需要多次重排的元素的position设置为fixed或absolute\n- 对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示\n- 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量中\n\n\n\n\n\n\n","slug":"js-foundation-浏览器的工作原理","published":1,"date":"2017-04-23T11:09:37.000Z","updated":"2017-04-23T11:09:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chy004ikzy6txgbc06l","content":"<h2 id=\"浏览器的功能\"><a href=\"#浏览器的功能\" class=\"headerlink\" title=\"浏览器的功能\"></a>浏览器的功能</h2><p> 将用户选择的web资源呈现出来，需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、img以及其他格式，用户用URI来指定所请求资源的位置</p>\n<h2 id=\"浏览器的结构\"><a href=\"#浏览器的结构\" class=\"headerlink\" title=\"浏览器的结构\"></a>浏览器的结构</h2><p>用户接口：<br>包括地址栏、标签栏、书签、返回等<br>浏览器引擎： 查询与操作渲染引擎的接口<br>渲染引擎： 显示CSS格式化、HTML和图片<br>网络：用于网络请求，如http<br>UI后端： 绘制基础元件，如组合框与窗口。。<br>JS解释器： 用于解析执行JS代码<br>数据存储： 浏览器需要把数据存到硬盘上，如cookies</p>\n<h2 id=\"渲染引擎\"><a href=\"#渲染引擎\" class=\"headerlink\" title=\"渲染引擎\"></a>渲染引擎</h2><p>firefox的gecko<br>chrome和safari的webkit</p>\n<h3 id=\"基本流程：-渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成\"><a href=\"#基本流程：-渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成\" class=\"headerlink\" title=\"基本流程： 渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成=\"></a>基本流程： 渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成=</h3><ul>\n<li>解析html构建dom树</li>\n<li>构造render树（css树）</li>\n<li>布局render树（</li>\n<li>绘制render树（插入节点会引起重绘（颜色的改变等）和回流（布局））</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树，它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n<h2 id=\"减少重绘和回流的方法\"><a href=\"#减少重绘和回流的方法\" class=\"headerlink\" title=\"减少重绘和回流的方法\"></a>减少重绘和回流的方法</h2><ul>\n<li>一次性改变样式</li>\n<li>操作DOM节点，尽量一次性添加</li>\n<li>不要在内存中多次操作节点，完成后添加到文档</li>\n<li>为图片指定大小，减少回流</li>\n<li>压缩html</li>\n<li>不要使用table布局，一个小的改动会造成整个table重新布局，而且table渲染要3倍于同等元素时间</li>\n</ul>\n<h2 id=\"优化网页的办法\"><a href=\"#优化网页的办法\" class=\"headerlink\" title=\"优化网页的办法\"></a>优化网页的办法</h2><h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h3><ul>\n<li>使用新标签，提高浏览器的识别能力</li>\n<li>减少html标签嵌套深度</li>\n<li>为图片指定大小，减少回流</li>\n<li>压缩html</li>\n</ul>\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><ul>\n<li>cssspirte</li>\n<li>模块化css</li>\n<li>嵌套层数减少，最右边的选择器使用优先级较高的选择器</li>\n<li>避免使用css表达式</li>\n<li>不要使用@import</li>\n<li>合并和压缩css代码</li>\n</ul>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ul>\n<li>为需要多次重排的元素的position设置为fixed或absolute</li>\n<li>对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示</li>\n<li>在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量中</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器的功能\"><a href=\"#浏览器的功能\" class=\"headerlink\" title=\"浏览器的功能\"></a>浏览器的功能</h2><p> 将用户选择的web资源呈现出来，需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、img以及其他格式，用户用URI来指定所请求资源的位置</p>\n<h2 id=\"浏览器的结构\"><a href=\"#浏览器的结构\" class=\"headerlink\" title=\"浏览器的结构\"></a>浏览器的结构</h2><p>用户接口：<br>包括地址栏、标签栏、书签、返回等<br>浏览器引擎： 查询与操作渲染引擎的接口<br>渲染引擎： 显示CSS格式化、HTML和图片<br>网络：用于网络请求，如http<br>UI后端： 绘制基础元件，如组合框与窗口。。<br>JS解释器： 用于解析执行JS代码<br>数据存储： 浏览器需要把数据存到硬盘上，如cookies</p>\n<h2 id=\"渲染引擎\"><a href=\"#渲染引擎\" class=\"headerlink\" title=\"渲染引擎\"></a>渲染引擎</h2><p>firefox的gecko<br>chrome和safari的webkit</p>\n<h3 id=\"基本流程：-渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成\"><a href=\"#基本流程：-渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成\" class=\"headerlink\" title=\"基本流程： 渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成=\"></a>基本流程： 渲染引擎通过网络获取请求的文档的内容，通常以8k分块的方式完成=</h3><ul>\n<li>解析html构建dom树</li>\n<li>构造render树（css树）</li>\n<li>布局render树（</li>\n<li>绘制render树（插入节点会引起重绘（颜色的改变等）和回流（布局））</li>\n</ul>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树，它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>\n<h2 id=\"减少重绘和回流的方法\"><a href=\"#减少重绘和回流的方法\" class=\"headerlink\" title=\"减少重绘和回流的方法\"></a>减少重绘和回流的方法</h2><ul>\n<li>一次性改变样式</li>\n<li>操作DOM节点，尽量一次性添加</li>\n<li>不要在内存中多次操作节点，完成后添加到文档</li>\n<li>为图片指定大小，减少回流</li>\n<li>压缩html</li>\n<li>不要使用table布局，一个小的改动会造成整个table重新布局，而且table渲染要3倍于同等元素时间</li>\n</ul>\n<h2 id=\"优化网页的办法\"><a href=\"#优化网页的办法\" class=\"headerlink\" title=\"优化网页的办法\"></a>优化网页的办法</h2><h3 id=\"html\"><a href=\"#html\" class=\"headerlink\" title=\"html\"></a>html</h3><ul>\n<li>使用新标签，提高浏览器的识别能力</li>\n<li>减少html标签嵌套深度</li>\n<li>为图片指定大小，减少回流</li>\n<li>压缩html</li>\n</ul>\n<h3 id=\"css\"><a href=\"#css\" class=\"headerlink\" title=\"css\"></a>css</h3><ul>\n<li>cssspirte</li>\n<li>模块化css</li>\n<li>嵌套层数减少，最右边的选择器使用优先级较高的选择器</li>\n<li>避免使用css表达式</li>\n<li>不要使用@import</li>\n<li>合并和压缩css代码</li>\n</ul>\n<h3 id=\"js\"><a href=\"#js\" class=\"headerlink\" title=\"js\"></a>js</h3><ul>\n<li>为需要多次重排的元素的position设置为fixed或absolute</li>\n<li>对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示</li>\n<li>在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量中</li>\n</ul>\n"},{"title":"深入JS原型","type":"categories","_content":"\n### 链式关系：主要是这三条线\n\n```\nnew Person() =>    __proto__    => Person.prototype =>    constructor    => function Person() =>     __proto__      => Function.prototype =>    constructor    => function Function =>........null\n\nnew Person() =>    __proto__    => Person.prototype =>   __proto__   => Function.prototype\n\nfunction Function =>    prototype    => Function.prototype\n\n```\n### 总结\n>   1.所有对象都有[[prototype]]属性（__proto__)，通过这个属性可以关联到对象的原型prototype;\n\t2.所有函数对象都有prototype属性，会赋值给该函数创建对象的[[prototype]]属性\n\t3.所有原型对象都有constructor属性，指向该原型的构造函数\n\t4.函数对象和原型对象通过constructor和prototype相互关联\n\n\n### 原型继承的注意事项\n\n#### 一\n\n> Bar.prototype = Foo.prototype 并不会创建一个关联到Bar.prototype 的新对象，它只\n是**让Bar.prototype 直接引用Foo.prototype 对象**。因此当你执行类似Bar.prototype.\nmyLabel = ... 的赋值语句时会直接修改Foo.prototype 对象本身。显然这不是你想要的结\n果，否则你根本不需要Bar 对象，直接使用Foo 就可以了，这样代码也会更简单一些。\n\n> Bar.prototype = Foo.prototype **这个也将会导致两个对象共享相同的原型**\n简而言之，就是 new Bar() 不会创造出一个新的 Foo 实例，而是 重复使用它原型上的那个实例；\n因此，所有的 Bar 实例都会共享相同的 value 属性。\n3.思考： 为什么不能 Bar.prototype = Foo，因为这不会执行 Foo 的原型，而是指向函数 Foo。 \n因此原型链将会回溯到 Function.prototype 而不是 Foo.prototype，因此 method 将不会在 Bar 的原型链上\n\n#### 二\n\n> Bar.prototype = new Foo() 的确会创建一个关联到Bar.prototype 的新对象。但是它使用\n了Foo(..) 的“构造函数调用”，**如果函数Foo 有一些副作用（比如写日志、修改状态、注\n册到其他对象、给this 添加数据属性，等等）的话，就会影响到Bar() 的“后代”**，后果\n不堪设想。\n\n#### 三\n\n> 要创建一个合适的关联对象，我们必须使用Object.create(..) 而不是使用具有副\n作用的Foo(..)。这样做唯一的缺点就是**需要创建一个新对象然后把旧对象抛弃掉，不能\n直接修改已有的默认对象**。\n\n\n### 原型继承的解决方案\n\n>  就是通过一个标准且可靠的方法来修改对象的[[Prototype]] 关联就好了\n\t1.设置.\\__proto\\__ 属性来实现，but不标准，不能兼容所有浏览器\n\t2.ES6 提供的 Object.setPrototypeOf( Bar.prototype, Foo.prototype )，标准并且可靠\n\t3.利用Object.create(Foo.prototype)\n\n```\nObject.prototype.create = function (o) { \n\tfunction F(){}\n \tF.prototype = o;\n\treturn new F();\n}\n\n```\n\n\n### 属性查找\n\n> 属性查找时都会查找 [[Prototype]] 链，直到找到属性或者\n查找完整条原型链,找不到，返回undefined\n\n### 属性设置\n\n> 假如 myObject.foo = \"bar\";\n\n\n1. 如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。\n2. 属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层, myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性\n3.foo 存在于原型链上层\n> 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性(参见第3章)并且没 有被标记为只读(writable:false)，那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性\n如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable:false)，那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。\n如果在[[Prototype]]链上层存在foo并且它是一个setter(参见第3章)，那就一定会 调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这 个 setter。\n\n\n### 一些想关的原型方法 \n```\n1. b.isPrototypeOf( c );  // 非常简单:b 是否出现在 c 的 [[Prototype]] 链中\n2. Object.getPrototypeOf( a ) === Foo.prototype; // true\n3. a.__proto__  === Foo.prototype; // true  绝大多数(不是所有!)浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性\n```\n>\t和我们之前说过的 .constructor 一样，.__proto__ 实际上并不存在于你正在使用的对象中 (本例中是 a)。实际上，它和其他的常用函数(.toString()、.isPrototypeOf(..)，等等),\n一样，存在于内置的 Object.prototype 中\n\n**.__proto__ 的实现大致上是这样的:**\n\n```\nObject.defineProperty( Object.prototype, \"__proto__\", { \n\tget: function() {\n\t\treturn Object.getPrototypeOf( this ); \n\t},\n\tset: function(o) {\n\t\t// ES6 中的 setPrototypeOf(..) \n\t\tObject.setPrototypeOf( this, o ); \n\t\treturn o;\n\t} \n});\n\n//因此，访问(获取值)a.__proto__ 时，实际上是调用了 a.__proto__()(调用 getter 函 数)。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a，所以和 Object.getPrototypeOf( a ) 结果相同。\n```\n\n### instanceof 和 isPrototypeof的区别\n```\na.isPrototypeof(new B()) 测试一个a是否存在于B的原型链上。\n\na instanceof B  对象a在其的原型链中是否存在一个构造函数的prototype属性\n```\n\n\n\t\n\n\n","source":"_posts/js/foundation/深入JS原型.md","raw":"---\ntitle: 深入JS原型\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n### 链式关系：主要是这三条线\n\n```\nnew Person() =>    __proto__    => Person.prototype =>    constructor    => function Person() =>     __proto__      => Function.prototype =>    constructor    => function Function =>........null\n\nnew Person() =>    __proto__    => Person.prototype =>   __proto__   => Function.prototype\n\nfunction Function =>    prototype    => Function.prototype\n\n```\n### 总结\n>   1.所有对象都有[[prototype]]属性（__proto__)，通过这个属性可以关联到对象的原型prototype;\n\t2.所有函数对象都有prototype属性，会赋值给该函数创建对象的[[prototype]]属性\n\t3.所有原型对象都有constructor属性，指向该原型的构造函数\n\t4.函数对象和原型对象通过constructor和prototype相互关联\n\n\n### 原型继承的注意事项\n\n#### 一\n\n> Bar.prototype = Foo.prototype 并不会创建一个关联到Bar.prototype 的新对象，它只\n是**让Bar.prototype 直接引用Foo.prototype 对象**。因此当你执行类似Bar.prototype.\nmyLabel = ... 的赋值语句时会直接修改Foo.prototype 对象本身。显然这不是你想要的结\n果，否则你根本不需要Bar 对象，直接使用Foo 就可以了，这样代码也会更简单一些。\n\n> Bar.prototype = Foo.prototype **这个也将会导致两个对象共享相同的原型**\n简而言之，就是 new Bar() 不会创造出一个新的 Foo 实例，而是 重复使用它原型上的那个实例；\n因此，所有的 Bar 实例都会共享相同的 value 属性。\n3.思考： 为什么不能 Bar.prototype = Foo，因为这不会执行 Foo 的原型，而是指向函数 Foo。 \n因此原型链将会回溯到 Function.prototype 而不是 Foo.prototype，因此 method 将不会在 Bar 的原型链上\n\n#### 二\n\n> Bar.prototype = new Foo() 的确会创建一个关联到Bar.prototype 的新对象。但是它使用\n了Foo(..) 的“构造函数调用”，**如果函数Foo 有一些副作用（比如写日志、修改状态、注\n册到其他对象、给this 添加数据属性，等等）的话，就会影响到Bar() 的“后代”**，后果\n不堪设想。\n\n#### 三\n\n> 要创建一个合适的关联对象，我们必须使用Object.create(..) 而不是使用具有副\n作用的Foo(..)。这样做唯一的缺点就是**需要创建一个新对象然后把旧对象抛弃掉，不能\n直接修改已有的默认对象**。\n\n\n### 原型继承的解决方案\n\n>  就是通过一个标准且可靠的方法来修改对象的[[Prototype]] 关联就好了\n\t1.设置.\\__proto\\__ 属性来实现，but不标准，不能兼容所有浏览器\n\t2.ES6 提供的 Object.setPrototypeOf( Bar.prototype, Foo.prototype )，标准并且可靠\n\t3.利用Object.create(Foo.prototype)\n\n```\nObject.prototype.create = function (o) { \n\tfunction F(){}\n \tF.prototype = o;\n\treturn new F();\n}\n\n```\n\n\n### 属性查找\n\n> 属性查找时都会查找 [[Prototype]] 链，直到找到属性或者\n查找完整条原型链,找不到，返回undefined\n\n### 属性设置\n\n> 假如 myObject.foo = \"bar\";\n\n\n1. 如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。\n2. 属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层, myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性\n3.foo 存在于原型链上层\n> 如果在[[Prototype]]链上层存在名为foo的普通数据访问属性(参见第3章)并且没 有被标记为只读(writable:false)，那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性\n如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable:false)，那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。\n如果在[[Prototype]]链上层存在foo并且它是一个setter(参见第3章)，那就一定会 调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这 个 setter。\n\n\n### 一些想关的原型方法 \n```\n1. b.isPrototypeOf( c );  // 非常简单:b 是否出现在 c 的 [[Prototype]] 链中\n2. Object.getPrototypeOf( a ) === Foo.prototype; // true\n3. a.__proto__  === Foo.prototype; // true  绝大多数(不是所有!)浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性\n```\n>\t和我们之前说过的 .constructor 一样，.__proto__ 实际上并不存在于你正在使用的对象中 (本例中是 a)。实际上，它和其他的常用函数(.toString()、.isPrototypeOf(..)，等等),\n一样，存在于内置的 Object.prototype 中\n\n**.__proto__ 的实现大致上是这样的:**\n\n```\nObject.defineProperty( Object.prototype, \"__proto__\", { \n\tget: function() {\n\t\treturn Object.getPrototypeOf( this ); \n\t},\n\tset: function(o) {\n\t\t// ES6 中的 setPrototypeOf(..) \n\t\tObject.setPrototypeOf( this, o ); \n\t\treturn o;\n\t} \n});\n\n//因此，访问(获取值)a.__proto__ 时，实际上是调用了 a.__proto__()(调用 getter 函 数)。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a，所以和 Object.getPrototypeOf( a ) 结果相同。\n```\n\n### instanceof 和 isPrototypeof的区别\n```\na.isPrototypeof(new B()) 测试一个a是否存在于B的原型链上。\n\na instanceof B  对象a在其的原型链中是否存在一个构造函数的prototype属性\n```\n\n\n\t\n\n\n","slug":"js-foundation-深入JS原型","published":1,"date":"2017-04-23T11:09:43.000Z","updated":"2017-04-23T11:09:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11chz004kkzy69vawud9w","content":"<h3 id=\"链式关系：主要是这三条线\"><a href=\"#链式关系：主要是这三条线\" class=\"headerlink\" title=\"链式关系：主要是这三条线\"></a>链式关系：主要是这三条线</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Person() =&gt;    __proto__    =&gt; Person.prototype =&gt;    constructor    =&gt; function Person() =&gt;     __proto__      =&gt; Function.prototype =&gt;    constructor    =&gt; function Function =&gt;........null</div><div class=\"line\"></div><div class=\"line\">new Person() =&gt;    __proto__    =&gt; Person.prototype =&gt;   __proto__   =&gt; Function.prototype</div><div class=\"line\"></div><div class=\"line\">function Function =&gt;    prototype    =&gt; Function.prototype</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>  1.所有对象都有[[prototype]]属性（<strong>proto</strong>)，通过这个属性可以关联到对象的原型prototype;<br>    2.所有函数对象都有prototype属性，会赋值给该函数创建对象的[[prototype]]属性<br>    3.所有原型对象都有constructor属性，指向该原型的构造函数<br>    4.函数对象和原型对象通过constructor和prototype相互关联</p>\n</blockquote>\n<h3 id=\"原型继承的注意事项\"><a href=\"#原型继承的注意事项\" class=\"headerlink\" title=\"原型继承的注意事项\"></a>原型继承的注意事项</h3><h4 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h4><blockquote>\n<p>Bar.prototype = Foo.prototype 并不会创建一个关联到Bar.prototype 的新对象，它只<br>是<strong>让Bar.prototype 直接引用Foo.prototype 对象</strong>。因此当你执行类似Bar.prototype.<br>myLabel = … 的赋值语句时会直接修改Foo.prototype 对象本身。显然这不是你想要的结<br>果，否则你根本不需要Bar 对象，直接使用Foo 就可以了，这样代码也会更简单一些。</p>\n<p>Bar.prototype = Foo.prototype <strong>这个也将会导致两个对象共享相同的原型</strong><br>简而言之，就是 new Bar() 不会创造出一个新的 Foo 实例，而是 重复使用它原型上的那个实例；<br>因此，所有的 Bar 实例都会共享相同的 value 属性。<br>3.思考： 为什么不能 Bar.prototype = Foo，因为这不会执行 Foo 的原型，而是指向函数 Foo。<br>因此原型链将会回溯到 Function.prototype 而不是 Foo.prototype，因此 method 将不会在 Bar 的原型链上</p>\n</blockquote>\n<h4 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h4><blockquote>\n<p>Bar.prototype = new Foo() 的确会创建一个关联到Bar.prototype 的新对象。但是它使用<br>了Foo(..) 的“构造函数调用”，<strong>如果函数Foo 有一些副作用（比如写日志、修改状态、注<br>册到其他对象、给this 添加数据属性，等等）的话，就会影响到Bar() 的“后代”</strong>，后果<br>不堪设想。</p>\n</blockquote>\n<h4 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h4><blockquote>\n<p>要创建一个合适的关联对象，我们必须使用Object.create(..) 而不是使用具有副<br>作用的Foo(..)。这样做唯一的缺点就是<strong>需要创建一个新对象然后把旧对象抛弃掉，不能<br>直接修改已有的默认对象</strong>。</p>\n</blockquote>\n<h3 id=\"原型继承的解决方案\"><a href=\"#原型继承的解决方案\" class=\"headerlink\" title=\"原型继承的解决方案\"></a>原型继承的解决方案</h3><blockquote>\n<p> 就是通过一个标准且可靠的方法来修改对象的[[Prototype]] 关联就好了<br>    1.设置.__proto__ 属性来实现，but不标准，不能兼容所有浏览器<br>    2.ES6 提供的 Object.setPrototypeOf( Bar.prototype, Foo.prototype )，标准并且可靠<br>    3.利用Object.create(Foo.prototype)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.prototype.create = function (o) &#123; </div><div class=\"line\">\tfunction F()&#123;&#125;</div><div class=\"line\"> \tF.prototype = o;</div><div class=\"line\">\treturn new F();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h3><blockquote>\n<p>属性查找时都会查找 [[Prototype]] 链，直到找到属性或者<br>查找完整条原型链,找不到，返回undefined</p>\n</blockquote>\n<h3 id=\"属性设置\"><a href=\"#属性设置\" class=\"headerlink\" title=\"属性设置\"></a>属性设置</h3><blockquote>\n<p>假如 myObject.foo = “bar”;</p>\n</blockquote>\n<ol>\n<li>如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。</li>\n<li>属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层, myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性<br>3.foo 存在于原型链上层<blockquote>\n<p>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性(参见第3章)并且没 有被标记为只读(writable:false)，那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性<br>如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable:false)，那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。<br>如果在[[Prototype]]链上层存在foo并且它是一个setter(参见第3章)，那就一定会 调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这 个 setter。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"一些想关的原型方法\"><a href=\"#一些想关的原型方法\" class=\"headerlink\" title=\"一些想关的原型方法\"></a>一些想关的原型方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. b.isPrototypeOf( c );  // 非常简单:b 是否出现在 c 的 [[Prototype]] 链中</div><div class=\"line\">2. Object.getPrototypeOf( a ) === Foo.prototype; // true</div><div class=\"line\">3. a.__proto__  === Foo.prototype; // true  绝大多数(不是所有!)浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性</div></pre></td></tr></table></figure>\n<blockquote>\n<p>   和我们之前说过的 .constructor 一样，.<strong>proto</strong> 实际上并不存在于你正在使用的对象中 (本例中是 a)。实际上，它和其他的常用函数(.toString()、.isPrototypeOf(..)，等等),<br>一样，存在于内置的 Object.prototype 中</p>\n</blockquote>\n<p><strong>.<strong>proto</strong> 的实现大致上是这样的:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.defineProperty( Object.prototype, &quot;__proto__&quot;, &#123; </div><div class=\"line\">\tget: function() &#123;</div><div class=\"line\">\t\treturn Object.getPrototypeOf( this ); </div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tset: function(o) &#123;</div><div class=\"line\">\t\t// ES6 中的 setPrototypeOf(..) </div><div class=\"line\">\t\tObject.setPrototypeOf( this, o ); </div><div class=\"line\">\t\treturn o;</div><div class=\"line\">\t&#125; </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//因此，访问(获取值)a.__proto__ 时，实际上是调用了 a.__proto__()(调用 getter 函 数)。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a，所以和 Object.getPrototypeOf( a ) 结果相同。</div></pre></td></tr></table></figure>\n<h3 id=\"instanceof-和-isPrototypeof的区别\"><a href=\"#instanceof-和-isPrototypeof的区别\" class=\"headerlink\" title=\"instanceof 和 isPrototypeof的区别\"></a>instanceof 和 isPrototypeof的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a.isPrototypeof(new B()) 测试一个a是否存在于B的原型链上。</div><div class=\"line\"></div><div class=\"line\">a instanceof B  对象a在其的原型链中是否存在一个构造函数的prototype属性</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"链式关系：主要是这三条线\"><a href=\"#链式关系：主要是这三条线\" class=\"headerlink\" title=\"链式关系：主要是这三条线\"></a>链式关系：主要是这三条线</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">new Person() =&gt;    __proto__    =&gt; Person.prototype =&gt;    constructor    =&gt; function Person() =&gt;     __proto__      =&gt; Function.prototype =&gt;    constructor    =&gt; function Function =&gt;........null</div><div class=\"line\"></div><div class=\"line\">new Person() =&gt;    __proto__    =&gt; Person.prototype =&gt;   __proto__   =&gt; Function.prototype</div><div class=\"line\"></div><div class=\"line\">function Function =&gt;    prototype    =&gt; Function.prototype</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>  1.所有对象都有[[prototype]]属性（<strong>proto</strong>)，通过这个属性可以关联到对象的原型prototype;<br>    2.所有函数对象都有prototype属性，会赋值给该函数创建对象的[[prototype]]属性<br>    3.所有原型对象都有constructor属性，指向该原型的构造函数<br>    4.函数对象和原型对象通过constructor和prototype相互关联</p>\n</blockquote>\n<h3 id=\"原型继承的注意事项\"><a href=\"#原型继承的注意事项\" class=\"headerlink\" title=\"原型继承的注意事项\"></a>原型继承的注意事项</h3><h4 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h4><blockquote>\n<p>Bar.prototype = Foo.prototype 并不会创建一个关联到Bar.prototype 的新对象，它只<br>是<strong>让Bar.prototype 直接引用Foo.prototype 对象</strong>。因此当你执行类似Bar.prototype.<br>myLabel = … 的赋值语句时会直接修改Foo.prototype 对象本身。显然这不是你想要的结<br>果，否则你根本不需要Bar 对象，直接使用Foo 就可以了，这样代码也会更简单一些。</p>\n<p>Bar.prototype = Foo.prototype <strong>这个也将会导致两个对象共享相同的原型</strong><br>简而言之，就是 new Bar() 不会创造出一个新的 Foo 实例，而是 重复使用它原型上的那个实例；<br>因此，所有的 Bar 实例都会共享相同的 value 属性。<br>3.思考： 为什么不能 Bar.prototype = Foo，因为这不会执行 Foo 的原型，而是指向函数 Foo。<br>因此原型链将会回溯到 Function.prototype 而不是 Foo.prototype，因此 method 将不会在 Bar 的原型链上</p>\n</blockquote>\n<h4 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h4><blockquote>\n<p>Bar.prototype = new Foo() 的确会创建一个关联到Bar.prototype 的新对象。但是它使用<br>了Foo(..) 的“构造函数调用”，<strong>如果函数Foo 有一些副作用（比如写日志、修改状态、注<br>册到其他对象、给this 添加数据属性，等等）的话，就会影响到Bar() 的“后代”</strong>，后果<br>不堪设想。</p>\n</blockquote>\n<h4 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h4><blockquote>\n<p>要创建一个合适的关联对象，我们必须使用Object.create(..) 而不是使用具有副<br>作用的Foo(..)。这样做唯一的缺点就是<strong>需要创建一个新对象然后把旧对象抛弃掉，不能<br>直接修改已有的默认对象</strong>。</p>\n</blockquote>\n<h3 id=\"原型继承的解决方案\"><a href=\"#原型继承的解决方案\" class=\"headerlink\" title=\"原型继承的解决方案\"></a>原型继承的解决方案</h3><blockquote>\n<p> 就是通过一个标准且可靠的方法来修改对象的[[Prototype]] 关联就好了<br>    1.设置.__proto__ 属性来实现，but不标准，不能兼容所有浏览器<br>    2.ES6 提供的 Object.setPrototypeOf( Bar.prototype, Foo.prototype )，标准并且可靠<br>    3.利用Object.create(Foo.prototype)</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.prototype.create = function (o) &#123; </div><div class=\"line\">\tfunction F()&#123;&#125;</div><div class=\"line\"> \tF.prototype = o;</div><div class=\"line\">\treturn new F();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h3><blockquote>\n<p>属性查找时都会查找 [[Prototype]] 链，直到找到属性或者<br>查找完整条原型链,找不到，返回undefined</p>\n</blockquote>\n<h3 id=\"属性设置\"><a href=\"#属性设置\" class=\"headerlink\" title=\"属性设置\"></a>属性设置</h3><blockquote>\n<p>假如 myObject.foo = “bar”;</p>\n</blockquote>\n<ol>\n<li>如果原型链上找不到 foo，foo 就会被直接添加到 myObject 上。</li>\n<li>属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层, myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性，因为 myObject.foo 总是会选择原型链中最底层的 foo 属性<br>3.foo 存在于原型链上层<blockquote>\n<p>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性(参见第3章)并且没 有被标记为只读(writable:false)，那就会直接在 myObject 中添加一个名为 foo 的新 属性，它是屏蔽属性<br>如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable:false)，那么 无法修改已有属性或者在 myObject 上创建屏蔽属性。如果运行在严格模式下，代码会 抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。<br>如果在[[Prototype]]链上层存在foo并且它是一个setter(参见第3章)，那就一定会 调用这个 setter。foo 不会被添加到(或者说屏蔽于)myObject，也不会重新定义 foo 这 个 setter。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"一些想关的原型方法\"><a href=\"#一些想关的原型方法\" class=\"headerlink\" title=\"一些想关的原型方法\"></a>一些想关的原型方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. b.isPrototypeOf( c );  // 非常简单:b 是否出现在 c 的 [[Prototype]] 链中</div><div class=\"line\">2. Object.getPrototypeOf( a ) === Foo.prototype; // true</div><div class=\"line\">3. a.__proto__  === Foo.prototype; // true  绝大多数(不是所有!)浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性</div></pre></td></tr></table></figure>\n<blockquote>\n<p>   和我们之前说过的 .constructor 一样，.<strong>proto</strong> 实际上并不存在于你正在使用的对象中 (本例中是 a)。实际上，它和其他的常用函数(.toString()、.isPrototypeOf(..)，等等),<br>一样，存在于内置的 Object.prototype 中</p>\n</blockquote>\n<p><strong>.<strong>proto</strong> 的实现大致上是这样的:</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Object.defineProperty( Object.prototype, &quot;__proto__&quot;, &#123; </div><div class=\"line\">\tget: function() &#123;</div><div class=\"line\">\t\treturn Object.getPrototypeOf( this ); </div><div class=\"line\">\t&#125;,</div><div class=\"line\">\tset: function(o) &#123;</div><div class=\"line\">\t\t// ES6 中的 setPrototypeOf(..) </div><div class=\"line\">\t\tObject.setPrototypeOf( this, o ); </div><div class=\"line\">\t\treturn o;</div><div class=\"line\">\t&#125; </div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//因此，访问(获取值)a.__proto__ 时，实际上是调用了 a.__proto__()(调用 getter 函 数)。虽然 getter 函数存在于 Object.prototype 对象中，但是它的 this 指向对象 a，所以和 Object.getPrototypeOf( a ) 结果相同。</div></pre></td></tr></table></figure>\n<h3 id=\"instanceof-和-isPrototypeof的区别\"><a href=\"#instanceof-和-isPrototypeof的区别\" class=\"headerlink\" title=\"instanceof 和 isPrototypeof的区别\"></a>instanceof 和 isPrototypeof的区别</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">a.isPrototypeof(new B()) 测试一个a是否存在于B的原型链上。</div><div class=\"line\"></div><div class=\"line\">a instanceof B  对象a在其的原型链中是否存在一个构造函数的prototype属性</div></pre></td></tr></table></figure>\n"},{"title":"深入理解数组去重","type":"categories","_content":"\n### @首先确定是否需要全等于，还是等于\n### ES5 解决方案\n  #### 1.双重遍历\n  ```\n  function unque(arr) {\n      var newArr = [];\n      var len =arr.length;\n      var onOff;\n      for(var i=0; i<len; i++) {\n          onOff = false;\n          for(var j=i+1; j<len; j++ ){\n            if(arr[i] === arr[j]) {//这里用的是全等，所以如果有多个[],结果也会存在多个[]\n                onOff = true;\n                break;\n            }\n          }\n          if(!onOff) {//如果当前元素之后不存在相同元素\n              newArr.push(arr[i])\n          }\n      }\n      return newArr;\n      ==缺点==：导致NaN重复\n  }\n  优化：\n    function unique(arr) {\n        var newArr = [];\n        var len = arr.length;\n        for(var i=0; i<len; i++) {\n            for(var j=i+1; j<len; j++) {\n                if(arr[i] === arr[j])\n                j = ++i;\n            }\n            //没有相同的元素就添加\n            newArr.push(arr[i])\n        }\n        return newArr;\n    }\n    ==缺点==：导致NaN重复\n  ```\n  #### 2.高阶函数去重\n  ```\n  function unique(arr) {\n    //优点：不用再申明一个变量来保存\n      arr.filter(function(val, index){\n            //如果当前索引不是第一个索引\n            \n          return arr.indexOf(val) === index;\n          //===不能处理NaN的相等性判断。\n      })\n  }\n  ```\n  #### 3.对象key值去重\n \n  ```\nfunction unique(arr) {\n   var newArr = [];\n   var tmp = {}\n   var key;\n   var len = arr.length;\n   for(var item in arr) {\n      key = typeof arr[item] + JSON.stringify(arr[item]);//\t如果没有这句=>字符串和数字无法区分，对象、数组、正则表达式被去重\n      console.log(key)\n       if(!tmp[key]) {\n           tmp[key] = true;\n           newArr.push(arr[item])\n       }\n   }\n   return newArr;\n   //对象、数组被去重，正则表达式被消失\n}\n   ```\n   ### 综上所述，影响数组去重的因素：\n    1.=== \n    2.indexOf  不能判断NaN\n    3.对象key属性存在 字符串和数字隐式转换，对象变成属性时为[object object]，特殊属性__proto__,不能重写\n\n### ES6解决方案\n\n#### 1.includes()\n```\nfunction unique(arr, newArr=[]) {\n    arr.forEach(function(item) {\n        if(!newArr.includes(item))\n        newArr.push(item)\n    })\n    return newArr\n}\n```\n#### 2.Map数据类型\n```\nfunction unique(arr, tmp=new Map(), newArr=[], len=arr.length) {\n    for(let i=0; i<len; i++) {\n        if(!tmp.get(arr[i]) {\n            tmp.set(arr[i],true)\n            newArr.push(arr[i])\n        }\n    }\n}\n```\n#### 3.Set数据类型\n```\nfunction unique(arr) {\n    arr = new Set(arr)//Set原型上带有一个迭代器的方法，所以可以用Array.from\n    return Array.from(arr)\n}\n  \n```","source":"_posts/js/foundation/深入理解数组去重.md","raw":"\n---\ntitle: 深入理解数组去重\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n### @首先确定是否需要全等于，还是等于\n### ES5 解决方案\n  #### 1.双重遍历\n  ```\n  function unque(arr) {\n      var newArr = [];\n      var len =arr.length;\n      var onOff;\n      for(var i=0; i<len; i++) {\n          onOff = false;\n          for(var j=i+1; j<len; j++ ){\n            if(arr[i] === arr[j]) {//这里用的是全等，所以如果有多个[],结果也会存在多个[]\n                onOff = true;\n                break;\n            }\n          }\n          if(!onOff) {//如果当前元素之后不存在相同元素\n              newArr.push(arr[i])\n          }\n      }\n      return newArr;\n      ==缺点==：导致NaN重复\n  }\n  优化：\n    function unique(arr) {\n        var newArr = [];\n        var len = arr.length;\n        for(var i=0; i<len; i++) {\n            for(var j=i+1; j<len; j++) {\n                if(arr[i] === arr[j])\n                j = ++i;\n            }\n            //没有相同的元素就添加\n            newArr.push(arr[i])\n        }\n        return newArr;\n    }\n    ==缺点==：导致NaN重复\n  ```\n  #### 2.高阶函数去重\n  ```\n  function unique(arr) {\n    //优点：不用再申明一个变量来保存\n      arr.filter(function(val, index){\n            //如果当前索引不是第一个索引\n            \n          return arr.indexOf(val) === index;\n          //===不能处理NaN的相等性判断。\n      })\n  }\n  ```\n  #### 3.对象key值去重\n \n  ```\nfunction unique(arr) {\n   var newArr = [];\n   var tmp = {}\n   var key;\n   var len = arr.length;\n   for(var item in arr) {\n      key = typeof arr[item] + JSON.stringify(arr[item]);//\t如果没有这句=>字符串和数字无法区分，对象、数组、正则表达式被去重\n      console.log(key)\n       if(!tmp[key]) {\n           tmp[key] = true;\n           newArr.push(arr[item])\n       }\n   }\n   return newArr;\n   //对象、数组被去重，正则表达式被消失\n}\n   ```\n   ### 综上所述，影响数组去重的因素：\n    1.=== \n    2.indexOf  不能判断NaN\n    3.对象key属性存在 字符串和数字隐式转换，对象变成属性时为[object object]，特殊属性__proto__,不能重写\n\n### ES6解决方案\n\n#### 1.includes()\n```\nfunction unique(arr, newArr=[]) {\n    arr.forEach(function(item) {\n        if(!newArr.includes(item))\n        newArr.push(item)\n    })\n    return newArr\n}\n```\n#### 2.Map数据类型\n```\nfunction unique(arr, tmp=new Map(), newArr=[], len=arr.length) {\n    for(let i=0; i<len; i++) {\n        if(!tmp.get(arr[i]) {\n            tmp.set(arr[i],true)\n            newArr.push(arr[i])\n        }\n    }\n}\n```\n#### 3.Set数据类型\n```\nfunction unique(arr) {\n    arr = new Set(arr)//Set原型上带有一个迭代器的方法，所以可以用Array.from\n    return Array.from(arr)\n}\n  \n```","slug":"js-foundation-深入理解数组去重","published":1,"date":"2017-04-23T11:09:40.000Z","updated":"2017-04-23T11:09:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ci0004nkzy66tdd2l6d","content":"<h3 id=\"首先确定是否需要全等于，还是等于\"><a href=\"#首先确定是否需要全等于，还是等于\" class=\"headerlink\" title=\"@首先确定是否需要全等于，还是等于\"></a>@首先确定是否需要全等于，还是等于</h3><h3 id=\"ES5-解决方案\"><a href=\"#ES5-解决方案\" class=\"headerlink\" title=\"ES5 解决方案\"></a>ES5 解决方案</h3><h4 id=\"1-双重遍历\"><a href=\"#1-双重遍历\" class=\"headerlink\" title=\"1.双重遍历\"></a>1.双重遍历</h4>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unque(arr) &#123;</div><div class=\"line\">    var newArr = [];</div><div class=\"line\">    var len =arr.length;</div><div class=\"line\">    var onOff;</div><div class=\"line\">    for(var i=0; i&lt;len; i++) &#123;</div><div class=\"line\">        onOff = false;</div><div class=\"line\">        for(var j=i+1; j&lt;len; j++ )&#123;</div><div class=\"line\">          if(arr[i] === arr[j]) &#123;//这里用的是全等，所以如果有多个[],结果也会存在多个[]</div><div class=\"line\">              onOff = true;</div><div class=\"line\">              break;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if(!onOff) &#123;//如果当前元素之后不存在相同元素</div><div class=\"line\">            newArr.push(arr[i])</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return newArr;</div><div class=\"line\">    ==缺点==：导致NaN重复</div><div class=\"line\">&#125;</div><div class=\"line\">优化：</div><div class=\"line\">  function unique(arr) &#123;</div><div class=\"line\">      var newArr = [];</div><div class=\"line\">      var len = arr.length;</div><div class=\"line\">      for(var i=0; i&lt;len; i++) &#123;</div><div class=\"line\">          for(var j=i+1; j&lt;len; j++) &#123;</div><div class=\"line\">              if(arr[i] === arr[j])</div><div class=\"line\">              j = ++i;</div><div class=\"line\">          &#125;</div><div class=\"line\">          //没有相同的元素就添加</div><div class=\"line\">          newArr.push(arr[i])</div><div class=\"line\">      &#125;</div><div class=\"line\">      return newArr;</div><div class=\"line\">  &#125;</div><div class=\"line\">  ==缺点==：导致NaN重复</div></pre></td></tr></table></figure>\n<h4 id=\"2-高阶函数去重\"><a href=\"#2-高阶函数去重\" class=\"headerlink\" title=\"2.高阶函数去重\"></a>2.高阶函数去重</h4>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr) &#123;</div><div class=\"line\">  //优点：不用再申明一个变量来保存</div><div class=\"line\">    arr.filter(function(val, index)&#123;</div><div class=\"line\">          //如果当前索引不是第一个索引</div><div class=\"line\">          </div><div class=\"line\">        return arr.indexOf(val) === index;</div><div class=\"line\">        //===不能处理NaN的相等性判断。</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-对象key值去重\"><a href=\"#3-对象key值去重\" class=\"headerlink\" title=\"3.对象key值去重\"></a>3.对象key值去重</h4>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr) &#123;</div><div class=\"line\">   var newArr = [];</div><div class=\"line\">   var tmp = &#123;&#125;</div><div class=\"line\">   var key;</div><div class=\"line\">   var len = arr.length;</div><div class=\"line\">   for(var item in arr) &#123;</div><div class=\"line\">      key = typeof arr[item] + JSON.stringify(arr[item]);//\t如果没有这句=&gt;字符串和数字无法区分，对象、数组、正则表达式被去重</div><div class=\"line\">      console.log(key)</div><div class=\"line\">       if(!tmp[key]) &#123;</div><div class=\"line\">           tmp[key] = true;</div><div class=\"line\">           newArr.push(arr[item])</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   return newArr;</div><div class=\"line\">   //对象、数组被去重，正则表达式被消失</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"综上所述，影响数组去重的因素：\"><a href=\"#综上所述，影响数组去重的因素：\" class=\"headerlink\" title=\"综上所述，影响数组去重的因素：\"></a>综上所述，影响数组去重的因素：</h3><pre><code>1.=== \n2.indexOf  不能判断NaN\n3.对象key属性存在 字符串和数字隐式转换，对象变成属性时为[object object]，特殊属性__proto__,不能重写\n</code></pre><h3 id=\"ES6解决方案\"><a href=\"#ES6解决方案\" class=\"headerlink\" title=\"ES6解决方案\"></a>ES6解决方案</h3><h4 id=\"1-includes\"><a href=\"#1-includes\" class=\"headerlink\" title=\"1.includes()\"></a>1.includes()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr, newArr=[]) &#123;</div><div class=\"line\">    arr.forEach(function(item) &#123;</div><div class=\"line\">        if(!newArr.includes(item))</div><div class=\"line\">        newArr.push(item)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    return newArr</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-Map数据类型\"><a href=\"#2-Map数据类型\" class=\"headerlink\" title=\"2.Map数据类型\"></a>2.Map数据类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr, tmp=new Map(), newArr=[], len=arr.length) &#123;</div><div class=\"line\">    for(let i=0; i&lt;len; i++) &#123;</div><div class=\"line\">        if(!tmp.get(arr[i]) &#123;</div><div class=\"line\">            tmp.set(arr[i],true)</div><div class=\"line\">            newArr.push(arr[i])</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-Set数据类型\"><a href=\"#3-Set数据类型\" class=\"headerlink\" title=\"3.Set数据类型\"></a>3.Set数据类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr) &#123;</div><div class=\"line\">    arr = new Set(arr)//Set原型上带有一个迭代器的方法，所以可以用Array.from</div><div class=\"line\">    return Array.from(arr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"首先确定是否需要全等于，还是等于\"><a href=\"#首先确定是否需要全等于，还是等于\" class=\"headerlink\" title=\"@首先确定是否需要全等于，还是等于\"></a>@首先确定是否需要全等于，还是等于</h3><h3 id=\"ES5-解决方案\"><a href=\"#ES5-解决方案\" class=\"headerlink\" title=\"ES5 解决方案\"></a>ES5 解决方案</h3><h4 id=\"1-双重遍历\"><a href=\"#1-双重遍历\" class=\"headerlink\" title=\"1.双重遍历\"></a>1.双重遍历</h4>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unque(arr) &#123;</div><div class=\"line\">    var newArr = [];</div><div class=\"line\">    var len =arr.length;</div><div class=\"line\">    var onOff;</div><div class=\"line\">    for(var i=0; i&lt;len; i++) &#123;</div><div class=\"line\">        onOff = false;</div><div class=\"line\">        for(var j=i+1; j&lt;len; j++ )&#123;</div><div class=\"line\">          if(arr[i] === arr[j]) &#123;//这里用的是全等，所以如果有多个[],结果也会存在多个[]</div><div class=\"line\">              onOff = true;</div><div class=\"line\">              break;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if(!onOff) &#123;//如果当前元素之后不存在相同元素</div><div class=\"line\">            newArr.push(arr[i])</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return newArr;</div><div class=\"line\">    ==缺点==：导致NaN重复</div><div class=\"line\">&#125;</div><div class=\"line\">优化：</div><div class=\"line\">  function unique(arr) &#123;</div><div class=\"line\">      var newArr = [];</div><div class=\"line\">      var len = arr.length;</div><div class=\"line\">      for(var i=0; i&lt;len; i++) &#123;</div><div class=\"line\">          for(var j=i+1; j&lt;len; j++) &#123;</div><div class=\"line\">              if(arr[i] === arr[j])</div><div class=\"line\">              j = ++i;</div><div class=\"line\">          &#125;</div><div class=\"line\">          //没有相同的元素就添加</div><div class=\"line\">          newArr.push(arr[i])</div><div class=\"line\">      &#125;</div><div class=\"line\">      return newArr;</div><div class=\"line\">  &#125;</div><div class=\"line\">  ==缺点==：导致NaN重复</div></pre></td></tr></table></figure>\n<h4 id=\"2-高阶函数去重\"><a href=\"#2-高阶函数去重\" class=\"headerlink\" title=\"2.高阶函数去重\"></a>2.高阶函数去重</h4>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr) &#123;</div><div class=\"line\">  //优点：不用再申明一个变量来保存</div><div class=\"line\">    arr.filter(function(val, index)&#123;</div><div class=\"line\">          //如果当前索引不是第一个索引</div><div class=\"line\">          </div><div class=\"line\">        return arr.indexOf(val) === index;</div><div class=\"line\">        //===不能处理NaN的相等性判断。</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-对象key值去重\"><a href=\"#3-对象key值去重\" class=\"headerlink\" title=\"3.对象key值去重\"></a>3.对象key值去重</h4>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr) &#123;</div><div class=\"line\">   var newArr = [];</div><div class=\"line\">   var tmp = &#123;&#125;</div><div class=\"line\">   var key;</div><div class=\"line\">   var len = arr.length;</div><div class=\"line\">   for(var item in arr) &#123;</div><div class=\"line\">      key = typeof arr[item] + JSON.stringify(arr[item]);//\t如果没有这句=&gt;字符串和数字无法区分，对象、数组、正则表达式被去重</div><div class=\"line\">      console.log(key)</div><div class=\"line\">       if(!tmp[key]) &#123;</div><div class=\"line\">           tmp[key] = true;</div><div class=\"line\">           newArr.push(arr[item])</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   return newArr;</div><div class=\"line\">   //对象、数组被去重，正则表达式被消失</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"综上所述，影响数组去重的因素：\"><a href=\"#综上所述，影响数组去重的因素：\" class=\"headerlink\" title=\"综上所述，影响数组去重的因素：\"></a>综上所述，影响数组去重的因素：</h3><pre><code>1.=== \n2.indexOf  不能判断NaN\n3.对象key属性存在 字符串和数字隐式转换，对象变成属性时为[object object]，特殊属性__proto__,不能重写\n</code></pre><h3 id=\"ES6解决方案\"><a href=\"#ES6解决方案\" class=\"headerlink\" title=\"ES6解决方案\"></a>ES6解决方案</h3><h4 id=\"1-includes\"><a href=\"#1-includes\" class=\"headerlink\" title=\"1.includes()\"></a>1.includes()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr, newArr=[]) &#123;</div><div class=\"line\">    arr.forEach(function(item) &#123;</div><div class=\"line\">        if(!newArr.includes(item))</div><div class=\"line\">        newArr.push(item)</div><div class=\"line\">    &#125;)</div><div class=\"line\">    return newArr</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"2-Map数据类型\"><a href=\"#2-Map数据类型\" class=\"headerlink\" title=\"2.Map数据类型\"></a>2.Map数据类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr, tmp=new Map(), newArr=[], len=arr.length) &#123;</div><div class=\"line\">    for(let i=0; i&lt;len; i++) &#123;</div><div class=\"line\">        if(!tmp.get(arr[i]) &#123;</div><div class=\"line\">            tmp.set(arr[i],true)</div><div class=\"line\">            newArr.push(arr[i])</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"3-Set数据类型\"><a href=\"#3-Set数据类型\" class=\"headerlink\" title=\"3.Set数据类型\"></a>3.Set数据类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">function unique(arr) &#123;</div><div class=\"line\">    arr = new Set(arr)//Set原型上带有一个迭代器的方法，所以可以用Array.from</div><div class=\"line\">    return Array.from(arr)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"现代模块化机制","type":"categories","_content":"\n## 现代模块的机制\n\n- 定义存取的模块\n- 获取以来的模块\n- 并把后续注册的module绑定到存取模块里\n- 返回对外提供的api\n```\nvar  myModules = (function manager() {\n\tvar modules = {}\n\tfunction define(name, deps, impl) {\n\t\tfor(var i=0; i< =deps.length; i++) {\n\t\t\tdeps[i] = modules[deps[i]];\n\t\t}\n\t\tmodules[name] = impl.apply(impl, deps);\n\t}\n\tfunction get(name) {\n\t\treturn modules[name];\n\t}\n\treturn {\n\t\tdefine: define,\n\t\tget: get\n\t}\n})()\n\nmyModules.define('bar', [], function() {\n\tfunction hello(who) {\n\t\treturn who;\n\t}\n\treturn {\n\t\thello: hello\n\t}\n})\n\nmyModules.define('foo', ['bar'], function(bar) {\n\tvar hungry = 'hippo'\n\tfunction awesome() {\n\t\tbar.hello('wbcz')\n\t}\n\treturn {\n\t\tawesome: awesome\n\t}\n})\n\nvar bar = myModules.get(\"bar\")\nbar.hello('wbcz')\n\n```","source":"_posts/js/foundation/现代模块化机制.md","raw":"---\ntitle: 现代模块化机制\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n## 现代模块的机制\n\n- 定义存取的模块\n- 获取以来的模块\n- 并把后续注册的module绑定到存取模块里\n- 返回对外提供的api\n```\nvar  myModules = (function manager() {\n\tvar modules = {}\n\tfunction define(name, deps, impl) {\n\t\tfor(var i=0; i< =deps.length; i++) {\n\t\t\tdeps[i] = modules[deps[i]];\n\t\t}\n\t\tmodules[name] = impl.apply(impl, deps);\n\t}\n\tfunction get(name) {\n\t\treturn modules[name];\n\t}\n\treturn {\n\t\tdefine: define,\n\t\tget: get\n\t}\n})()\n\nmyModules.define('bar', [], function() {\n\tfunction hello(who) {\n\t\treturn who;\n\t}\n\treturn {\n\t\thello: hello\n\t}\n})\n\nmyModules.define('foo', ['bar'], function(bar) {\n\tvar hungry = 'hippo'\n\tfunction awesome() {\n\t\tbar.hello('wbcz')\n\t}\n\treturn {\n\t\tawesome: awesome\n\t}\n})\n\nvar bar = myModules.get(\"bar\")\nbar.hello('wbcz')\n\n```","slug":"js-foundation-现代模块化机制","published":1,"date":"2017-04-23T11:09:56.000Z","updated":"2017-04-23T11:09:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ci1004pkzy6ryhu6ckm","content":"<h2 id=\"现代模块的机制\"><a href=\"#现代模块的机制\" class=\"headerlink\" title=\"现代模块的机制\"></a>现代模块的机制</h2><ul>\n<li>定义存取的模块</li>\n<li>获取以来的模块</li>\n<li>并把后续注册的module绑定到存取模块里</li>\n<li>返回对外提供的api<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var  myModules = (function manager() &#123;</div><div class=\"line\">\tvar modules = &#123;&#125;</div><div class=\"line\">\tfunction define(name, deps, impl) &#123;</div><div class=\"line\">\t\tfor(var i=0; i&lt; =deps.length; i++) &#123;</div><div class=\"line\">\t\t\tdeps[i] = modules[deps[i]];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tmodules[name] = impl.apply(impl, deps);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfunction get(name) &#123;</div><div class=\"line\">\t\treturn modules[name];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\tdefine: define,</div><div class=\"line\">\t\tget: get</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)()</div><div class=\"line\"></div><div class=\"line\">myModules.define(&apos;bar&apos;, [], function() &#123;</div><div class=\"line\">\tfunction hello(who) &#123;</div><div class=\"line\">\t\treturn who;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\thello: hello</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">myModules.define(&apos;foo&apos;, [&apos;bar&apos;], function(bar) &#123;</div><div class=\"line\">\tvar hungry = &apos;hippo&apos;</div><div class=\"line\">\tfunction awesome() &#123;</div><div class=\"line\">\t\tbar.hello(&apos;wbcz&apos;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\tawesome: awesome</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">var bar = myModules.get(&quot;bar&quot;)</div><div class=\"line\">bar.hello(&apos;wbcz&apos;)</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"现代模块的机制\"><a href=\"#现代模块的机制\" class=\"headerlink\" title=\"现代模块的机制\"></a>现代模块的机制</h2><ul>\n<li>定义存取的模块</li>\n<li>获取以来的模块</li>\n<li>并把后续注册的module绑定到存取模块里</li>\n<li>返回对外提供的api<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">var  myModules = (function manager() &#123;</div><div class=\"line\">\tvar modules = &#123;&#125;</div><div class=\"line\">\tfunction define(name, deps, impl) &#123;</div><div class=\"line\">\t\tfor(var i=0; i&lt; =deps.length; i++) &#123;</div><div class=\"line\">\t\t\tdeps[i] = modules[deps[i]];</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tmodules[name] = impl.apply(impl, deps);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tfunction get(name) &#123;</div><div class=\"line\">\t\treturn modules[name];</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\tdefine: define,</div><div class=\"line\">\t\tget: get</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)()</div><div class=\"line\"></div><div class=\"line\">myModules.define(&apos;bar&apos;, [], function() &#123;</div><div class=\"line\">\tfunction hello(who) &#123;</div><div class=\"line\">\t\treturn who;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\thello: hello</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">myModules.define(&apos;foo&apos;, [&apos;bar&apos;], function(bar) &#123;</div><div class=\"line\">\tvar hungry = &apos;hippo&apos;</div><div class=\"line\">\tfunction awesome() &#123;</div><div class=\"line\">\t\tbar.hello(&apos;wbcz&apos;)</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\tawesome: awesome</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">var bar = myModules.get(&quot;bar&quot;)</div><div class=\"line\">bar.hello(&apos;wbcz&apos;)</div></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"自定义事件","type":"categories","_content":"##### 1.实现一个可以注册和移除的事件  2.事件处理程序可以包含多个  3.事件处理程序可以分别移除  4.同一个事件的处理程序可以全部移除\n\n```\nclass Events {\n\n    constructor() {\n\n        this.events = {}\n\n    }\n\n    registerHander(name, callback = function() {}) {\n\n        if(arguments.length === 0) throw Error('必须传参数')\n\n        if(!this.events[name]) {\n            this.events[name] = []\n        }\n        this.events[name].push(callback)\n        return this\n\n    }\n\n    removeHander(name, callback) {\n\n        if(arguments.length === 0) throw Error('必须传参数')\n\n        if(this.events[name] instanceof Array) {\n            let handlers = this.events[name]\n            if(callback) {  \n                for(let i=0, len=handlers.length; i<len; i++) {\n                    if(handlers[i] === callback) {\n                        handlers.splice(i, 1)\n                        break\n                    }\n                }\n            } else {\n                handlers = null\n            }\n        } else {\n            throw Error('请确认是否注册过这个事件')\n        }\n        return this\n    }\n\n    trrigerHander(name, callback) {\n\n        if(arguments.length === 0) throw Error('必须传参数')\n\n        if(this.events[name] instanceof Array) {\n            let handlers = this.events[name]\n            for(let v of handlers) {\n                if(!callback) {\n                    v()\n                } else if(name && typeof callback === 'function'){\n                    if(v === callback) {\n                        callback()\n                    }\n                }\n            }\n        } else {\n            throw Error('请确认是否注册过这个事件')\n        }\n        return this\n    }\n\n}\n\n```\n\n```\n\nclass Child extends Events {\n    \n}\n\nlet evt = new Child()\nfunction fruit() {\n    console.log('fruit')\n}\nfunction meat() {\n    console.log('meat')\n}\nevt.registerHander('eat',fruit).registerHander('eat',meat).removeHander('eat',meat).trrigerHander('eat')\n\n```\n","source":"_posts/js/foundation/自定义事件.md","raw":"\n---\ntitle: 自定义事件\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n##### 1.实现一个可以注册和移除的事件  2.事件处理程序可以包含多个  3.事件处理程序可以分别移除  4.同一个事件的处理程序可以全部移除\n\n```\nclass Events {\n\n    constructor() {\n\n        this.events = {}\n\n    }\n\n    registerHander(name, callback = function() {}) {\n\n        if(arguments.length === 0) throw Error('必须传参数')\n\n        if(!this.events[name]) {\n            this.events[name] = []\n        }\n        this.events[name].push(callback)\n        return this\n\n    }\n\n    removeHander(name, callback) {\n\n        if(arguments.length === 0) throw Error('必须传参数')\n\n        if(this.events[name] instanceof Array) {\n            let handlers = this.events[name]\n            if(callback) {  \n                for(let i=0, len=handlers.length; i<len; i++) {\n                    if(handlers[i] === callback) {\n                        handlers.splice(i, 1)\n                        break\n                    }\n                }\n            } else {\n                handlers = null\n            }\n        } else {\n            throw Error('请确认是否注册过这个事件')\n        }\n        return this\n    }\n\n    trrigerHander(name, callback) {\n\n        if(arguments.length === 0) throw Error('必须传参数')\n\n        if(this.events[name] instanceof Array) {\n            let handlers = this.events[name]\n            for(let v of handlers) {\n                if(!callback) {\n                    v()\n                } else if(name && typeof callback === 'function'){\n                    if(v === callback) {\n                        callback()\n                    }\n                }\n            }\n        } else {\n            throw Error('请确认是否注册过这个事件')\n        }\n        return this\n    }\n\n}\n\n```\n\n```\n\nclass Child extends Events {\n    \n}\n\nlet evt = new Child()\nfunction fruit() {\n    console.log('fruit')\n}\nfunction meat() {\n    console.log('meat')\n}\nevt.registerHander('eat',fruit).registerHander('eat',meat).removeHander('eat',meat).trrigerHander('eat')\n\n```\n","slug":"js-foundation-自定义事件","published":1,"date":"2017-04-23T11:10:02.000Z","updated":"2017-04-23T11:10:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ci3004rkzy6viod4sbo","content":"<h5 id=\"1-实现一个可以注册和移除的事件-2-事件处理程序可以包含多个-3-事件处理程序可以分别移除-4-同一个事件的处理程序可以全部移除\"><a href=\"#1-实现一个可以注册和移除的事件-2-事件处理程序可以包含多个-3-事件处理程序可以分别移除-4-同一个事件的处理程序可以全部移除\" class=\"headerlink\" title=\"1.实现一个可以注册和移除的事件  2.事件处理程序可以包含多个  3.事件处理程序可以分别移除  4.同一个事件的处理程序可以全部移除\"></a>1.实现一个可以注册和移除的事件  2.事件处理程序可以包含多个  3.事件处理程序可以分别移除  4.同一个事件的处理程序可以全部移除</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Events &#123;</div><div class=\"line\"></div><div class=\"line\">    constructor() &#123;</div><div class=\"line\"></div><div class=\"line\">        this.events = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    registerHander(name, callback = function() &#123;&#125;) &#123;</div><div class=\"line\"></div><div class=\"line\">        if(arguments.length === 0) throw Error(&apos;必须传参数&apos;)</div><div class=\"line\"></div><div class=\"line\">        if(!this.events[name]) &#123;</div><div class=\"line\">            this.events[name] = []</div><div class=\"line\">        &#125;</div><div class=\"line\">        this.events[name].push(callback)</div><div class=\"line\">        return this</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    removeHander(name, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">        if(arguments.length === 0) throw Error(&apos;必须传参数&apos;)</div><div class=\"line\"></div><div class=\"line\">        if(this.events[name] instanceof Array) &#123;</div><div class=\"line\">            let handlers = this.events[name]</div><div class=\"line\">            if(callback) &#123;  </div><div class=\"line\">                for(let i=0, len=handlers.length; i&lt;len; i++) &#123;</div><div class=\"line\">                    if(handlers[i] === callback) &#123;</div><div class=\"line\">                        handlers.splice(i, 1)</div><div class=\"line\">                        break</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                handlers = null</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throw Error(&apos;请确认是否注册过这个事件&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return this</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    trrigerHander(name, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">        if(arguments.length === 0) throw Error(&apos;必须传参数&apos;)</div><div class=\"line\"></div><div class=\"line\">        if(this.events[name] instanceof Array) &#123;</div><div class=\"line\">            let handlers = this.events[name]</div><div class=\"line\">            for(let v of handlers) &#123;</div><div class=\"line\">                if(!callback) &#123;</div><div class=\"line\">                    v()</div><div class=\"line\">                &#125; else if(name &amp;&amp; typeof callback === &apos;function&apos;)&#123;</div><div class=\"line\">                    if(v === callback) &#123;</div><div class=\"line\">                        callback()</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throw Error(&apos;请确认是否注册过这个事件&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return this</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class Child extends Events &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let evt = new Child()</div><div class=\"line\">function fruit() &#123;</div><div class=\"line\">    console.log(&apos;fruit&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">function meat() &#123;</div><div class=\"line\">    console.log(&apos;meat&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">evt.registerHander(&apos;eat&apos;,fruit).registerHander(&apos;eat&apos;,meat).removeHander(&apos;eat&apos;,meat).trrigerHander(&apos;eat&apos;)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"1-实现一个可以注册和移除的事件-2-事件处理程序可以包含多个-3-事件处理程序可以分别移除-4-同一个事件的处理程序可以全部移除\"><a href=\"#1-实现一个可以注册和移除的事件-2-事件处理程序可以包含多个-3-事件处理程序可以分别移除-4-同一个事件的处理程序可以全部移除\" class=\"headerlink\" title=\"1.实现一个可以注册和移除的事件  2.事件处理程序可以包含多个  3.事件处理程序可以分别移除  4.同一个事件的处理程序可以全部移除\"></a>1.实现一个可以注册和移除的事件  2.事件处理程序可以包含多个  3.事件处理程序可以分别移除  4.同一个事件的处理程序可以全部移除</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Events &#123;</div><div class=\"line\"></div><div class=\"line\">    constructor() &#123;</div><div class=\"line\"></div><div class=\"line\">        this.events = &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    registerHander(name, callback = function() &#123;&#125;) &#123;</div><div class=\"line\"></div><div class=\"line\">        if(arguments.length === 0) throw Error(&apos;必须传参数&apos;)</div><div class=\"line\"></div><div class=\"line\">        if(!this.events[name]) &#123;</div><div class=\"line\">            this.events[name] = []</div><div class=\"line\">        &#125;</div><div class=\"line\">        this.events[name].push(callback)</div><div class=\"line\">        return this</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    removeHander(name, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">        if(arguments.length === 0) throw Error(&apos;必须传参数&apos;)</div><div class=\"line\"></div><div class=\"line\">        if(this.events[name] instanceof Array) &#123;</div><div class=\"line\">            let handlers = this.events[name]</div><div class=\"line\">            if(callback) &#123;  </div><div class=\"line\">                for(let i=0, len=handlers.length; i&lt;len; i++) &#123;</div><div class=\"line\">                    if(handlers[i] === callback) &#123;</div><div class=\"line\">                        handlers.splice(i, 1)</div><div class=\"line\">                        break</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                handlers = null</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throw Error(&apos;请确认是否注册过这个事件&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return this</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    trrigerHander(name, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">        if(arguments.length === 0) throw Error(&apos;必须传参数&apos;)</div><div class=\"line\"></div><div class=\"line\">        if(this.events[name] instanceof Array) &#123;</div><div class=\"line\">            let handlers = this.events[name]</div><div class=\"line\">            for(let v of handlers) &#123;</div><div class=\"line\">                if(!callback) &#123;</div><div class=\"line\">                    v()</div><div class=\"line\">                &#125; else if(name &amp;&amp; typeof callback === &apos;function&apos;)&#123;</div><div class=\"line\">                    if(v === callback) &#123;</div><div class=\"line\">                        callback()</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            throw Error(&apos;请确认是否注册过这个事件&apos;)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return this</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">class Child extends Events &#123;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let evt = new Child()</div><div class=\"line\">function fruit() &#123;</div><div class=\"line\">    console.log(&apos;fruit&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">function meat() &#123;</div><div class=\"line\">    console.log(&apos;meat&apos;)</div><div class=\"line\">&#125;</div><div class=\"line\">evt.registerHander(&apos;eat&apos;,fruit).registerHander(&apos;eat&apos;,meat).removeHander(&apos;eat&apos;,meat).trrigerHander(&apos;eat&apos;)</div></pre></td></tr></table></figure>\n"},{"title":"跨域请求","type":"categories","_content":"\n## 简单聊一下跨域...\n\n### 造成跨域的由来：\n```\n AJAX跨域请求: //是因为浏览器的同源策略，一个页面的AJAX只能获取这个页面相同和源或者相同域的数据；\n \n同源、同域： //协议、端口、域名都要相同\n```\n\n### 常用解决方法\n\n#### #JSONP\n```\n1.浏览器：浏览器创建一个script标签，将src设置为:// http://xxxx.com?callback=JsonpCallback;\n2.服务端: 将要返回的数据组合成JsonpCallback({data})\n3.浏览器立即执行JsonpCallback方法，并且通过参数获取到了数据\n\n```\n#### # CORS\n##### 简单请求：同时满足两种条件\n##### 非简单请求： 同时不满足两种条件:比如请求方式是PUT，Delete,或者post提交数据的方式：application/json\n```\n（1) 请求方法是以下三种方法之一：\n    HEAD\n    GET\n    POST\n（2）HTTP的头信息不超出以下几种字段：\n    Accept\n    Accept-Language\n    Content-Language\n    Last-Event-ID\n    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n```\n##### 流程\n```\n浏览器：在请求头部增加一个Origin字段：\nOrigin: http://api.bob.com；\n如过浏览器在响应首部接收到Access-Control-Allow-xxx类似信息，说明请求成功\n\n```\n```\n服务器： CORS默认不发送Cookie和HTTP认证信息，如果要发送，需要指定：Access-Control-Allow-Credentials: true;\n前端也要打开: xhr.withCredentials = true\n###注意： 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。\n###  Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie\n```\n### POST提交数据的方式()\n```\n表单：enctype设置属性，只支持application/x-www-form-urlencoded和text/plain\nContent-type: application/x-www-form-urlencoded;charset=utf-8\n\n文件上传：\nContent-type: multipart/form-data;\n\njson字符串传递：部分后台语言不能原生支持，比如php，php 就无法通过 $_POST 对象从上面的请求中获得内容，可以通过，从 php://input 里获得原始输入流，再 json_decode 成对象。\nContent-type:application/json;charset=utf-8\n\nxml传递：\nContent-type: text/xml;\n\n```","source":"_posts/js/foundation/跨域请求.md","raw":"---\ntitle: 跨域请求\ntype: \"categories\"\ncategories: [前端, JS, 基本概念]\n---\n\n## 简单聊一下跨域...\n\n### 造成跨域的由来：\n```\n AJAX跨域请求: //是因为浏览器的同源策略，一个页面的AJAX只能获取这个页面相同和源或者相同域的数据；\n \n同源、同域： //协议、端口、域名都要相同\n```\n\n### 常用解决方法\n\n#### #JSONP\n```\n1.浏览器：浏览器创建一个script标签，将src设置为:// http://xxxx.com?callback=JsonpCallback;\n2.服务端: 将要返回的数据组合成JsonpCallback({data})\n3.浏览器立即执行JsonpCallback方法，并且通过参数获取到了数据\n\n```\n#### # CORS\n##### 简单请求：同时满足两种条件\n##### 非简单请求： 同时不满足两种条件:比如请求方式是PUT，Delete,或者post提交数据的方式：application/json\n```\n（1) 请求方法是以下三种方法之一：\n    HEAD\n    GET\n    POST\n（2）HTTP的头信息不超出以下几种字段：\n    Accept\n    Accept-Language\n    Content-Language\n    Last-Event-ID\n    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n```\n##### 流程\n```\n浏览器：在请求头部增加一个Origin字段：\nOrigin: http://api.bob.com；\n如过浏览器在响应首部接收到Access-Control-Allow-xxx类似信息，说明请求成功\n\n```\n```\n服务器： CORS默认不发送Cookie和HTTP认证信息，如果要发送，需要指定：Access-Control-Allow-Credentials: true;\n前端也要打开: xhr.withCredentials = true\n###注意： 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。\n###  Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie\n```\n### POST提交数据的方式()\n```\n表单：enctype设置属性，只支持application/x-www-form-urlencoded和text/plain\nContent-type: application/x-www-form-urlencoded;charset=utf-8\n\n文件上传：\nContent-type: multipart/form-data;\n\njson字符串传递：部分后台语言不能原生支持，比如php，php 就无法通过 $_POST 对象从上面的请求中获得内容，可以通过，从 php://input 里获得原始输入流，再 json_decode 成对象。\nContent-type:application/json;charset=utf-8\n\nxml传递：\nContent-type: text/xml;\n\n```","slug":"js-foundation-跨域请求","published":1,"date":"2017-04-23T11:10:06.000Z","updated":"2017-04-23T11:10:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ci5004ukzy6vfn0qo6p","content":"<h2 id=\"简单聊一下跨域…\"><a href=\"#简单聊一下跨域…\" class=\"headerlink\" title=\"简单聊一下跨域…\"></a>简单聊一下跨域…</h2><h3 id=\"造成跨域的由来：\"><a href=\"#造成跨域的由来：\" class=\"headerlink\" title=\"造成跨域的由来：\"></a>造成跨域的由来：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> AJAX跨域请求: //是因为浏览器的同源策略，一个页面的AJAX只能获取这个页面相同和源或者相同域的数据；</div><div class=\"line\"> </div><div class=\"line\">同源、同域： //协议、端口、域名都要相同</div></pre></td></tr></table></figure>\n<h3 id=\"常用解决方法\"><a href=\"#常用解决方法\" class=\"headerlink\" title=\"常用解决方法\"></a>常用解决方法</h3><h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"#JSONP\"></a>#JSONP</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.浏览器：浏览器创建一个script标签，将src设置为:// http://xxxx.com?callback=JsonpCallback;</div><div class=\"line\">2.服务端: 将要返回的数据组合成JsonpCallback(&#123;data&#125;)</div><div class=\"line\">3.浏览器立即执行JsonpCallback方法，并且通过参数获取到了数据</div></pre></td></tr></table></figure>\n<h4 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"# CORS\"></a># CORS</h4><h5 id=\"简单请求：同时满足两种条件\"><a href=\"#简单请求：同时满足两种条件\" class=\"headerlink\" title=\"简单请求：同时满足两种条件\"></a>简单请求：同时满足两种条件</h5><h5 id=\"非简单请求：-同时不满足两种条件-比如请求方式是PUT，Delete-或者post提交数据的方式：application-json\"><a href=\"#非简单请求：-同时不满足两种条件-比如请求方式是PUT，Delete-或者post提交数据的方式：application-json\" class=\"headerlink\" title=\"非简单请求： 同时不满足两种条件:比如请求方式是PUT，Delete,或者post提交数据的方式：application/json\"></a>非简单请求： 同时不满足两种条件:比如请求方式是PUT，Delete,或者post提交数据的方式：application/json</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1) 请求方法是以下三种方法之一：</div><div class=\"line\">    HEAD</div><div class=\"line\">    GET</div><div class=\"line\">    POST</div><div class=\"line\">（2）HTTP的头信息不超出以下几种字段：</div><div class=\"line\">    Accept</div><div class=\"line\">    Accept-Language</div><div class=\"line\">    Content-Language</div><div class=\"line\">    Last-Event-ID</div><div class=\"line\">    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</div></pre></td></tr></table></figure>\n<h5 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">浏览器：在请求头部增加一个Origin字段：</div><div class=\"line\">Origin: http://api.bob.com；</div><div class=\"line\">如过浏览器在响应首部接收到Access-Control-Allow-xxx类似信息，说明请求成功</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">服务器： CORS默认不发送Cookie和HTTP认证信息，如果要发送，需要指定：Access-Control-Allow-Credentials: true;</div><div class=\"line\">前端也要打开: xhr.withCredentials = true</div><div class=\"line\">###注意： 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。</div><div class=\"line\">###  Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie</div></pre></td></tr></table></figure>\n<h3 id=\"POST提交数据的方式\"><a href=\"#POST提交数据的方式\" class=\"headerlink\" title=\"POST提交数据的方式()\"></a>POST提交数据的方式()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">表单：enctype设置属性，只支持application/x-www-form-urlencoded和text/plain</div><div class=\"line\">Content-type: application/x-www-form-urlencoded;charset=utf-8</div><div class=\"line\"></div><div class=\"line\">文件上传：</div><div class=\"line\">Content-type: multipart/form-data;</div><div class=\"line\"></div><div class=\"line\">json字符串传递：部分后台语言不能原生支持，比如php，php 就无法通过 $_POST 对象从上面的请求中获得内容，可以通过，从 php://input 里获得原始输入流，再 json_decode 成对象。</div><div class=\"line\">Content-type:application/json;charset=utf-8</div><div class=\"line\"></div><div class=\"line\">xml传递：</div><div class=\"line\">Content-type: text/xml;</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简单聊一下跨域…\"><a href=\"#简单聊一下跨域…\" class=\"headerlink\" title=\"简单聊一下跨域…\"></a>简单聊一下跨域…</h2><h3 id=\"造成跨域的由来：\"><a href=\"#造成跨域的由来：\" class=\"headerlink\" title=\"造成跨域的由来：\"></a>造成跨域的由来：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> AJAX跨域请求: //是因为浏览器的同源策略，一个页面的AJAX只能获取这个页面相同和源或者相同域的数据；</div><div class=\"line\"> </div><div class=\"line\">同源、同域： //协议、端口、域名都要相同</div></pre></td></tr></table></figure>\n<h3 id=\"常用解决方法\"><a href=\"#常用解决方法\" class=\"headerlink\" title=\"常用解决方法\"></a>常用解决方法</h3><h4 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"#JSONP\"></a>#JSONP</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">1.浏览器：浏览器创建一个script标签，将src设置为:// http://xxxx.com?callback=JsonpCallback;</div><div class=\"line\">2.服务端: 将要返回的数据组合成JsonpCallback(&#123;data&#125;)</div><div class=\"line\">3.浏览器立即执行JsonpCallback方法，并且通过参数获取到了数据</div></pre></td></tr></table></figure>\n<h4 id=\"CORS\"><a href=\"#CORS\" class=\"headerlink\" title=\"# CORS\"></a># CORS</h4><h5 id=\"简单请求：同时满足两种条件\"><a href=\"#简单请求：同时满足两种条件\" class=\"headerlink\" title=\"简单请求：同时满足两种条件\"></a>简单请求：同时满足两种条件</h5><h5 id=\"非简单请求：-同时不满足两种条件-比如请求方式是PUT，Delete-或者post提交数据的方式：application-json\"><a href=\"#非简单请求：-同时不满足两种条件-比如请求方式是PUT，Delete-或者post提交数据的方式：application-json\" class=\"headerlink\" title=\"非简单请求： 同时不满足两种条件:比如请求方式是PUT，Delete,或者post提交数据的方式：application/json\"></a>非简单请求： 同时不满足两种条件:比如请求方式是PUT，Delete,或者post提交数据的方式：application/json</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1) 请求方法是以下三种方法之一：</div><div class=\"line\">    HEAD</div><div class=\"line\">    GET</div><div class=\"line\">    POST</div><div class=\"line\">（2）HTTP的头信息不超出以下几种字段：</div><div class=\"line\">    Accept</div><div class=\"line\">    Accept-Language</div><div class=\"line\">    Content-Language</div><div class=\"line\">    Last-Event-ID</div><div class=\"line\">    Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</div></pre></td></tr></table></figure>\n<h5 id=\"流程\"><a href=\"#流程\" class=\"headerlink\" title=\"流程\"></a>流程</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">浏览器：在请求头部增加一个Origin字段：</div><div class=\"line\">Origin: http://api.bob.com；</div><div class=\"line\">如过浏览器在响应首部接收到Access-Control-Allow-xxx类似信息，说明请求成功</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">服务器： CORS默认不发送Cookie和HTTP认证信息，如果要发送，需要指定：Access-Control-Allow-Credentials: true;</div><div class=\"line\">前端也要打开: xhr.withCredentials = true</div><div class=\"line\">###注意： 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。</div><div class=\"line\">###  Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie</div></pre></td></tr></table></figure>\n<h3 id=\"POST提交数据的方式\"><a href=\"#POST提交数据的方式\" class=\"headerlink\" title=\"POST提交数据的方式()\"></a>POST提交数据的方式()</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">表单：enctype设置属性，只支持application/x-www-form-urlencoded和text/plain</div><div class=\"line\">Content-type: application/x-www-form-urlencoded;charset=utf-8</div><div class=\"line\"></div><div class=\"line\">文件上传：</div><div class=\"line\">Content-type: multipart/form-data;</div><div class=\"line\"></div><div class=\"line\">json字符串传递：部分后台语言不能原生支持，比如php，php 就无法通过 $_POST 对象从上面的请求中获得内容，可以通过，从 php://input 里获得原始输入流，再 json_decode 成对象。</div><div class=\"line\">Content-type:application/json;charset=utf-8</div><div class=\"line\"></div><div class=\"line\">xml传递：</div><div class=\"line\">Content-type: text/xml;</div></pre></td></tr></table></figure>"},{"title":"移动端之Event","type":"categories","_content":"\n### 事件种类\n\n通过obj.on添加事件 //在部分手机浏览模拟器不行\n> ontouchstart\n> ontouchmove\n> ontouchend\n\n通过addListener添加事件\n> touchstart\n> touchmove\n> touchend\n\n### 事件冒泡、捕获\n> 比如分享菜单就是用hover事件实现的\n\n### 事件的注意事项\n> e.preventDefault() //在touchstart，toumove的情况下会**阻止移动端的滚动** ，在浏览器模拟器看不到效果，需要在手机上看,同时阻止页面上的文字被选中，阻止页面上的系统菜单\n> 冒泡：点击元素 他会把这个事件一直向上传递；先执行子元素事件的handle，之后父元素事件也执行，用e.stopPropagation()阻止父元素事件的执行\n\n### 事件点透\n> PC端鼠标事件 在移动端也可以正常使用，但是注意 事件的执行 会有300ms的延迟\n\n1. 在移动端 PC事件 有 300ms的延迟\n2. 我们点击了页面之后，浏览器会记录点击下去的坐标\n3. 300ms后，在该坐标找到现在在这的元素 执行事件\n\n解决办法：\n\n1. 阻止默认事件（部分安卓机型不支持)\n2. 不在移动端使用鼠标事件，不用a标签做页面跳转\n```\nobj.addEventListener(\"touchend\",function (e) {\n\t\te.preventDefault();\n\t}\n);\n```\n\n### 防止误触\n```\nobj.addEventListener('touchmove',()=> {\n\tthis.move = true\n})\nobj.addEventListener('touchend',()=> {\n\tif(!this.move) {\n\t\twindow.location.href = 'xxxxxx'\n\t}\n})\n```\n\n### 事件对象\n1. touches 当前屏幕上的手指列表\n2. targetTouches 当前元素上的手指列表\n4. changedTouches 触发当前事件的手指列表\n## [请看demo](https://wbcz.github.io/special-effects/%E6%BB%91%E5%8A%A8%E7%BB%84%E4%BB%B6ES6%E5%86%99%E6%B3%95/index.html)","source":"_posts/js/mobile/event.md","raw":"---\ntitle: 移动端之Event\ntype: \"categories\"\ncategories: [前端, H5]\n---\n\n### 事件种类\n\n通过obj.on添加事件 //在部分手机浏览模拟器不行\n> ontouchstart\n> ontouchmove\n> ontouchend\n\n通过addListener添加事件\n> touchstart\n> touchmove\n> touchend\n\n### 事件冒泡、捕获\n> 比如分享菜单就是用hover事件实现的\n\n### 事件的注意事项\n> e.preventDefault() //在touchstart，toumove的情况下会**阻止移动端的滚动** ，在浏览器模拟器看不到效果，需要在手机上看,同时阻止页面上的文字被选中，阻止页面上的系统菜单\n> 冒泡：点击元素 他会把这个事件一直向上传递；先执行子元素事件的handle，之后父元素事件也执行，用e.stopPropagation()阻止父元素事件的执行\n\n### 事件点透\n> PC端鼠标事件 在移动端也可以正常使用，但是注意 事件的执行 会有300ms的延迟\n\n1. 在移动端 PC事件 有 300ms的延迟\n2. 我们点击了页面之后，浏览器会记录点击下去的坐标\n3. 300ms后，在该坐标找到现在在这的元素 执行事件\n\n解决办法：\n\n1. 阻止默认事件（部分安卓机型不支持)\n2. 不在移动端使用鼠标事件，不用a标签做页面跳转\n```\nobj.addEventListener(\"touchend\",function (e) {\n\t\te.preventDefault();\n\t}\n);\n```\n\n### 防止误触\n```\nobj.addEventListener('touchmove',()=> {\n\tthis.move = true\n})\nobj.addEventListener('touchend',()=> {\n\tif(!this.move) {\n\t\twindow.location.href = 'xxxxxx'\n\t}\n})\n```\n\n### 事件对象\n1. touches 当前屏幕上的手指列表\n2. targetTouches 当前元素上的手指列表\n4. changedTouches 触发当前事件的手指列表\n## [请看demo](https://wbcz.github.io/special-effects/%E6%BB%91%E5%8A%A8%E7%BB%84%E4%BB%B6ES6%E5%86%99%E6%B3%95/index.html)","slug":"js-mobile-event","published":1,"date":"2017-04-23T22:53:15.000Z","updated":"2017-04-23T22:53:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ci7004wkzy6emly8qsh","content":"<h3 id=\"事件种类\"><a href=\"#事件种类\" class=\"headerlink\" title=\"事件种类\"></a>事件种类</h3><p>通过obj.on添加事件 //在部分手机浏览模拟器不行</p>\n<blockquote>\n<p>ontouchstart<br>ontouchmove<br>ontouchend</p>\n</blockquote>\n<p>通过addListener添加事件</p>\n<blockquote>\n<p>touchstart<br>touchmove<br>touchend</p>\n</blockquote>\n<h3 id=\"事件冒泡、捕获\"><a href=\"#事件冒泡、捕获\" class=\"headerlink\" title=\"事件冒泡、捕获\"></a>事件冒泡、捕获</h3><blockquote>\n<p>比如分享菜单就是用hover事件实现的</p>\n</blockquote>\n<h3 id=\"事件的注意事项\"><a href=\"#事件的注意事项\" class=\"headerlink\" title=\"事件的注意事项\"></a>事件的注意事项</h3><blockquote>\n<p>e.preventDefault() //在touchstart，toumove的情况下会<strong>阻止移动端的滚动</strong> ，在浏览器模拟器看不到效果，需要在手机上看,同时阻止页面上的文字被选中，阻止页面上的系统菜单<br>冒泡：点击元素 他会把这个事件一直向上传递；先执行子元素事件的handle，之后父元素事件也执行，用e.stopPropagation()阻止父元素事件的执行</p>\n</blockquote>\n<h3 id=\"事件点透\"><a href=\"#事件点透\" class=\"headerlink\" title=\"事件点透\"></a>事件点透</h3><blockquote>\n<p>PC端鼠标事件 在移动端也可以正常使用，但是注意 事件的执行 会有300ms的延迟</p>\n</blockquote>\n<ol>\n<li>在移动端 PC事件 有 300ms的延迟</li>\n<li>我们点击了页面之后，浏览器会记录点击下去的坐标</li>\n<li>300ms后，在该坐标找到现在在这的元素 执行事件</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>阻止默认事件（部分安卓机型不支持)</li>\n<li>不在移动端使用鼠标事件，不用a标签做页面跳转<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj.addEventListener(&quot;touchend&quot;,function (e) &#123;</div><div class=\"line\">\t\te.preventDefault();</div><div class=\"line\">\t&#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"防止误触\"><a href=\"#防止误触\" class=\"headerlink\" title=\"防止误触\"></a>防止误触</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj.addEventListener(&apos;touchmove&apos;,()=&gt; &#123;</div><div class=\"line\">\tthis.move = true</div><div class=\"line\">&#125;)</div><div class=\"line\">obj.addEventListener(&apos;touchend&apos;,()=&gt; &#123;</div><div class=\"line\">\tif(!this.move) &#123;</div><div class=\"line\">\t\twindow.location.href = &apos;xxxxxx&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><ol>\n<li>touches 当前屏幕上的手指列表</li>\n<li>targetTouches 当前元素上的手指列表</li>\n<li>changedTouches 触发当前事件的手指列表<h2 id=\"请看demo\"><a href=\"#请看demo\" class=\"headerlink\" title=\"请看demo\"></a><a href=\"https://wbcz.github.io/special-effects/%E6%BB%91%E5%8A%A8%E7%BB%84%E4%BB%B6ES6%E5%86%99%E6%B3%95/index.html\" target=\"_blank\" rel=\"external\">请看demo</a></h2></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"事件种类\"><a href=\"#事件种类\" class=\"headerlink\" title=\"事件种类\"></a>事件种类</h3><p>通过obj.on添加事件 //在部分手机浏览模拟器不行</p>\n<blockquote>\n<p>ontouchstart<br>ontouchmove<br>ontouchend</p>\n</blockquote>\n<p>通过addListener添加事件</p>\n<blockquote>\n<p>touchstart<br>touchmove<br>touchend</p>\n</blockquote>\n<h3 id=\"事件冒泡、捕获\"><a href=\"#事件冒泡、捕获\" class=\"headerlink\" title=\"事件冒泡、捕获\"></a>事件冒泡、捕获</h3><blockquote>\n<p>比如分享菜单就是用hover事件实现的</p>\n</blockquote>\n<h3 id=\"事件的注意事项\"><a href=\"#事件的注意事项\" class=\"headerlink\" title=\"事件的注意事项\"></a>事件的注意事项</h3><blockquote>\n<p>e.preventDefault() //在touchstart，toumove的情况下会<strong>阻止移动端的滚动</strong> ，在浏览器模拟器看不到效果，需要在手机上看,同时阻止页面上的文字被选中，阻止页面上的系统菜单<br>冒泡：点击元素 他会把这个事件一直向上传递；先执行子元素事件的handle，之后父元素事件也执行，用e.stopPropagation()阻止父元素事件的执行</p>\n</blockquote>\n<h3 id=\"事件点透\"><a href=\"#事件点透\" class=\"headerlink\" title=\"事件点透\"></a>事件点透</h3><blockquote>\n<p>PC端鼠标事件 在移动端也可以正常使用，但是注意 事件的执行 会有300ms的延迟</p>\n</blockquote>\n<ol>\n<li>在移动端 PC事件 有 300ms的延迟</li>\n<li>我们点击了页面之后，浏览器会记录点击下去的坐标</li>\n<li>300ms后，在该坐标找到现在在这的元素 执行事件</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>阻止默认事件（部分安卓机型不支持)</li>\n<li>不在移动端使用鼠标事件，不用a标签做页面跳转<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj.addEventListener(&quot;touchend&quot;,function (e) &#123;</div><div class=\"line\">\t\te.preventDefault();</div><div class=\"line\">\t&#125;</div><div class=\"line\">);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"防止误触\"><a href=\"#防止误触\" class=\"headerlink\" title=\"防止误触\"></a>防止误触</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">obj.addEventListener(&apos;touchmove&apos;,()=&gt; &#123;</div><div class=\"line\">\tthis.move = true</div><div class=\"line\">&#125;)</div><div class=\"line\">obj.addEventListener(&apos;touchend&apos;,()=&gt; &#123;</div><div class=\"line\">\tif(!this.move) &#123;</div><div class=\"line\">\t\twindow.location.href = &apos;xxxxxx&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><ol>\n<li>touches 当前屏幕上的手指列表</li>\n<li>targetTouches 当前元素上的手指列表</li>\n<li>changedTouches 触发当前事件的手指列表<h2 id=\"请看demo\"><a href=\"#请看demo\" class=\"headerlink\" title=\"请看demo\"></a><a href=\"https://wbcz.github.io/special-effects/%E6%BB%91%E5%8A%A8%E7%BB%84%E4%BB%B6ES6%E5%86%99%E6%B3%95/index.html\" target=\"_blank\" rel=\"external\">请看demo</a></h2></li>\n</ol>\n"},{"title":"H5坑总结","type":"categories","_content":"\n### localstorage和sessionStorage在safari的无痕浏览模式报错\n\n> 在localstorage.setItem() 报错， localstorage.getItem(), localstorage.removeItem() 会忽略;\n\n解决方案： \n>\t1.如果信息量小可以用cookie或者通过url方式\n>\t2. 后端写个存取数据的公用的接口\n>\t3. 迫不得已的情况下启动单页，存到内存里（要是用了单页就ok了）\n\n### 移动端浏览器300毫秒点击延时\n\n解决方案：\n>\t1.禁止页面缩放 \n>\t2.touchend 事件之后触发一个click事件，再取消300毫秒之后的事件\n\n### transition闪屏\n\n解决方案：\n> -webkit-transform-style: preserve-3d; //3d加速效果\n-webkit-backface-visibility: hidden; //页面转换的时候隐藏\n\n优化：\n\n> 1. overflow: scroll | auto, 滚动时使用原生效果：-webkit-overflow-scrolling: touch\n2.设置css属性 -webkit-user-select:none; 控制用户不可选择文字\n3.通过设置css属性 -webkit-tap-highlight-color: rgba(0, 0, 0, 0);取消掉手机端webkit浏览器 点击按钮或超链接之类的 默认灰色背景色\n\n### H5的奇特技巧\n\n> 做弹窗的时候你会发现，当弹窗内容里面的组件会根据周边元素定位的时候且你的遮罩刚开始是设置为none的时候，\n之后当组件显示，发现页面乱了，因为组件内部前后针对的相对定位的元素不一样。\n\n解决方案\n\n> 1. z-index: -1 ;\n2. 或则opacity：0\n\n注意事项:\n> 如果仅仅点击内容的关闭按钮，关闭弹窗，需要阻止冒泡\n1. e.preventDefault()\n2. e.target == e.currentarget\n\n### H5调试\n> android调试浏览器页面可以用360浏览器\n> webview 调试用 chrome://inspect/version#devices\n> 调试本地代码， 用charles代理工具，手机配置本地电脑的ip\n> 注意safari浏览器调试的时候，第一次的数据捕捉不到\n\n\n","source":"_posts/js/mobile/h5坑总结.md","raw":"---\ntitle: H5坑总结\ntype: \"categories\"\ncategories: [前端, H5]\n---\n\n### localstorage和sessionStorage在safari的无痕浏览模式报错\n\n> 在localstorage.setItem() 报错， localstorage.getItem(), localstorage.removeItem() 会忽略;\n\n解决方案： \n>\t1.如果信息量小可以用cookie或者通过url方式\n>\t2. 后端写个存取数据的公用的接口\n>\t3. 迫不得已的情况下启动单页，存到内存里（要是用了单页就ok了）\n\n### 移动端浏览器300毫秒点击延时\n\n解决方案：\n>\t1.禁止页面缩放 \n>\t2.touchend 事件之后触发一个click事件，再取消300毫秒之后的事件\n\n### transition闪屏\n\n解决方案：\n> -webkit-transform-style: preserve-3d; //3d加速效果\n-webkit-backface-visibility: hidden; //页面转换的时候隐藏\n\n优化：\n\n> 1. overflow: scroll | auto, 滚动时使用原生效果：-webkit-overflow-scrolling: touch\n2.设置css属性 -webkit-user-select:none; 控制用户不可选择文字\n3.通过设置css属性 -webkit-tap-highlight-color: rgba(0, 0, 0, 0);取消掉手机端webkit浏览器 点击按钮或超链接之类的 默认灰色背景色\n\n### H5的奇特技巧\n\n> 做弹窗的时候你会发现，当弹窗内容里面的组件会根据周边元素定位的时候且你的遮罩刚开始是设置为none的时候，\n之后当组件显示，发现页面乱了，因为组件内部前后针对的相对定位的元素不一样。\n\n解决方案\n\n> 1. z-index: -1 ;\n2. 或则opacity：0\n\n注意事项:\n> 如果仅仅点击内容的关闭按钮，关闭弹窗，需要阻止冒泡\n1. e.preventDefault()\n2. e.target == e.currentarget\n\n### H5调试\n> android调试浏览器页面可以用360浏览器\n> webview 调试用 chrome://inspect/version#devices\n> 调试本地代码， 用charles代理工具，手机配置本地电脑的ip\n> 注意safari浏览器调试的时候，第一次的数据捕捉不到\n\n\n","slug":"js-mobile-h5坑总结","published":1,"date":"2017-04-23T22:53:20.000Z","updated":"2017-04-23T22:53:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ci8004zkzy6ag9rdim5","content":"<h3 id=\"localstorage和sessionStorage在safari的无痕浏览模式报错\"><a href=\"#localstorage和sessionStorage在safari的无痕浏览模式报错\" class=\"headerlink\" title=\"localstorage和sessionStorage在safari的无痕浏览模式报错\"></a>localstorage和sessionStorage在safari的无痕浏览模式报错</h3><blockquote>\n<p>在localstorage.setItem() 报错， localstorage.getItem(), localstorage.removeItem() 会忽略;</p>\n</blockquote>\n<p>解决方案： </p>\n<blockquote>\n<p>   1.如果信息量小可以用cookie或者通过url方式</p>\n<ol>\n<li>后端写个存取数据的公用的接口</li>\n<li>迫不得已的情况下启动单页，存到内存里（要是用了单页就ok了）</li>\n</ol>\n</blockquote>\n<h3 id=\"移动端浏览器300毫秒点击延时\"><a href=\"#移动端浏览器300毫秒点击延时\" class=\"headerlink\" title=\"移动端浏览器300毫秒点击延时\"></a>移动端浏览器300毫秒点击延时</h3><p>解决方案：</p>\n<blockquote>\n<p>   1.禁止页面缩放<br>   2.touchend 事件之后触发一个click事件，再取消300毫秒之后的事件</p>\n</blockquote>\n<h3 id=\"transition闪屏\"><a href=\"#transition闪屏\" class=\"headerlink\" title=\"transition闪屏\"></a>transition闪屏</h3><p>解决方案：</p>\n<blockquote>\n<p>-webkit-transform-style: preserve-3d; //3d加速效果<br>-webkit-backface-visibility: hidden; //页面转换的时候隐藏</p>\n</blockquote>\n<p>优化：</p>\n<blockquote>\n<ol>\n<li>overflow: scroll | auto, 滚动时使用原生效果：-webkit-overflow-scrolling: touch<br>2.设置css属性 -webkit-user-select:none; 控制用户不可选择文字<br>3.通过设置css属性 -webkit-tap-highlight-color: rgba(0, 0, 0, 0);取消掉手机端webkit浏览器 点击按钮或超链接之类的 默认灰色背景色</li>\n</ol>\n</blockquote>\n<h3 id=\"H5的奇特技巧\"><a href=\"#H5的奇特技巧\" class=\"headerlink\" title=\"H5的奇特技巧\"></a>H5的奇特技巧</h3><blockquote>\n<p>做弹窗的时候你会发现，当弹窗内容里面的组件会根据周边元素定位的时候且你的遮罩刚开始是设置为none的时候，<br>之后当组件显示，发现页面乱了，因为组件内部前后针对的相对定位的元素不一样。</p>\n</blockquote>\n<p>解决方案</p>\n<blockquote>\n<ol>\n<li>z-index: -1 ;</li>\n<li>或则opacity：0</li>\n</ol>\n</blockquote>\n<p>注意事项:</p>\n<blockquote>\n<p>如果仅仅点击内容的关闭按钮，关闭弹窗，需要阻止冒泡</p>\n<ol>\n<li>e.preventDefault()</li>\n<li>e.target == e.currentarget</li>\n</ol>\n</blockquote>\n<h3 id=\"H5调试\"><a href=\"#H5调试\" class=\"headerlink\" title=\"H5调试\"></a>H5调试</h3><blockquote>\n<p>android调试浏览器页面可以用360浏览器<br>webview 调试用 chrome://inspect/version#devices<br>调试本地代码， 用charles代理工具，手机配置本地电脑的ip<br>注意safari浏览器调试的时候，第一次的数据捕捉不到</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"localstorage和sessionStorage在safari的无痕浏览模式报错\"><a href=\"#localstorage和sessionStorage在safari的无痕浏览模式报错\" class=\"headerlink\" title=\"localstorage和sessionStorage在safari的无痕浏览模式报错\"></a>localstorage和sessionStorage在safari的无痕浏览模式报错</h3><blockquote>\n<p>在localstorage.setItem() 报错， localstorage.getItem(), localstorage.removeItem() 会忽略;</p>\n</blockquote>\n<p>解决方案： </p>\n<blockquote>\n<p>   1.如果信息量小可以用cookie或者通过url方式</p>\n<ol>\n<li>后端写个存取数据的公用的接口</li>\n<li>迫不得已的情况下启动单页，存到内存里（要是用了单页就ok了）</li>\n</ol>\n</blockquote>\n<h3 id=\"移动端浏览器300毫秒点击延时\"><a href=\"#移动端浏览器300毫秒点击延时\" class=\"headerlink\" title=\"移动端浏览器300毫秒点击延时\"></a>移动端浏览器300毫秒点击延时</h3><p>解决方案：</p>\n<blockquote>\n<p>   1.禁止页面缩放<br>   2.touchend 事件之后触发一个click事件，再取消300毫秒之后的事件</p>\n</blockquote>\n<h3 id=\"transition闪屏\"><a href=\"#transition闪屏\" class=\"headerlink\" title=\"transition闪屏\"></a>transition闪屏</h3><p>解决方案：</p>\n<blockquote>\n<p>-webkit-transform-style: preserve-3d; //3d加速效果<br>-webkit-backface-visibility: hidden; //页面转换的时候隐藏</p>\n</blockquote>\n<p>优化：</p>\n<blockquote>\n<ol>\n<li>overflow: scroll | auto, 滚动时使用原生效果：-webkit-overflow-scrolling: touch<br>2.设置css属性 -webkit-user-select:none; 控制用户不可选择文字<br>3.通过设置css属性 -webkit-tap-highlight-color: rgba(0, 0, 0, 0);取消掉手机端webkit浏览器 点击按钮或超链接之类的 默认灰色背景色</li>\n</ol>\n</blockquote>\n<h3 id=\"H5的奇特技巧\"><a href=\"#H5的奇特技巧\" class=\"headerlink\" title=\"H5的奇特技巧\"></a>H5的奇特技巧</h3><blockquote>\n<p>做弹窗的时候你会发现，当弹窗内容里面的组件会根据周边元素定位的时候且你的遮罩刚开始是设置为none的时候，<br>之后当组件显示，发现页面乱了，因为组件内部前后针对的相对定位的元素不一样。</p>\n</blockquote>\n<p>解决方案</p>\n<blockquote>\n<ol>\n<li>z-index: -1 ;</li>\n<li>或则opacity：0</li>\n</ol>\n</blockquote>\n<p>注意事项:</p>\n<blockquote>\n<p>如果仅仅点击内容的关闭按钮，关闭弹窗，需要阻止冒泡</p>\n<ol>\n<li>e.preventDefault()</li>\n<li>e.target == e.currentarget</li>\n</ol>\n</blockquote>\n<h3 id=\"H5调试\"><a href=\"#H5调试\" class=\"headerlink\" title=\"H5调试\"></a>H5调试</h3><blockquote>\n<p>android调试浏览器页面可以用360浏览器<br>webview 调试用 chrome://inspect/version#devices<br>调试本地代码， 用charles代理工具，手机配置本地电脑的ip<br>注意safari浏览器调试的时候，第一次的数据捕捉不到</p>\n</blockquote>\n"},{"title":"使用Hybrid的心得","type":"categories","_content":"# Hybrid\n## hybrid介绍\n\n1. 我们通过JSbridge实现方法的互相调用并且传递数据。\n2. 在第一种的基础上，H5打包代码给客户端，然后客户端如果确定本地已有缓存，就不需要再通过网络请求，优化性能。\n\n在项目的迭代开发中，H5需要兼容客户端的低版本，在开发的过程中也遇到一些问题，比如H5如何做到支持客户端的低版本，如何自如的切换容器，如何做版本分支管理，如何组织一个框架等自己也有一些心得，这个持续迭代的项目让我得到很多收获，教会我如何搭建一个健壮，灵活，好维护的框架。\n\n## 项目心得\n\n### 背景\n调用native的方法和自身的方法都写到common文件中，但是公共文件的代码会分发到每个页面去，当然这将造成代码过度加载，那么问题出在哪里呢？等一下回答，再看下一个坑\n\n### 版本控制遇到的坑\n在开发的过程中，我们发现在客户端1.1版本的旧容器提供了很多方法给H5用，但当版本升级到1.4版本的时候，换了个新容器，那么H5调用1.4新容器的方法的时候，首先native就需要兼容以前1.1旧容器的老方法，但是为了满足老版本的用户，H5也要兼容老版本。\n\n### 暂时解决方案\n那么H5可以有两种方案：\n1. 重新拉个分支，维护1.1版本，然后1.4采用另外一套代码。\n2. native传个版本号给H5，H5根据版本号，自己指定调用的方法。\n显然采用第二种貌似更优，但是问题又来了，我们判断版本管理的代码是写到公共文件的，如果统一版本控制的代码，会让项目的其他员原来已经上线的代码模块受到影响，虽然你会说改了公共代码，但是可以让公共代码打包到各自的页面中去啊，然后分模块发布，这样各个页面就不受影响了，但是这个就需要再次拉个分支了，因为你改了公共代码会影响到其他人员开发的模块。\n\n### 最终解决方案\n最终其实这以上的问题还是要归于公共基础框架封装过度，在基础的框架组件应该要做到灵活配置，比如不管是要调用web的ajax方法还是native的方法，应该精确到每个页面单独处理，而不是放到公共的基础框架中，基础框架组件应该以占位的方式让各个页面传递进去需要执行的方法，这样才符合设计模式的开闭原则。\n\n## Hybrid的优化\n那么在native上的webview有什么好的方式优化呢，比如我们如果做单页也可以在native上跑，我们跳转页面是调用native的方法还是直接有hash、history的方式，通过调用native的方法有个好处就是在IOS上手动右滑就可以返回上一个页面，而不需要点击左上角的返回按钮，这样也能达到一定的优化。\n\n# H5\nH5做的时候要确定到底使用单页还是多页，这个界定一定要选好，简单的说：当两个页面传递数据比较多的时候最好不要分开把他做成一个单页，当这个页面被其他的第三方调用比较多的时候，做成多页的形式或许更灵活。\n\n# 基本框架的搭建\n\n<img src=\"/images/基本框架.png\">\n\n\n","source":"_posts/js/mobile/基本框架的搭建.md","raw":"---\ntitle: 使用Hybrid的心得\ntype: \"categories\"\ncategories: [前端, H5]\n---\n# Hybrid\n## hybrid介绍\n\n1. 我们通过JSbridge实现方法的互相调用并且传递数据。\n2. 在第一种的基础上，H5打包代码给客户端，然后客户端如果确定本地已有缓存，就不需要再通过网络请求，优化性能。\n\n在项目的迭代开发中，H5需要兼容客户端的低版本，在开发的过程中也遇到一些问题，比如H5如何做到支持客户端的低版本，如何自如的切换容器，如何做版本分支管理，如何组织一个框架等自己也有一些心得，这个持续迭代的项目让我得到很多收获，教会我如何搭建一个健壮，灵活，好维护的框架。\n\n## 项目心得\n\n### 背景\n调用native的方法和自身的方法都写到common文件中，但是公共文件的代码会分发到每个页面去，当然这将造成代码过度加载，那么问题出在哪里呢？等一下回答，再看下一个坑\n\n### 版本控制遇到的坑\n在开发的过程中，我们发现在客户端1.1版本的旧容器提供了很多方法给H5用，但当版本升级到1.4版本的时候，换了个新容器，那么H5调用1.4新容器的方法的时候，首先native就需要兼容以前1.1旧容器的老方法，但是为了满足老版本的用户，H5也要兼容老版本。\n\n### 暂时解决方案\n那么H5可以有两种方案：\n1. 重新拉个分支，维护1.1版本，然后1.4采用另外一套代码。\n2. native传个版本号给H5，H5根据版本号，自己指定调用的方法。\n显然采用第二种貌似更优，但是问题又来了，我们判断版本管理的代码是写到公共文件的，如果统一版本控制的代码，会让项目的其他员原来已经上线的代码模块受到影响，虽然你会说改了公共代码，但是可以让公共代码打包到各自的页面中去啊，然后分模块发布，这样各个页面就不受影响了，但是这个就需要再次拉个分支了，因为你改了公共代码会影响到其他人员开发的模块。\n\n### 最终解决方案\n最终其实这以上的问题还是要归于公共基础框架封装过度，在基础的框架组件应该要做到灵活配置，比如不管是要调用web的ajax方法还是native的方法，应该精确到每个页面单独处理，而不是放到公共的基础框架中，基础框架组件应该以占位的方式让各个页面传递进去需要执行的方法，这样才符合设计模式的开闭原则。\n\n## Hybrid的优化\n那么在native上的webview有什么好的方式优化呢，比如我们如果做单页也可以在native上跑，我们跳转页面是调用native的方法还是直接有hash、history的方式，通过调用native的方法有个好处就是在IOS上手动右滑就可以返回上一个页面，而不需要点击左上角的返回按钮，这样也能达到一定的优化。\n\n# H5\nH5做的时候要确定到底使用单页还是多页，这个界定一定要选好，简单的说：当两个页面传递数据比较多的时候最好不要分开把他做成一个单页，当这个页面被其他的第三方调用比较多的时候，做成多页的形式或许更灵活。\n\n# 基本框架的搭建\n\n<img src=\"/images/基本框架.png\">\n\n\n","slug":"js-mobile-基本框架的搭建","published":1,"date":"2017-04-23T22:53:05.000Z","updated":"2017-04-23T22:53:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11ci90051kzy68hgsn8nx","content":"<h1 id=\"Hybrid\"><a href=\"#Hybrid\" class=\"headerlink\" title=\"Hybrid\"></a>Hybrid</h1><h2 id=\"hybrid介绍\"><a href=\"#hybrid介绍\" class=\"headerlink\" title=\"hybrid介绍\"></a>hybrid介绍</h2><ol>\n<li>我们通过JSbridge实现方法的互相调用并且传递数据。</li>\n<li>在第一种的基础上，H5打包代码给客户端，然后客户端如果确定本地已有缓存，就不需要再通过网络请求，优化性能。</li>\n</ol>\n<p>在项目的迭代开发中，H5需要兼容客户端的低版本，在开发的过程中也遇到一些问题，比如H5如何做到支持客户端的低版本，如何自如的切换容器，如何做版本分支管理，如何组织一个框架等自己也有一些心得，这个持续迭代的项目让我得到很多收获，教会我如何搭建一个健壮，灵活，好维护的框架。</p>\n<h2 id=\"项目心得\"><a href=\"#项目心得\" class=\"headerlink\" title=\"项目心得\"></a>项目心得</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>调用native的方法和自身的方法都写到common文件中，但是公共文件的代码会分发到每个页面去，当然这将造成代码过度加载，那么问题出在哪里呢？等一下回答，再看下一个坑</p>\n<h3 id=\"版本控制遇到的坑\"><a href=\"#版本控制遇到的坑\" class=\"headerlink\" title=\"版本控制遇到的坑\"></a>版本控制遇到的坑</h3><p>在开发的过程中，我们发现在客户端1.1版本的旧容器提供了很多方法给H5用，但当版本升级到1.4版本的时候，换了个新容器，那么H5调用1.4新容器的方法的时候，首先native就需要兼容以前1.1旧容器的老方法，但是为了满足老版本的用户，H5也要兼容老版本。</p>\n<h3 id=\"暂时解决方案\"><a href=\"#暂时解决方案\" class=\"headerlink\" title=\"暂时解决方案\"></a>暂时解决方案</h3><p>那么H5可以有两种方案：</p>\n<ol>\n<li>重新拉个分支，维护1.1版本，然后1.4采用另外一套代码。</li>\n<li>native传个版本号给H5，H5根据版本号，自己指定调用的方法。<br>显然采用第二种貌似更优，但是问题又来了，我们判断版本管理的代码是写到公共文件的，如果统一版本控制的代码，会让项目的其他员原来已经上线的代码模块受到影响，虽然你会说改了公共代码，但是可以让公共代码打包到各自的页面中去啊，然后分模块发布，这样各个页面就不受影响了，但是这个就需要再次拉个分支了，因为你改了公共代码会影响到其他人员开发的模块。</li>\n</ol>\n<h3 id=\"最终解决方案\"><a href=\"#最终解决方案\" class=\"headerlink\" title=\"最终解决方案\"></a>最终解决方案</h3><p>最终其实这以上的问题还是要归于公共基础框架封装过度，在基础的框架组件应该要做到灵活配置，比如不管是要调用web的ajax方法还是native的方法，应该精确到每个页面单独处理，而不是放到公共的基础框架中，基础框架组件应该以占位的方式让各个页面传递进去需要执行的方法，这样才符合设计模式的开闭原则。</p>\n<h2 id=\"Hybrid的优化\"><a href=\"#Hybrid的优化\" class=\"headerlink\" title=\"Hybrid的优化\"></a>Hybrid的优化</h2><p>那么在native上的webview有什么好的方式优化呢，比如我们如果做单页也可以在native上跑，我们跳转页面是调用native的方法还是直接有hash、history的方式，通过调用native的方法有个好处就是在IOS上手动右滑就可以返回上一个页面，而不需要点击左上角的返回按钮，这样也能达到一定的优化。</p>\n<h1 id=\"H5\"><a href=\"#H5\" class=\"headerlink\" title=\"H5\"></a>H5</h1><p>H5做的时候要确定到底使用单页还是多页，这个界定一定要选好，简单的说：当两个页面传递数据比较多的时候最好不要分开把他做成一个单页，当这个页面被其他的第三方调用比较多的时候，做成多页的形式或许更灵活。</p>\n<h1 id=\"基本框架的搭建\"><a href=\"#基本框架的搭建\" class=\"headerlink\" title=\"基本框架的搭建\"></a>基本框架的搭建</h1><p><img src=\"/images/基本框架.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Hybrid\"><a href=\"#Hybrid\" class=\"headerlink\" title=\"Hybrid\"></a>Hybrid</h1><h2 id=\"hybrid介绍\"><a href=\"#hybrid介绍\" class=\"headerlink\" title=\"hybrid介绍\"></a>hybrid介绍</h2><ol>\n<li>我们通过JSbridge实现方法的互相调用并且传递数据。</li>\n<li>在第一种的基础上，H5打包代码给客户端，然后客户端如果确定本地已有缓存，就不需要再通过网络请求，优化性能。</li>\n</ol>\n<p>在项目的迭代开发中，H5需要兼容客户端的低版本，在开发的过程中也遇到一些问题，比如H5如何做到支持客户端的低版本，如何自如的切换容器，如何做版本分支管理，如何组织一个框架等自己也有一些心得，这个持续迭代的项目让我得到很多收获，教会我如何搭建一个健壮，灵活，好维护的框架。</p>\n<h2 id=\"项目心得\"><a href=\"#项目心得\" class=\"headerlink\" title=\"项目心得\"></a>项目心得</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>调用native的方法和自身的方法都写到common文件中，但是公共文件的代码会分发到每个页面去，当然这将造成代码过度加载，那么问题出在哪里呢？等一下回答，再看下一个坑</p>\n<h3 id=\"版本控制遇到的坑\"><a href=\"#版本控制遇到的坑\" class=\"headerlink\" title=\"版本控制遇到的坑\"></a>版本控制遇到的坑</h3><p>在开发的过程中，我们发现在客户端1.1版本的旧容器提供了很多方法给H5用，但当版本升级到1.4版本的时候，换了个新容器，那么H5调用1.4新容器的方法的时候，首先native就需要兼容以前1.1旧容器的老方法，但是为了满足老版本的用户，H5也要兼容老版本。</p>\n<h3 id=\"暂时解决方案\"><a href=\"#暂时解决方案\" class=\"headerlink\" title=\"暂时解决方案\"></a>暂时解决方案</h3><p>那么H5可以有两种方案：</p>\n<ol>\n<li>重新拉个分支，维护1.1版本，然后1.4采用另外一套代码。</li>\n<li>native传个版本号给H5，H5根据版本号，自己指定调用的方法。<br>显然采用第二种貌似更优，但是问题又来了，我们判断版本管理的代码是写到公共文件的，如果统一版本控制的代码，会让项目的其他员原来已经上线的代码模块受到影响，虽然你会说改了公共代码，但是可以让公共代码打包到各自的页面中去啊，然后分模块发布，这样各个页面就不受影响了，但是这个就需要再次拉个分支了，因为你改了公共代码会影响到其他人员开发的模块。</li>\n</ol>\n<h3 id=\"最终解决方案\"><a href=\"#最终解决方案\" class=\"headerlink\" title=\"最终解决方案\"></a>最终解决方案</h3><p>最终其实这以上的问题还是要归于公共基础框架封装过度，在基础的框架组件应该要做到灵活配置，比如不管是要调用web的ajax方法还是native的方法，应该精确到每个页面单独处理，而不是放到公共的基础框架中，基础框架组件应该以占位的方式让各个页面传递进去需要执行的方法，这样才符合设计模式的开闭原则。</p>\n<h2 id=\"Hybrid的优化\"><a href=\"#Hybrid的优化\" class=\"headerlink\" title=\"Hybrid的优化\"></a>Hybrid的优化</h2><p>那么在native上的webview有什么好的方式优化呢，比如我们如果做单页也可以在native上跑，我们跳转页面是调用native的方法还是直接有hash、history的方式，通过调用native的方法有个好处就是在IOS上手动右滑就可以返回上一个页面，而不需要点击左上角的返回按钮，这样也能达到一定的优化。</p>\n<h1 id=\"H5\"><a href=\"#H5\" class=\"headerlink\" title=\"H5\"></a>H5</h1><p>H5做的时候要确定到底使用单页还是多页，这个界定一定要选好，简单的说：当两个页面传递数据比较多的时候最好不要分开把他做成一个单页，当这个页面被其他的第三方调用比较多的时候，做成多页的形式或许更灵活。</p>\n<h1 id=\"基本框架的搭建\"><a href=\"#基本框架的搭建\" class=\"headerlink\" title=\"基本框架的搭建\"></a>基本框架的搭建</h1><p><img src=\"/images/基本框架.png\"></p>\n"},{"title":"移动端适配方案","type":"categories","_content":"\n## 提前预知\n\n> 像素比\n[介绍](http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/)\n[介绍](https://colachan.com/post/3435)\n\n\n## 动态设置Rem\n\n```\n\tfunction reRalculate() {\n\t\tvar html = document.querySelector(\"html\");\n\t\tvar clientWidth = html.getBoundingClientRect().width;\n\t\tif(!clientWidth) return;\n\n\t\t//首先你要看设计师出多大的设计图，这里我们就用750的吧\n\t\t//其次你要保证你的fontSize > 12, 低于12px，chrome浏览器也会当做12px来算，这就会出问题\n\t\t//fontSize也不能太大，因为这样计算出来的rem就会很多小数，难道不碍眼吗，朋友们！！\n\n\t\thtml.style.fontSize = 60*(clientWidth/750) + 'px'\n\t}\n\t\n\tdocument.addEventListener('DOMContentLoaded', reRalculate)\n\twindow.addEventListener('resize', reRalculate, false)\n\twindow.addEventListener(\"orientationchange\", reRalculate);\n\n```\n\n```\n\t#sass需要提供一个基于rem的函数来进行运算\n\n\t@function rem($px, $base:60) {\n\t    @return ($px / $base) * 1rem;\n\t}\n\n```\n\n```\n\t#运用\n\t使用直接根据测量出来的大小即可（5px， 即调用rem(5))即可\n\n```\n###\n\n## 动态设置viewport\n```\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<script>\n\tvar width = (window.orientation == 90||window.orientation == -90)? window.screen.height: window.screen.width\n\tvar targetW = 320; \n\tvar scale = width / targetW;\n\tvar meta = document.createElement('meta');\n\talert(width);\n\tmeta.setAttribute('name', 'viewport');\n\tmeta.setAttribute('content', \"user-scalable=no,initial-scale=\"+scale+\",minimum-scale=\"+scale+\",maximum-scale=\"+scale);\n\tdocument.head.appendChild(meta);\n\twindow.addEventListener(\n\t\t\"orientationchange\", \n\t\tfunction() {\n\t\t\tsetTimeout(\n\t\t\t\tfunction() {\n\t\t\t\t\twindow.location.href = window.location.href;\n\t\t\t\t},\n\t\t\t\t1000\n\t\t\t);\n\t\t}\n\t);\n\twindow.addEventListener(\n\t\t\"resize\", \n\t\tfunction() {\n\t\t\tsetTimeout(\n\t\t\t\tfunction() {\n\t\t\t\t\twindow.location.href = window.location.href;\n\t\t\t\t},\n\t\t\t\t1000\n\t\t\t);\n\t\t}\n\t);\n</script>\n<title>无标题文档</title>\n<style>\n\tbody {\n\t\tmargin: 0;\n\t}\n\t#box {\n\t\twidth: 300px;\n\t\theight: 300px;\n\t\tmargin: 0 auto;\n\t\tbackground: red;\n\t}\n</style>\n</head>\n<body>\n<div id=\"box\"></div>\n</body>\n</html>\t\n```\n## 总结\n\n1.当屏幕被放得很大的时候，你会发现图片，文字也跟着变大，那解决方案是什么呢，当然是flexbox，只是兼容性还不太好，\n这样子图片文字就不会跟着屏幕变大了哟，只是图片文字间的间隙会增大而已\n2.如果引入第三方库的样式，也要基于根元素（全局变量）fontSize和viewport的scale来适配,具体哪张方案，根据自己的业务来做选择\n3.用rem的时候安卓部分机型会出现rem后面的小数点被截掉的问题\n4.如果要考虑1px像素的问题，可以直接用px\n\n","source":"_posts/js/mobile/移动端适配方案.md","raw":"---\ntitle: 移动端适配方案\ntype: \"categories\"\ncategories: [前端, H5]\n---\n\n## 提前预知\n\n> 像素比\n[介绍](http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/)\n[介绍](https://colachan.com/post/3435)\n\n\n## 动态设置Rem\n\n```\n\tfunction reRalculate() {\n\t\tvar html = document.querySelector(\"html\");\n\t\tvar clientWidth = html.getBoundingClientRect().width;\n\t\tif(!clientWidth) return;\n\n\t\t//首先你要看设计师出多大的设计图，这里我们就用750的吧\n\t\t//其次你要保证你的fontSize > 12, 低于12px，chrome浏览器也会当做12px来算，这就会出问题\n\t\t//fontSize也不能太大，因为这样计算出来的rem就会很多小数，难道不碍眼吗，朋友们！！\n\n\t\thtml.style.fontSize = 60*(clientWidth/750) + 'px'\n\t}\n\t\n\tdocument.addEventListener('DOMContentLoaded', reRalculate)\n\twindow.addEventListener('resize', reRalculate, false)\n\twindow.addEventListener(\"orientationchange\", reRalculate);\n\n```\n\n```\n\t#sass需要提供一个基于rem的函数来进行运算\n\n\t@function rem($px, $base:60) {\n\t    @return ($px / $base) * 1rem;\n\t}\n\n```\n\n```\n\t#运用\n\t使用直接根据测量出来的大小即可（5px， 即调用rem(5))即可\n\n```\n###\n\n## 动态设置viewport\n```\n<!doctype html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<script>\n\tvar width = (window.orientation == 90||window.orientation == -90)? window.screen.height: window.screen.width\n\tvar targetW = 320; \n\tvar scale = width / targetW;\n\tvar meta = document.createElement('meta');\n\talert(width);\n\tmeta.setAttribute('name', 'viewport');\n\tmeta.setAttribute('content', \"user-scalable=no,initial-scale=\"+scale+\",minimum-scale=\"+scale+\",maximum-scale=\"+scale);\n\tdocument.head.appendChild(meta);\n\twindow.addEventListener(\n\t\t\"orientationchange\", \n\t\tfunction() {\n\t\t\tsetTimeout(\n\t\t\t\tfunction() {\n\t\t\t\t\twindow.location.href = window.location.href;\n\t\t\t\t},\n\t\t\t\t1000\n\t\t\t);\n\t\t}\n\t);\n\twindow.addEventListener(\n\t\t\"resize\", \n\t\tfunction() {\n\t\t\tsetTimeout(\n\t\t\t\tfunction() {\n\t\t\t\t\twindow.location.href = window.location.href;\n\t\t\t\t},\n\t\t\t\t1000\n\t\t\t);\n\t\t}\n\t);\n</script>\n<title>无标题文档</title>\n<style>\n\tbody {\n\t\tmargin: 0;\n\t}\n\t#box {\n\t\twidth: 300px;\n\t\theight: 300px;\n\t\tmargin: 0 auto;\n\t\tbackground: red;\n\t}\n</style>\n</head>\n<body>\n<div id=\"box\"></div>\n</body>\n</html>\t\n```\n## 总结\n\n1.当屏幕被放得很大的时候，你会发现图片，文字也跟着变大，那解决方案是什么呢，当然是flexbox，只是兼容性还不太好，\n这样子图片文字就不会跟着屏幕变大了哟，只是图片文字间的间隙会增大而已\n2.如果引入第三方库的样式，也要基于根元素（全局变量）fontSize和viewport的scale来适配,具体哪张方案，根据自己的业务来做选择\n3.用rem的时候安卓部分机型会出现rem后面的小数点被截掉的问题\n4.如果要考虑1px像素的问题，可以直接用px\n\n","slug":"js-mobile-移动端适配方案","published":1,"date":"2017-04-23T22:53:10.000Z","updated":"2017-09-25T09:01:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cia0054kzy6uhppyqck","content":"<h2 id=\"提前预知\"><a href=\"#提前预知\" class=\"headerlink\" title=\"提前预知\"></a>提前预知</h2><blockquote>\n<p>像素比<br><a href=\"http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/\" target=\"_blank\" rel=\"external\">介绍</a><br><a href=\"https://colachan.com/post/3435\" target=\"_blank\" rel=\"external\">介绍</a></p>\n</blockquote>\n<h2 id=\"动态设置Rem\"><a href=\"#动态设置Rem\" class=\"headerlink\" title=\"动态设置Rem\"></a>动态设置Rem</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function reRalculate() &#123;</div><div class=\"line\">\tvar html = document.querySelector(&quot;html&quot;);</div><div class=\"line\">\tvar clientWidth = html.getBoundingClientRect().width;</div><div class=\"line\">\tif(!clientWidth) return;</div><div class=\"line\"></div><div class=\"line\">\t//首先你要看设计师出多大的设计图，这里我们就用750的吧</div><div class=\"line\">\t//其次你要保证你的fontSize &gt; 12, 低于12px，chrome浏览器也会当做12px来算，这就会出问题</div><div class=\"line\">\t//fontSize也不能太大，因为这样计算出来的rem就会很多小数，难道不碍眼吗，朋友们！！</div><div class=\"line\"></div><div class=\"line\">\thtml.style.fontSize = 60*(clientWidth/750) + &apos;px&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">document.addEventListener(&apos;DOMContentLoaded&apos;, reRalculate)</div><div class=\"line\">window.addEventListener(&apos;resize&apos;, reRalculate, false)</div><div class=\"line\">window.addEventListener(&quot;orientationchange&quot;, reRalculate);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#sass需要提供一个基于rem的函数来进行运算</div><div class=\"line\"></div><div class=\"line\">@function rem($px, $base:60) &#123;</div><div class=\"line\">    @return ($px / $base) * 1rem;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#运用</div><div class=\"line\">使用直接根据测量出来的大小即可（5px， 即调用rem(5))即可</div></pre></td></tr></table></figure>\n<p>###</p>\n<h2 id=\"动态设置viewport\"><a href=\"#动态设置viewport\" class=\"headerlink\" title=\"动态设置viewport\"></a>动态设置viewport</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!doctype html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">&lt;meta charset=&quot;utf-8&quot;&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">\tvar width = (window.orientation == 90||window.orientation == -90)? window.screen.height: window.screen.width</div><div class=\"line\">\tvar targetW = 320; </div><div class=\"line\">\tvar scale = width / targetW;</div><div class=\"line\">\tvar meta = document.createElement(&apos;meta&apos;);</div><div class=\"line\">\talert(width);</div><div class=\"line\">\tmeta.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</div><div class=\"line\">\tmeta.setAttribute(&apos;content&apos;, &quot;user-scalable=no,initial-scale=&quot;+scale+&quot;,minimum-scale=&quot;+scale+&quot;,maximum-scale=&quot;+scale);</div><div class=\"line\">\tdocument.head.appendChild(meta);</div><div class=\"line\">\twindow.addEventListener(</div><div class=\"line\">\t\t&quot;orientationchange&quot;, </div><div class=\"line\">\t\tfunction() &#123;</div><div class=\"line\">\t\t\tsetTimeout(</div><div class=\"line\">\t\t\t\tfunction() &#123;</div><div class=\"line\">\t\t\t\t\twindow.location.href = window.location.href;</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t1000</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t);</div><div class=\"line\">\twindow.addEventListener(</div><div class=\"line\">\t\t&quot;resize&quot;, </div><div class=\"line\">\t\tfunction() &#123;</div><div class=\"line\">\t\t\tsetTimeout(</div><div class=\"line\">\t\t\t\tfunction() &#123;</div><div class=\"line\">\t\t\t\t\twindow.location.href = window.location.href;</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t1000</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;title&gt;无标题文档&lt;/title&gt;</div><div class=\"line\">&lt;style&gt;</div><div class=\"line\">\tbody &#123;</div><div class=\"line\">\t\tmargin: 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t#box &#123;</div><div class=\"line\">\t\twidth: 300px;</div><div class=\"line\">\t\theight: 300px;</div><div class=\"line\">\t\tmargin: 0 auto;</div><div class=\"line\">\t\tbackground: red;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1.当屏幕被放得很大的时候，你会发现图片，文字也跟着变大，那解决方案是什么呢，当然是flexbox，只是兼容性还不太好，<br>这样子图片文字就不会跟着屏幕变大了哟，只是图片文字间的间隙会增大而已<br>2.如果引入第三方库的样式，也要基于根元素（全局变量）fontSize和viewport的scale来适配,具体哪张方案，根据自己的业务来做选择<br>3.用rem的时候安卓部分机型会出现rem后面的小数点被截掉的问题<br>4.如果要考虑1px像素的问题，可以直接用px</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"提前预知\"><a href=\"#提前预知\" class=\"headerlink\" title=\"提前预知\"></a>提前预知</h2><blockquote>\n<p>像素比<br><a href=\"http://www.zhangxinxu.com/wordpress/2012/08/window-devicepixelratio/\" target=\"_blank\" rel=\"external\">介绍</a><br><a href=\"https://colachan.com/post/3435\" target=\"_blank\" rel=\"external\">介绍</a></p>\n</blockquote>\n<h2 id=\"动态设置Rem\"><a href=\"#动态设置Rem\" class=\"headerlink\" title=\"动态设置Rem\"></a>动态设置Rem</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">function reRalculate() &#123;</div><div class=\"line\">\tvar html = document.querySelector(&quot;html&quot;);</div><div class=\"line\">\tvar clientWidth = html.getBoundingClientRect().width;</div><div class=\"line\">\tif(!clientWidth) return;</div><div class=\"line\"></div><div class=\"line\">\t//首先你要看设计师出多大的设计图，这里我们就用750的吧</div><div class=\"line\">\t//其次你要保证你的fontSize &gt; 12, 低于12px，chrome浏览器也会当做12px来算，这就会出问题</div><div class=\"line\">\t//fontSize也不能太大，因为这样计算出来的rem就会很多小数，难道不碍眼吗，朋友们！！</div><div class=\"line\"></div><div class=\"line\">\thtml.style.fontSize = 60*(clientWidth/750) + &apos;px&apos;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">document.addEventListener(&apos;DOMContentLoaded&apos;, reRalculate)</div><div class=\"line\">window.addEventListener(&apos;resize&apos;, reRalculate, false)</div><div class=\"line\">window.addEventListener(&quot;orientationchange&quot;, reRalculate);</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">#sass需要提供一个基于rem的函数来进行运算</div><div class=\"line\"></div><div class=\"line\">@function rem($px, $base:60) &#123;</div><div class=\"line\">    @return ($px / $base) * 1rem;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#运用</div><div class=\"line\">使用直接根据测量出来的大小即可（5px， 即调用rem(5))即可</div></pre></td></tr></table></figure>\n<p>###</p>\n<h2 id=\"动态设置viewport\"><a href=\"#动态设置viewport\" class=\"headerlink\" title=\"动态设置viewport\"></a>动态设置viewport</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!doctype html&gt;</div><div class=\"line\">&lt;html&gt;</div><div class=\"line\">&lt;head&gt;</div><div class=\"line\">&lt;meta charset=&quot;utf-8&quot;&gt;</div><div class=\"line\">&lt;script&gt;</div><div class=\"line\">\tvar width = (window.orientation == 90||window.orientation == -90)? window.screen.height: window.screen.width</div><div class=\"line\">\tvar targetW = 320; </div><div class=\"line\">\tvar scale = width / targetW;</div><div class=\"line\">\tvar meta = document.createElement(&apos;meta&apos;);</div><div class=\"line\">\talert(width);</div><div class=\"line\">\tmeta.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</div><div class=\"line\">\tmeta.setAttribute(&apos;content&apos;, &quot;user-scalable=no,initial-scale=&quot;+scale+&quot;,minimum-scale=&quot;+scale+&quot;,maximum-scale=&quot;+scale);</div><div class=\"line\">\tdocument.head.appendChild(meta);</div><div class=\"line\">\twindow.addEventListener(</div><div class=\"line\">\t\t&quot;orientationchange&quot;, </div><div class=\"line\">\t\tfunction() &#123;</div><div class=\"line\">\t\t\tsetTimeout(</div><div class=\"line\">\t\t\t\tfunction() &#123;</div><div class=\"line\">\t\t\t\t\twindow.location.href = window.location.href;</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t1000</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t);</div><div class=\"line\">\twindow.addEventListener(</div><div class=\"line\">\t\t&quot;resize&quot;, </div><div class=\"line\">\t\tfunction() &#123;</div><div class=\"line\">\t\t\tsetTimeout(</div><div class=\"line\">\t\t\t\tfunction() &#123;</div><div class=\"line\">\t\t\t\t\twindow.location.href = window.location.href;</div><div class=\"line\">\t\t\t\t&#125;,</div><div class=\"line\">\t\t\t\t1000</div><div class=\"line\">\t\t\t);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t);</div><div class=\"line\">&lt;/script&gt;</div><div class=\"line\">&lt;title&gt;无标题文档&lt;/title&gt;</div><div class=\"line\">&lt;style&gt;</div><div class=\"line\">\tbody &#123;</div><div class=\"line\">\t\tmargin: 0;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t#box &#123;</div><div class=\"line\">\t\twidth: 300px;</div><div class=\"line\">\t\theight: 300px;</div><div class=\"line\">\t\tmargin: 0 auto;</div><div class=\"line\">\t\tbackground: red;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&lt;/style&gt;</div><div class=\"line\">&lt;/head&gt;</div><div class=\"line\">&lt;body&gt;</div><div class=\"line\">&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1.当屏幕被放得很大的时候，你会发现图片，文字也跟着变大，那解决方案是什么呢，当然是flexbox，只是兼容性还不太好，<br>这样子图片文字就不会跟着屏幕变大了哟，只是图片文字间的间隙会增大而已<br>2.如果引入第三方库的样式，也要基于根元素（全局变量）fontSize和viewport的scale来适配,具体哪张方案，根据自己的业务来做选择<br>3.用rem的时候安卓部分机型会出现rem后面的小数点被截掉的问题<br>4.如果要考虑1px像素的问题，可以直接用px</p>\n"},{"title":"HybridApp踩坑之旅","type":"categories","_content":"\n# 何为JSBridge？\n构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。\n\n# 通信过程\n## JavaScript 调用 Native\n主要有两种：注入 API 和 拦截 URL SCHEME。\n\n### 注入API\n通过webview提供的接口，向JavaScript的Context（window）中注入对象或者方法，让JavaScript调用时，执行相应的Native代码逻辑\n\n### 拦截 URL SCHEME\nWeb 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。\n\n## Native 调用 JavaScript\n执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上\n\n# native是如何和h5交互细节\n(参考链接)['https://github.com/marcuswestin/WebViewJavascriptBridge']\n\n- 导入WebViewJavascriptBridge\n- UIWebView LoadURL:url 开始加载页面\n- 加载完毕，植入自执行的函数（native执行一段代码： 1.挂载到window.JavascriptBridge， 2.生成一个隐藏的iframe 3. 生成一个ObjectId, obj[obj]=callback\n- window加载完成之后,通过事件发出通知，h5收到WebViewJavascriptBridgeReady就可以调用了\n- 前端去执行一个native函数  saveCache -》 __ELE__://saveCache?objId=1&key=1&value=2 找到对应的函数\n- 通过iframe.src -> 指向Schema， 客户端就可以在一个回调函数里监听到url\n- 客户端对url进行解析，判断schema. 获取方法名， 参数\n- 就可以执行原生方法, 执行js函数，map[objId]\n\n**native是拿到确切的地址，如何操作的？**\n```\nfunction(url) {\n\n<a src='__ELE__://call?tel=123857702077'>\n\nvar isNeedle = url.indexOf('Needle://'!= 0) {\n  return;\n}\n.....\nFunction\nParams\nRun.\n\n}\n\n```\n**webview是啥？**\n```\n<Body> = RootView\n<div></div> = WebView\n</Body>\n```\n\n相互调用时封装的JS代码\n```\n/**\n * author bo.wang09@ele.me\n */\n\n'use strict'\n\n// H5调用native\nfunction send(event, data = {}, callback) {\n\n\tif(typeof event !== 'string') return false\n\n\treturn new Promise( (resolve, reject) => {\n\t\tneedle.execute(event, data, function(err, res) {\n\n\t\t\tif(err === null) {\n\t\t\t\ttypeof callback === 'function' && callback(res)\n\t\t\t\tresolve(res)\n\t\t\t} else {\n\t\t\t\treject(err)\n\t\t\t}\n\n\t\t})\n\t})\n}\n\n//native调用H5\nfunction register(handleName) {\n\treturn new Promise((resove, reject) => {\n\t    function initJS() {\n\t      \tneedle.on(handleName, function (err, res) {\n\t      \t\tif(!err) {\n\t      \t\t\tresove(res)\n\t      \t\t} else {\n\t      \t\t\treject(err)\n\t      \t\t}\n\t      \t})\n\t      \tneedle.execute('each.app.ready')\n\t    }\n\t    if(window.__needle__) {\n\t      \tinitJS()\n\t    } else {\n\t      \tdocument.addEventListener('needleReady', initJS, false)\n\t    }\n\t})\n}\n\nexport default {\n\tsend,\n\tregister\n}\n\n```\n\n# 注意要点\n1.是否页面所有DOM已经加载，必须保证h5调用方法的执行顺序在WebViewJavascriptBridgeReady挂载之后\n2.sqlite数据库的使用，不能够更改表的解构\n3.相机调用，dataURLtoBlob的时候注意把decodeFromBase64的内容的空白字符，包括空格、制表符、换页符替换成'',不然IOS上不兼容\n4.用sqlite插入数据注意插入字符串value中要加''：`INSERT INTO each_msgHealls(dataId, type, text) VALUES('${dataId}', ${type}, '${text}')`,数据冗余的时候，注意清除数据表\n5.WebViewJavascriptBridge挂载了两个方法，一个是callHandler执行函数（调用客户端），包括函数名和函数参数，最后native返回response给H5，比如拍照；一个是registerHandler监听函数(监听客户端），客户端不定时的触发任务，客户端接收到做处理，比如定位之类的需求\n6.safari浏览器默认会禁止掉cookie的存储，所以如果登陆采用cookie的方式来做的话，会引起跨域带cookie报错的问题，所以要采用token的形式来做登陆，避免影响前后端分离\n7.UIwebview和wkwebview的比较，wkwebview的性能虽好，但是容易白屏(参考)[https://zhuanlan.zhihu.com/p/24990222]\n","source":"_posts/js/mobile/hybridApp踩坑之旅.md","raw":"---\ntitle: HybridApp踩坑之旅\ntype: \"categories\"\ncategories: [前端, H5]\n---\n\n# 何为JSBridge？\n构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。\n\n# 通信过程\n## JavaScript 调用 Native\n主要有两种：注入 API 和 拦截 URL SCHEME。\n\n### 注入API\n通过webview提供的接口，向JavaScript的Context（window）中注入对象或者方法，让JavaScript调用时，执行相应的Native代码逻辑\n\n### 拦截 URL SCHEME\nWeb 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。\n\n## Native 调用 JavaScript\n执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上\n\n# native是如何和h5交互细节\n(参考链接)['https://github.com/marcuswestin/WebViewJavascriptBridge']\n\n- 导入WebViewJavascriptBridge\n- UIWebView LoadURL:url 开始加载页面\n- 加载完毕，植入自执行的函数（native执行一段代码： 1.挂载到window.JavascriptBridge， 2.生成一个隐藏的iframe 3. 生成一个ObjectId, obj[obj]=callback\n- window加载完成之后,通过事件发出通知，h5收到WebViewJavascriptBridgeReady就可以调用了\n- 前端去执行一个native函数  saveCache -》 __ELE__://saveCache?objId=1&key=1&value=2 找到对应的函数\n- 通过iframe.src -> 指向Schema， 客户端就可以在一个回调函数里监听到url\n- 客户端对url进行解析，判断schema. 获取方法名， 参数\n- 就可以执行原生方法, 执行js函数，map[objId]\n\n**native是拿到确切的地址，如何操作的？**\n```\nfunction(url) {\n\n<a src='__ELE__://call?tel=123857702077'>\n\nvar isNeedle = url.indexOf('Needle://'!= 0) {\n  return;\n}\n.....\nFunction\nParams\nRun.\n\n}\n\n```\n**webview是啥？**\n```\n<Body> = RootView\n<div></div> = WebView\n</Body>\n```\n\n相互调用时封装的JS代码\n```\n/**\n * author bo.wang09@ele.me\n */\n\n'use strict'\n\n// H5调用native\nfunction send(event, data = {}, callback) {\n\n\tif(typeof event !== 'string') return false\n\n\treturn new Promise( (resolve, reject) => {\n\t\tneedle.execute(event, data, function(err, res) {\n\n\t\t\tif(err === null) {\n\t\t\t\ttypeof callback === 'function' && callback(res)\n\t\t\t\tresolve(res)\n\t\t\t} else {\n\t\t\t\treject(err)\n\t\t\t}\n\n\t\t})\n\t})\n}\n\n//native调用H5\nfunction register(handleName) {\n\treturn new Promise((resove, reject) => {\n\t    function initJS() {\n\t      \tneedle.on(handleName, function (err, res) {\n\t      \t\tif(!err) {\n\t      \t\t\tresove(res)\n\t      \t\t} else {\n\t      \t\t\treject(err)\n\t      \t\t}\n\t      \t})\n\t      \tneedle.execute('each.app.ready')\n\t    }\n\t    if(window.__needle__) {\n\t      \tinitJS()\n\t    } else {\n\t      \tdocument.addEventListener('needleReady', initJS, false)\n\t    }\n\t})\n}\n\nexport default {\n\tsend,\n\tregister\n}\n\n```\n\n# 注意要点\n1.是否页面所有DOM已经加载，必须保证h5调用方法的执行顺序在WebViewJavascriptBridgeReady挂载之后\n2.sqlite数据库的使用，不能够更改表的解构\n3.相机调用，dataURLtoBlob的时候注意把decodeFromBase64的内容的空白字符，包括空格、制表符、换页符替换成'',不然IOS上不兼容\n4.用sqlite插入数据注意插入字符串value中要加''：`INSERT INTO each_msgHealls(dataId, type, text) VALUES('${dataId}', ${type}, '${text}')`,数据冗余的时候，注意清除数据表\n5.WebViewJavascriptBridge挂载了两个方法，一个是callHandler执行函数（调用客户端），包括函数名和函数参数，最后native返回response给H5，比如拍照；一个是registerHandler监听函数(监听客户端），客户端不定时的触发任务，客户端接收到做处理，比如定位之类的需求\n6.safari浏览器默认会禁止掉cookie的存储，所以如果登陆采用cookie的方式来做的话，会引起跨域带cookie报错的问题，所以要采用token的形式来做登陆，避免影响前后端分离\n7.UIwebview和wkwebview的比较，wkwebview的性能虽好，但是容易白屏(参考)[https://zhuanlan.zhihu.com/p/24990222]\n","slug":"js-mobile-hybridApp踩坑之旅","published":1,"date":"2017-06-13T16:38:57.000Z","updated":"2017-08-11T05:27:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cib0056kzy6bh1ws5t0","content":"<h1 id=\"何为JSBridge？\"><a href=\"#何为JSBridge？\" class=\"headerlink\" title=\"何为JSBridge？\"></a>何为JSBridge？</h1><p>构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。</p>\n<h1 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h1><h2 id=\"JavaScript-调用-Native\"><a href=\"#JavaScript-调用-Native\" class=\"headerlink\" title=\"JavaScript 调用 Native\"></a>JavaScript 调用 Native</h2><p>主要有两种：注入 API 和 拦截 URL SCHEME。</p>\n<h3 id=\"注入API\"><a href=\"#注入API\" class=\"headerlink\" title=\"注入API\"></a>注入API</h3><p>通过webview提供的接口，向JavaScript的Context（window）中注入对象或者方法，让JavaScript调用时，执行相应的Native代码逻辑</p>\n<h3 id=\"拦截-URL-SCHEME\"><a href=\"#拦截-URL-SCHEME\" class=\"headerlink\" title=\"拦截 URL SCHEME\"></a>拦截 URL SCHEME</h3><p>Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>\n<h2 id=\"Native-调用-JavaScript\"><a href=\"#Native-调用-JavaScript\" class=\"headerlink\" title=\"Native 调用 JavaScript\"></a>Native 调用 JavaScript</h2><p>执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上</p>\n<h1 id=\"native是如何和h5交互细节\"><a href=\"#native是如何和h5交互细节\" class=\"headerlink\" title=\"native是如何和h5交互细节\"></a>native是如何和h5交互细节</h1><p>(参考链接)[‘<a href=\"https://github.com/marcuswestin/WebViewJavascriptBridge\" target=\"_blank\" rel=\"external\">https://github.com/marcuswestin/WebViewJavascriptBridge</a>‘]</p>\n<ul>\n<li>导入WebViewJavascriptBridge</li>\n<li>UIWebView LoadURL:url 开始加载页面</li>\n<li>加载完毕，植入自执行的函数（native执行一段代码： 1.挂载到window.JavascriptBridge， 2.生成一个隐藏的iframe 3. 生成一个ObjectId, obj[obj]=callback</li>\n<li>window加载完成之后,通过事件发出通知，h5收到WebViewJavascriptBridgeReady就可以调用了</li>\n<li>前端去执行一个native函数  saveCache -》 <strong>ELE</strong>://saveCache?objId=1&amp;key=1&amp;value=2 找到对应的函数</li>\n<li>通过iframe.src -&gt; 指向Schema， 客户端就可以在一个回调函数里监听到url</li>\n<li>客户端对url进行解析，判断schema. 获取方法名， 参数</li>\n<li>就可以执行原生方法, 执行js函数，map[objId]</li>\n</ul>\n<p><strong>native是拿到确切的地址，如何操作的？</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(url) &#123;</div><div class=\"line\"></div><div class=\"line\">&lt;a src=&apos;__ELE__://call?tel=123857702077&apos;&gt;</div><div class=\"line\"></div><div class=\"line\">var isNeedle = url.indexOf(&apos;Needle://&apos;!= 0) &#123;</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div><div class=\"line\">.....</div><div class=\"line\">Function</div><div class=\"line\">Params</div><div class=\"line\">Run.</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>webview是啥？</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Body&gt; = RootView</div><div class=\"line\">&lt;div&gt;&lt;/div&gt; = WebView</div><div class=\"line\">&lt;/Body&gt;</div></pre></td></tr></table></figure></p>\n<p>相互调用时封装的JS代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * author bo.wang09@ele.me</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\"></div><div class=\"line\">// H5调用native</div><div class=\"line\">function send(event, data = &#123;&#125;, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">\tif(typeof event !== &apos;string&apos;) return false</div><div class=\"line\"></div><div class=\"line\">\treturn new Promise( (resolve, reject) =&gt; &#123;</div><div class=\"line\">\t\tneedle.execute(event, data, function(err, res) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif(err === null) &#123;</div><div class=\"line\">\t\t\t\ttypeof callback === &apos;function&apos; &amp;&amp; callback(res)</div><div class=\"line\">\t\t\t\tresolve(res)</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\treject(err)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//native调用H5</div><div class=\"line\">function register(handleName) &#123;</div><div class=\"line\">\treturn new Promise((resove, reject) =&gt; &#123;</div><div class=\"line\">\t    function initJS() &#123;</div><div class=\"line\">\t      \tneedle.on(handleName, function (err, res) &#123;</div><div class=\"line\">\t      \t\tif(!err) &#123;</div><div class=\"line\">\t      \t\t\tresove(res)</div><div class=\"line\">\t      \t\t&#125; else &#123;</div><div class=\"line\">\t      \t\t\treject(err)</div><div class=\"line\">\t      \t\t&#125;</div><div class=\"line\">\t      \t&#125;)</div><div class=\"line\">\t      \tneedle.execute(&apos;each.app.ready&apos;)</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    if(window.__needle__) &#123;</div><div class=\"line\">\t      \tinitJS()</div><div class=\"line\">\t    &#125; else &#123;</div><div class=\"line\">\t      \tdocument.addEventListener(&apos;needleReady&apos;, initJS, false)</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">export default &#123;</div><div class=\"line\">\tsend,</div><div class=\"line\">\tregister</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"注意要点\"><a href=\"#注意要点\" class=\"headerlink\" title=\"注意要点\"></a>注意要点</h1><p>1.是否页面所有DOM已经加载，必须保证h5调用方法的执行顺序在WebViewJavascriptBridgeReady挂载之后<br>2.sqlite数据库的使用，不能够更改表的解构<br>3.相机调用，dataURLtoBlob的时候注意把decodeFromBase64的内容的空白字符，包括空格、制表符、换页符替换成’’,不然IOS上不兼容<br>4.用sqlite插入数据注意插入字符串value中要加’’：<code>INSERT INTO each_msgHealls(dataId, type, text) VALUES(&#39;${dataId}&#39;, ${type}, &#39;${text}&#39;)</code>,数据冗余的时候，注意清除数据表<br>5.WebViewJavascriptBridge挂载了两个方法，一个是callHandler执行函数（调用客户端），包括函数名和函数参数，最后native返回response给H5，比如拍照；一个是registerHandler监听函数(监听客户端），客户端不定时的触发任务，客户端接收到做处理，比如定位之类的需求<br>6.safari浏览器默认会禁止掉cookie的存储，所以如果登陆采用cookie的方式来做的话，会引起跨域带cookie报错的问题，所以要采用token的形式来做登陆，避免影响前后端分离<br>7.UIwebview和wkwebview的比较，wkwebview的性能虽好，但是容易白屏(参考)[<a href=\"https://zhuanlan.zhihu.com/p/24990222\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/p/24990222</a>]</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"何为JSBridge？\"><a href=\"#何为JSBridge？\" class=\"headerlink\" title=\"何为JSBridge？\"></a>何为JSBridge？</h1><p>构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。</p>\n<h1 id=\"通信过程\"><a href=\"#通信过程\" class=\"headerlink\" title=\"通信过程\"></a>通信过程</h1><h2 id=\"JavaScript-调用-Native\"><a href=\"#JavaScript-调用-Native\" class=\"headerlink\" title=\"JavaScript 调用 Native\"></a>JavaScript 调用 Native</h2><p>主要有两种：注入 API 和 拦截 URL SCHEME。</p>\n<h3 id=\"注入API\"><a href=\"#注入API\" class=\"headerlink\" title=\"注入API\"></a>注入API</h3><p>通过webview提供的接口，向JavaScript的Context（window）中注入对象或者方法，让JavaScript调用时，执行相应的Native代码逻辑</p>\n<h3 id=\"拦截-URL-SCHEME\"><a href=\"#拦截-URL-SCHEME\" class=\"headerlink\" title=\"拦截 URL SCHEME\"></a>拦截 URL SCHEME</h3><p>Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>\n<h2 id=\"Native-调用-JavaScript\"><a href=\"#Native-调用-JavaScript\" class=\"headerlink\" title=\"Native 调用 JavaScript\"></a>Native 调用 JavaScript</h2><p>执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上</p>\n<h1 id=\"native是如何和h5交互细节\"><a href=\"#native是如何和h5交互细节\" class=\"headerlink\" title=\"native是如何和h5交互细节\"></a>native是如何和h5交互细节</h1><p>(参考链接)[‘<a href=\"https://github.com/marcuswestin/WebViewJavascriptBridge\" target=\"_blank\" rel=\"external\">https://github.com/marcuswestin/WebViewJavascriptBridge</a>‘]</p>\n<ul>\n<li>导入WebViewJavascriptBridge</li>\n<li>UIWebView LoadURL:url 开始加载页面</li>\n<li>加载完毕，植入自执行的函数（native执行一段代码： 1.挂载到window.JavascriptBridge， 2.生成一个隐藏的iframe 3. 生成一个ObjectId, obj[obj]=callback</li>\n<li>window加载完成之后,通过事件发出通知，h5收到WebViewJavascriptBridgeReady就可以调用了</li>\n<li>前端去执行一个native函数  saveCache -》 <strong>ELE</strong>://saveCache?objId=1&amp;key=1&amp;value=2 找到对应的函数</li>\n<li>通过iframe.src -&gt; 指向Schema， 客户端就可以在一个回调函数里监听到url</li>\n<li>客户端对url进行解析，判断schema. 获取方法名， 参数</li>\n<li>就可以执行原生方法, 执行js函数，map[objId]</li>\n</ul>\n<p><strong>native是拿到确切的地址，如何操作的？</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">function(url) &#123;</div><div class=\"line\"></div><div class=\"line\">&lt;a src=&apos;__ELE__://call?tel=123857702077&apos;&gt;</div><div class=\"line\"></div><div class=\"line\">var isNeedle = url.indexOf(&apos;Needle://&apos;!= 0) &#123;</div><div class=\"line\">  return;</div><div class=\"line\">&#125;</div><div class=\"line\">.....</div><div class=\"line\">Function</div><div class=\"line\">Params</div><div class=\"line\">Run.</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><strong>webview是啥？</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;Body&gt; = RootView</div><div class=\"line\">&lt;div&gt;&lt;/div&gt; = WebView</div><div class=\"line\">&lt;/Body&gt;</div></pre></td></tr></table></figure></p>\n<p>相互调用时封装的JS代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * author bo.wang09@ele.me</div><div class=\"line\"> */</div><div class=\"line\"></div><div class=\"line\">&apos;use strict&apos;</div><div class=\"line\"></div><div class=\"line\">// H5调用native</div><div class=\"line\">function send(event, data = &#123;&#125;, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">\tif(typeof event !== &apos;string&apos;) return false</div><div class=\"line\"></div><div class=\"line\">\treturn new Promise( (resolve, reject) =&gt; &#123;</div><div class=\"line\">\t\tneedle.execute(event, data, function(err, res) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif(err === null) &#123;</div><div class=\"line\">\t\t\t\ttypeof callback === &apos;function&apos; &amp;&amp; callback(res)</div><div class=\"line\">\t\t\t\tresolve(res)</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\treject(err)</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//native调用H5</div><div class=\"line\">function register(handleName) &#123;</div><div class=\"line\">\treturn new Promise((resove, reject) =&gt; &#123;</div><div class=\"line\">\t    function initJS() &#123;</div><div class=\"line\">\t      \tneedle.on(handleName, function (err, res) &#123;</div><div class=\"line\">\t      \t\tif(!err) &#123;</div><div class=\"line\">\t      \t\t\tresove(res)</div><div class=\"line\">\t      \t\t&#125; else &#123;</div><div class=\"line\">\t      \t\t\treject(err)</div><div class=\"line\">\t      \t\t&#125;</div><div class=\"line\">\t      \t&#125;)</div><div class=\"line\">\t      \tneedle.execute(&apos;each.app.ready&apos;)</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t    if(window.__needle__) &#123;</div><div class=\"line\">\t      \tinitJS()</div><div class=\"line\">\t    &#125; else &#123;</div><div class=\"line\">\t      \tdocument.addEventListener(&apos;needleReady&apos;, initJS, false)</div><div class=\"line\">\t    &#125;</div><div class=\"line\">\t&#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">export default &#123;</div><div class=\"line\">\tsend,</div><div class=\"line\">\tregister</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"注意要点\"><a href=\"#注意要点\" class=\"headerlink\" title=\"注意要点\"></a>注意要点</h1><p>1.是否页面所有DOM已经加载，必须保证h5调用方法的执行顺序在WebViewJavascriptBridgeReady挂载之后<br>2.sqlite数据库的使用，不能够更改表的解构<br>3.相机调用，dataURLtoBlob的时候注意把decodeFromBase64的内容的空白字符，包括空格、制表符、换页符替换成’’,不然IOS上不兼容<br>4.用sqlite插入数据注意插入字符串value中要加’’：<code>INSERT INTO each_msgHealls(dataId, type, text) VALUES(&#39;${dataId}&#39;, ${type}, &#39;${text}&#39;)</code>,数据冗余的时候，注意清除数据表<br>5.WebViewJavascriptBridge挂载了两个方法，一个是callHandler执行函数（调用客户端），包括函数名和函数参数，最后native返回response给H5，比如拍照；一个是registerHandler监听函数(监听客户端），客户端不定时的触发任务，客户端接收到做处理，比如定位之类的需求<br>6.safari浏览器默认会禁止掉cookie的存储，所以如果登陆采用cookie的方式来做的话，会引起跨域带cookie报错的问题，所以要采用token的形式来做登陆，避免影响前后端分离<br>7.UIwebview和wkwebview的比较，wkwebview的性能虽好，但是容易白屏(参考)[<a href=\"https://zhuanlan.zhihu.com/p/24990222\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/p/24990222</a>]</p>\n"},{"_content":"title: VUE初体验\nspeaker: wbcz\nurl: https://github.com/wbcz\ntransition: cards\nfiles: /css/index.css\n\n[slide data-transition=\"vertical3d\"]\n\n# vue初体验\n# 演讲者：wbcz\n\n[slide]\n\n# 先来道js基础题尝尝鲜\n\n```\nfor(var i = 0;i < 5;i++) {\n\tconsole.log(i)\n}\n```\n```\nfor(var i = 0;i < 5;i++) {\n\tsetTimeout(function() {\n\t\tconsole.log(i)\n\t}, 1000*i)\n}\n```\n```\nfor(let i = 0;i < 5;i++) {\n\tsetTimeout(function() {\n\t\tconsole.log(i)\n\t}, 1000*i)\n}\n```\n\n[slide]\n\n```\nfor(var i = 0;i < 5;i++) {\n\t(function(i) {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log(i)\n\t\t}, 1000*i)\n\t})(i)\n}\n```\n```\nfor(var i = 0;i < 5;i++) {\n\t(function(i) {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log(i)\n\t\t}, 1000*i)\n\t})()\n}\n```\n\n[slide]\n# Vue简单介绍 {:&.fadeIn}\n## 1.数据驱动的渐进式框架\n## 2.与Jquery库不同之处\n\n[slide]\n\n# 模板语法\n\n```\n<span>{{user.name}}</span>\n<span>{{user.age | number}}</span>\n<span>{{user.age + 1}}</span>\n<span>{{user.age ? user.age : 18 }}</span>\n```\n\n[slide]\n\n# 计算属性\n\n- 计算属性是基于它们的依赖进行缓存的\n\n```\n//Date.now() 不是响应式依赖\ncomputed: {\n\tnow: function () {\n\t\treturn Date.now()\n\t}\n}\n```\n```\n\t//name 值是依赖的\n\tdata() {\n\t\treturn {\n\t\t\tname: 'wbcz'\n\t\t}\n\t}\n\tcomputed: {\n\t\tnow: function () {\n\t\t\t'my name is ' + this.name\n\t\t}\n\t}\n```\n\n[slide]\n\n# computed vs watch\n\n声明式 vs 命令式\n\n```\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n```\n\n```\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n```\n\n[slide]\n# Class 与 Style 绑定\nv-bind:class=\"\"  v-bind:style=\"\"\n\n# 条件渲染 {:&.fadeIn}\nv-if v-show \n\n# 列表渲染\nv-for\n\n# 事件处理器\nv-on:click=\"say()\"\n\n# 表单控件\nv-model=\"\"\n\n[slide]\n\n# 生命周期 {:&.fadeIn}\n## beforeCreate \n## created\n## beforeMount\n## mounted \n## beforeUpdate \n## updated\n## beforeDestroy\n## destroyed","source":"_posts/js/vue/vue初体验.md","raw":"title: VUE初体验\nspeaker: wbcz\nurl: https://github.com/wbcz\ntransition: cards\nfiles: /css/index.css\n\n[slide data-transition=\"vertical3d\"]\n\n# vue初体验\n# 演讲者：wbcz\n\n[slide]\n\n# 先来道js基础题尝尝鲜\n\n```\nfor(var i = 0;i < 5;i++) {\n\tconsole.log(i)\n}\n```\n```\nfor(var i = 0;i < 5;i++) {\n\tsetTimeout(function() {\n\t\tconsole.log(i)\n\t}, 1000*i)\n}\n```\n```\nfor(let i = 0;i < 5;i++) {\n\tsetTimeout(function() {\n\t\tconsole.log(i)\n\t}, 1000*i)\n}\n```\n\n[slide]\n\n```\nfor(var i = 0;i < 5;i++) {\n\t(function(i) {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log(i)\n\t\t}, 1000*i)\n\t})(i)\n}\n```\n```\nfor(var i = 0;i < 5;i++) {\n\t(function(i) {\n\t\tsetTimeout(function() {\n\t\t\tconsole.log(i)\n\t\t}, 1000*i)\n\t})()\n}\n```\n\n[slide]\n# Vue简单介绍 {:&.fadeIn}\n## 1.数据驱动的渐进式框架\n## 2.与Jquery库不同之处\n\n[slide]\n\n# 模板语法\n\n```\n<span>{{user.name}}</span>\n<span>{{user.age | number}}</span>\n<span>{{user.age + 1}}</span>\n<span>{{user.age ? user.age : 18 }}</span>\n```\n\n[slide]\n\n# 计算属性\n\n- 计算属性是基于它们的依赖进行缓存的\n\n```\n//Date.now() 不是响应式依赖\ncomputed: {\n\tnow: function () {\n\t\treturn Date.now()\n\t}\n}\n```\n```\n\t//name 值是依赖的\n\tdata() {\n\t\treturn {\n\t\t\tname: 'wbcz'\n\t\t}\n\t}\n\tcomputed: {\n\t\tnow: function () {\n\t\t\t'my name is ' + this.name\n\t\t}\n\t}\n```\n\n[slide]\n\n# computed vs watch\n\n声明式 vs 命令式\n\n```\n  computed: {\n    fullName: function () {\n      return this.firstName + ' ' + this.lastName\n    }\n  }\n```\n\n```\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + ' ' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + ' ' + val\n    }\n  }\n```\n\n[slide]\n# Class 与 Style 绑定\nv-bind:class=\"\"  v-bind:style=\"\"\n\n# 条件渲染 {:&.fadeIn}\nv-if v-show \n\n# 列表渲染\nv-for\n\n# 事件处理器\nv-on:click=\"say()\"\n\n# 表单控件\nv-model=\"\"\n\n[slide]\n\n# 生命周期 {:&.fadeIn}\n## beforeCreate \n## created\n## beforeMount\n## mounted \n## beforeUpdate \n## updated\n## beforeDestroy\n## destroyed","slug":"js-vue-vue初体验","published":1,"date":"2017-07-31T02:26:48.000Z","updated":"2017-07-31T02:26:48.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cic0059kzy6405molz8","content":"<p>title: VUE初体验<br>speaker: wbcz<br>url: <a href=\"https://github.com/wbcz\" target=\"_blank\" rel=\"external\">https://github.com/wbcz</a><br>transition: cards<br>files: /css/index.css</p>\n<p>[slide data-transition=”vertical3d”]</p>\n<h1 id=\"vue初体验\"><a href=\"#vue初体验\" class=\"headerlink\" title=\"vue初体验\"></a>vue初体验</h1><h1 id=\"演讲者：wbcz\"><a href=\"#演讲者：wbcz\" class=\"headerlink\" title=\"演讲者：wbcz\"></a>演讲者：wbcz</h1><p>[slide]</p>\n<h1 id=\"先来道js基础题尝尝鲜\"><a href=\"#先来道js基础题尝尝鲜\" class=\"headerlink\" title=\"先来道js基础题尝尝鲜\"></a>先来道js基础题尝尝鲜</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\tconsole.log(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(i)</div><div class=\"line\">\t&#125;, 1000*i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(let i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(i)</div><div class=\"line\">\t&#125;, 1000*i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\t(function(i) &#123;</div><div class=\"line\">\t\tsetTimeout(function() &#123;</div><div class=\"line\">\t\t\tconsole.log(i)</div><div class=\"line\">\t\t&#125;, 1000*i)</div><div class=\"line\">\t&#125;)(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\t(function(i) &#123;</div><div class=\"line\">\t\tsetTimeout(function() &#123;</div><div class=\"line\">\t\t\tconsole.log(i)</div><div class=\"line\">\t\t&#125;, 1000*i)</div><div class=\"line\">\t&#125;)()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"Vue简单介绍-amp-fadeIn\"><a href=\"#Vue简单介绍-amp-fadeIn\" class=\"headerlink\" title=\"Vue简单介绍 {:&amp;.fadeIn}\"></a>Vue简单介绍 {:&amp;.fadeIn}</h1><h2 id=\"1-数据驱动的渐进式框架\"><a href=\"#1-数据驱动的渐进式框架\" class=\"headerlink\" title=\"1.数据驱动的渐进式框架\"></a>1.数据驱动的渐进式框架</h2><h2 id=\"2-与Jquery库不同之处\"><a href=\"#2-与Jquery库不同之处\" class=\"headerlink\" title=\"2.与Jquery库不同之处\"></a>2.与Jquery库不同之处</h2><p>[slide]</p>\n<h1 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</div><div class=\"line\">&lt;span&gt;&#123;&#123;user.age | number&#125;&#125;&lt;/span&gt;</div><div class=\"line\">&lt;span&gt;&#123;&#123;user.age + 1&#125;&#125;&lt;/span&gt;</div><div class=\"line\">&lt;span&gt;&#123;&#123;user.age ? user.age : 18 &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h1><ul>\n<li>计算属性是基于它们的依赖进行缓存的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Date.now() 不是响应式依赖</div><div class=\"line\">computed: &#123;</div><div class=\"line\">\tnow: function () &#123;</div><div class=\"line\">\t\treturn Date.now()</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//name 值是依赖的</div><div class=\"line\">data() &#123;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\tname: &apos;wbcz&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">computed: &#123;</div><div class=\"line\">\tnow: function () &#123;</div><div class=\"line\">\t\t&apos;my name is &apos; + this.name</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"computed-vs-watch\"><a href=\"#computed-vs-watch\" class=\"headerlink\" title=\"computed vs watch\"></a>computed vs watch</h1><p>声明式 vs 命令式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  fullName: function () &#123;</div><div class=\"line\">    return this.firstName + &apos; &apos; + this.lastName</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">watch: &#123;</div><div class=\"line\">  firstName: function (val) &#123;</div><div class=\"line\">    this.fullName = val + &apos; &apos; + this.lastName</div><div class=\"line\">  &#125;,</div><div class=\"line\">  lastName: function (val) &#123;</div><div class=\"line\">    this.fullName = this.firstName + &apos; &apos; + val</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"Class-与-Style-绑定\"><a href=\"#Class-与-Style-绑定\" class=\"headerlink\" title=\"Class 与 Style 绑定\"></a>Class 与 Style 绑定</h1><p>v-bind:class=””  v-bind:style=””</p>\n<h1 id=\"条件渲染-amp-fadeIn\"><a href=\"#条件渲染-amp-fadeIn\" class=\"headerlink\" title=\"条件渲染 {:&amp;.fadeIn}\"></a>条件渲染 {:&amp;.fadeIn}</h1><p>v-if v-show </p>\n<h1 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h1><p>v-for</p>\n<h1 id=\"事件处理器\"><a href=\"#事件处理器\" class=\"headerlink\" title=\"事件处理器\"></a>事件处理器</h1><p>v-on:click=”say()”</p>\n<h1 id=\"表单控件\"><a href=\"#表单控件\" class=\"headerlink\" title=\"表单控件\"></a>表单控件</h1><p>v-model=””</p>\n<p>[slide]</p>\n<h1 id=\"生命周期-amp-fadeIn\"><a href=\"#生命周期-amp-fadeIn\" class=\"headerlink\" title=\"生命周期 {:&amp;.fadeIn}\"></a>生命周期 {:&amp;.fadeIn}</h1><h2 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h2><h2 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h2><h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><h2 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h2><h2 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h2><h2 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h2><h2 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h2><h2 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h2>","site":{"data":{}},"excerpt":"","more":"<p>title: VUE初体验<br>speaker: wbcz<br>url: <a href=\"https://github.com/wbcz\" target=\"_blank\" rel=\"external\">https://github.com/wbcz</a><br>transition: cards<br>files: /css/index.css</p>\n<p>[slide data-transition=”vertical3d”]</p>\n<h1 id=\"vue初体验\"><a href=\"#vue初体验\" class=\"headerlink\" title=\"vue初体验\"></a>vue初体验</h1><h1 id=\"演讲者：wbcz\"><a href=\"#演讲者：wbcz\" class=\"headerlink\" title=\"演讲者：wbcz\"></a>演讲者：wbcz</h1><p>[slide]</p>\n<h1 id=\"先来道js基础题尝尝鲜\"><a href=\"#先来道js基础题尝尝鲜\" class=\"headerlink\" title=\"先来道js基础题尝尝鲜\"></a>先来道js基础题尝尝鲜</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\tconsole.log(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(i)</div><div class=\"line\">\t&#125;, 1000*i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(let i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\tsetTimeout(function() &#123;</div><div class=\"line\">\t\tconsole.log(i)</div><div class=\"line\">\t&#125;, 1000*i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\t(function(i) &#123;</div><div class=\"line\">\t\tsetTimeout(function() &#123;</div><div class=\"line\">\t\t\tconsole.log(i)</div><div class=\"line\">\t\t&#125;, 1000*i)</div><div class=\"line\">\t&#125;)(i)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">for(var i = 0;i &lt; 5;i++) &#123;</div><div class=\"line\">\t(function(i) &#123;</div><div class=\"line\">\t\tsetTimeout(function() &#123;</div><div class=\"line\">\t\t\tconsole.log(i)</div><div class=\"line\">\t\t&#125;, 1000*i)</div><div class=\"line\">\t&#125;)()</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"Vue简单介绍-amp-fadeIn\"><a href=\"#Vue简单介绍-amp-fadeIn\" class=\"headerlink\" title=\"Vue简单介绍 {:&amp;.fadeIn}\"></a>Vue简单介绍 {:&amp;.fadeIn}</h1><h2 id=\"1-数据驱动的渐进式框架\"><a href=\"#1-数据驱动的渐进式框架\" class=\"headerlink\" title=\"1.数据驱动的渐进式框架\"></a>1.数据驱动的渐进式框架</h2><h2 id=\"2-与Jquery库不同之处\"><a href=\"#2-与Jquery库不同之处\" class=\"headerlink\" title=\"2.与Jquery库不同之处\"></a>2.与Jquery库不同之处</h2><p>[slide]</p>\n<h1 id=\"模板语法\"><a href=\"#模板语法\" class=\"headerlink\" title=\"模板语法\"></a>模板语法</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;span&gt;&#123;&#123;user.name&#125;&#125;&lt;/span&gt;</div><div class=\"line\">&lt;span&gt;&#123;&#123;user.age | number&#125;&#125;&lt;/span&gt;</div><div class=\"line\">&lt;span&gt;&#123;&#123;user.age + 1&#125;&#125;&lt;/span&gt;</div><div class=\"line\">&lt;span&gt;&#123;&#123;user.age ? user.age : 18 &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h1><ul>\n<li>计算属性是基于它们的依赖进行缓存的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//Date.now() 不是响应式依赖</div><div class=\"line\">computed: &#123;</div><div class=\"line\">\tnow: function () &#123;</div><div class=\"line\">\t\treturn Date.now()</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//name 值是依赖的</div><div class=\"line\">data() &#123;</div><div class=\"line\">\treturn &#123;</div><div class=\"line\">\t\tname: &apos;wbcz&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\">computed: &#123;</div><div class=\"line\">\tnow: function () &#123;</div><div class=\"line\">\t\t&apos;my name is &apos; + this.name</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"computed-vs-watch\"><a href=\"#computed-vs-watch\" class=\"headerlink\" title=\"computed vs watch\"></a>computed vs watch</h1><p>声明式 vs 命令式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">computed: &#123;</div><div class=\"line\">  fullName: function () &#123;</div><div class=\"line\">    return this.firstName + &apos; &apos; + this.lastName</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">watch: &#123;</div><div class=\"line\">  firstName: function (val) &#123;</div><div class=\"line\">    this.fullName = val + &apos; &apos; + this.lastName</div><div class=\"line\">  &#125;,</div><div class=\"line\">  lastName: function (val) &#123;</div><div class=\"line\">    this.fullName = this.firstName + &apos; &apos; + val</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>[slide]</p>\n<h1 id=\"Class-与-Style-绑定\"><a href=\"#Class-与-Style-绑定\" class=\"headerlink\" title=\"Class 与 Style 绑定\"></a>Class 与 Style 绑定</h1><p>v-bind:class=””  v-bind:style=””</p>\n<h1 id=\"条件渲染-amp-fadeIn\"><a href=\"#条件渲染-amp-fadeIn\" class=\"headerlink\" title=\"条件渲染 {:&amp;.fadeIn}\"></a>条件渲染 {:&amp;.fadeIn}</h1><p>v-if v-show </p>\n<h1 id=\"列表渲染\"><a href=\"#列表渲染\" class=\"headerlink\" title=\"列表渲染\"></a>列表渲染</h1><p>v-for</p>\n<h1 id=\"事件处理器\"><a href=\"#事件处理器\" class=\"headerlink\" title=\"事件处理器\"></a>事件处理器</h1><p>v-on:click=”say()”</p>\n<h1 id=\"表单控件\"><a href=\"#表单控件\" class=\"headerlink\" title=\"表单控件\"></a>表单控件</h1><p>v-model=””</p>\n<p>[slide]</p>\n<h1 id=\"生命周期-amp-fadeIn\"><a href=\"#生命周期-amp-fadeIn\" class=\"headerlink\" title=\"生命周期 {:&amp;.fadeIn}\"></a>生命周期 {:&amp;.fadeIn}</h1><h2 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h2><h2 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h2><h2 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h2><h2 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h2><h2 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h2><h2 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h2><h2 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h2><h2 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h2>"},{"title":"Vue数据双向绑定浅析","type":"categories","_content":"\n# Vue数据双向绑定浅析\n>  ES5提供了一个Object.defineProperty()为其监听属性的变化\n   递归监听属性的变化\n\n```\nclass Observer {\n\n\tconstructor(data) {\n\n\t\tthis.watch ={} //要定义在前，防止后面访问不到\n\n\t\tthis.data = data\n\n\t\tthis.walk(data)\n\n\t}\n\n\twalk(obj) {\n\n\t\tlet val\n\n\t\tfor(let key in obj) {\n\n\t\t\tif(obj.hasOwnProperty(key)) {\n\n\t\t\t\tval = obj[key]\n\n\t\t\t\tif(typeof val === 'object') {\n\t\t\t\t\tnew Observer(val) //监控所有属性变化\n\t\t\t\t}\n\n\t\t\t\tthis.covert(key, val)\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcovert(key, val) {\n\n\t\tlet self = this\n\n\t\tObject.defineProperty(this.data, key, {\n\n\t\t\tenumberable: true,\n\n\t\t\tconfigurable: true,\n\n\t\t\tget() {\n\t\t\t\tconsole.log(`你访问了 ${key}`);\n\t\t\t\tconsole.log(`值是:${JSON.stringify(val)}`)\n\t\t\t\treturn val\n\t\t\t},\n\n\t\t\tset(newVal) {\n\n\t\t\t\tself.$emit(key, newVal)\n\n\t\t\t\tif (typeof newVal === 'object') {\n\t\t\t\t\tnew Observer(newVal) //如果设置的值是对对象，再次递归，防止监控不到属性的变化\n\t\t\t\t}\n\n\t\t\t\tif (newVal === val) return;\n\n\t\t\t\tval = newVal\n\t\t\t}   \n\t\t})\n\t}\n\n\t$watch(key, callback) {\n\n\t\tif(typeof callback !== 'function') throw Error('second params must a function')\n\t\t\n\t\t(this.watch[key] || (this.watch[key] = [])).push(callback)\n\t}\n\n\t$emit(key, val) {\n\t\tthis.watch[key] && this.watch[key].forEach(item =>{\n\t\t\titem(key, val)\n\t\t})\n\t}\n\n}\n\nlet obj = {\n\tname: 'wbcz',\n\tage: 10,\n\tinfo: {\n\t\tcon: 'china',\n\t\tuniversity: 'js'\n\t}\n}\n\nlet app = new Observer(obj)\n\napp.$watch('age', function(newVal) {\n\tconsole.log(`你设置了${key}, 新的值为${newVal}`);\n})\n\napp.data.name // 你访问了name, 值是:\"wbcz\"\napp.data.age = 20 //你设置了age, 新的值为20\n\n```\n\n[友情链接: 使用ES6的新特性Proxy来实现一个数据绑定实例](https://segmentfault.com/a/1190000007443611)\n\n```\nclass Mog {\n  constructor (options) {\n    this.$data = options.data\n    this.$el = options.el\n    this.$tpl = options.template\n    this._render(this.$tpl, this.$data)\n  }\n\n  $setData (dataObj, fn) {\n    let self = this\n    let once = false\n    let $d = new Proxy(dataObj, {\n      set (target, property, value) {\n        if (!once) {\n          target[property] = value\n          once = true\n          self._render(self.$tpl, self.$data)\n        }\n        return true\n      }\n    })\n    fn($d)\n  }\n\n  _render (tplString, data) {\n    document.querySelector(this.$el).innerHTML = this._replaceFun(tplString, data)\n  }\n\n  _replaceFun(str, data) {\n    let self = this\n    return str.replace(/{{([^{}]*)}}/g, (a, b) => {\n      let r = self._getObjProp(data, b);\n      console.log(a, b, r)\n      if (typeof r === 'string' || typeof r === 'number') {\n        return r\n      } else {\n        return self._getObjProp(r, b.split('.')[1])\n      }\n    })\n  }\n\n  _getObjProp (obj, propsName) {\n    let propsArr = propsName.split('.')\n    function rec(o, pName) {\n      if (!o[pName] instanceof Array && o[pName] instanceof Object) {\n        return rec(o[pName], propsArr.shift())\n      }\n      return o[pName]\n    }\n    return rec(obj, propsArr.shift())\n  }\n\n}\n\n```\n\n```\nlet template = document.querySelector('#app').innerHTML\n\nlet mog = new Mog({\n  template: template,\n  el: '#app',\n  data: {\n    name: 'mog',\n    lang: 'javascript',\n    work: 'data binding',\n    supports: ['String', 'Array', 'Object'],\n    info: {\n      author: 'Jrain',\n      jsVersion: 'Ecma2015'\n    },\n    motto: 'Every dog has his day'\n  }\n})\n\ndocument.querySelector('#set-motto').oninput = (e) => {\n  mog.$setData(mog.$data, ($d) => {\n    $d.motto = e.target.value\n  })\n}\n```\n```\n<!-- javascript -->\n\nlet template = document.querySelector('#app').innerHTML\n\nlet mog = new Mog({\n  template: template,\n  el: '#app',\n  data: {\n    name: 'mog',\n    lang: 'javascript',\n    work: 'data binding',\n    supports: ['String', 'Array', 'Object'],\n    info: {\n      author: 'Jrain',\n      jsVersion: 'Ecma2015'\n    },\n    motto: 'Every dog has his day'\n  }\n})\n\ndocument.querySelector('#set-motto').oninput = (e) => {\n  mog.$setData(mog.$data, ($d) => {\n    $d.motto = e.target.value\n  })\n}\n```\n简单的实现数据绑定\n```\nconst queuedObservers = new Set();\nconst observe = fn => queuedObservers.add(fn);\nconst observable = obj => new Proxy(obj, {\n\tset(target, key, value, recevier) {\n\t\tconst result = Reflect.set(target, key, value, recevier); \n\t\tqueuedObservers.forEach(observer => observer());\n\t\treturn result;\n\t}\n});\n```","source":"_posts/js/vue/Vue之数据双向绑定浅析.md","raw":"---\ntitle: Vue数据双向绑定浅析\ntype: \"categories\"\ncategories: [前端, JS, Vue]\n---\n\n# Vue数据双向绑定浅析\n>  ES5提供了一个Object.defineProperty()为其监听属性的变化\n   递归监听属性的变化\n\n```\nclass Observer {\n\n\tconstructor(data) {\n\n\t\tthis.watch ={} //要定义在前，防止后面访问不到\n\n\t\tthis.data = data\n\n\t\tthis.walk(data)\n\n\t}\n\n\twalk(obj) {\n\n\t\tlet val\n\n\t\tfor(let key in obj) {\n\n\t\t\tif(obj.hasOwnProperty(key)) {\n\n\t\t\t\tval = obj[key]\n\n\t\t\t\tif(typeof val === 'object') {\n\t\t\t\t\tnew Observer(val) //监控所有属性变化\n\t\t\t\t}\n\n\t\t\t\tthis.covert(key, val)\n\n\t\t\t}\n\t\t}\n\t}\n\n\tcovert(key, val) {\n\n\t\tlet self = this\n\n\t\tObject.defineProperty(this.data, key, {\n\n\t\t\tenumberable: true,\n\n\t\t\tconfigurable: true,\n\n\t\t\tget() {\n\t\t\t\tconsole.log(`你访问了 ${key}`);\n\t\t\t\tconsole.log(`值是:${JSON.stringify(val)}`)\n\t\t\t\treturn val\n\t\t\t},\n\n\t\t\tset(newVal) {\n\n\t\t\t\tself.$emit(key, newVal)\n\n\t\t\t\tif (typeof newVal === 'object') {\n\t\t\t\t\tnew Observer(newVal) //如果设置的值是对对象，再次递归，防止监控不到属性的变化\n\t\t\t\t}\n\n\t\t\t\tif (newVal === val) return;\n\n\t\t\t\tval = newVal\n\t\t\t}   \n\t\t})\n\t}\n\n\t$watch(key, callback) {\n\n\t\tif(typeof callback !== 'function') throw Error('second params must a function')\n\t\t\n\t\t(this.watch[key] || (this.watch[key] = [])).push(callback)\n\t}\n\n\t$emit(key, val) {\n\t\tthis.watch[key] && this.watch[key].forEach(item =>{\n\t\t\titem(key, val)\n\t\t})\n\t}\n\n}\n\nlet obj = {\n\tname: 'wbcz',\n\tage: 10,\n\tinfo: {\n\t\tcon: 'china',\n\t\tuniversity: 'js'\n\t}\n}\n\nlet app = new Observer(obj)\n\napp.$watch('age', function(newVal) {\n\tconsole.log(`你设置了${key}, 新的值为${newVal}`);\n})\n\napp.data.name // 你访问了name, 值是:\"wbcz\"\napp.data.age = 20 //你设置了age, 新的值为20\n\n```\n\n[友情链接: 使用ES6的新特性Proxy来实现一个数据绑定实例](https://segmentfault.com/a/1190000007443611)\n\n```\nclass Mog {\n  constructor (options) {\n    this.$data = options.data\n    this.$el = options.el\n    this.$tpl = options.template\n    this._render(this.$tpl, this.$data)\n  }\n\n  $setData (dataObj, fn) {\n    let self = this\n    let once = false\n    let $d = new Proxy(dataObj, {\n      set (target, property, value) {\n        if (!once) {\n          target[property] = value\n          once = true\n          self._render(self.$tpl, self.$data)\n        }\n        return true\n      }\n    })\n    fn($d)\n  }\n\n  _render (tplString, data) {\n    document.querySelector(this.$el).innerHTML = this._replaceFun(tplString, data)\n  }\n\n  _replaceFun(str, data) {\n    let self = this\n    return str.replace(/{{([^{}]*)}}/g, (a, b) => {\n      let r = self._getObjProp(data, b);\n      console.log(a, b, r)\n      if (typeof r === 'string' || typeof r === 'number') {\n        return r\n      } else {\n        return self._getObjProp(r, b.split('.')[1])\n      }\n    })\n  }\n\n  _getObjProp (obj, propsName) {\n    let propsArr = propsName.split('.')\n    function rec(o, pName) {\n      if (!o[pName] instanceof Array && o[pName] instanceof Object) {\n        return rec(o[pName], propsArr.shift())\n      }\n      return o[pName]\n    }\n    return rec(obj, propsArr.shift())\n  }\n\n}\n\n```\n\n```\nlet template = document.querySelector('#app').innerHTML\n\nlet mog = new Mog({\n  template: template,\n  el: '#app',\n  data: {\n    name: 'mog',\n    lang: 'javascript',\n    work: 'data binding',\n    supports: ['String', 'Array', 'Object'],\n    info: {\n      author: 'Jrain',\n      jsVersion: 'Ecma2015'\n    },\n    motto: 'Every dog has his day'\n  }\n})\n\ndocument.querySelector('#set-motto').oninput = (e) => {\n  mog.$setData(mog.$data, ($d) => {\n    $d.motto = e.target.value\n  })\n}\n```\n```\n<!-- javascript -->\n\nlet template = document.querySelector('#app').innerHTML\n\nlet mog = new Mog({\n  template: template,\n  el: '#app',\n  data: {\n    name: 'mog',\n    lang: 'javascript',\n    work: 'data binding',\n    supports: ['String', 'Array', 'Object'],\n    info: {\n      author: 'Jrain',\n      jsVersion: 'Ecma2015'\n    },\n    motto: 'Every dog has his day'\n  }\n})\n\ndocument.querySelector('#set-motto').oninput = (e) => {\n  mog.$setData(mog.$data, ($d) => {\n    $d.motto = e.target.value\n  })\n}\n```\n简单的实现数据绑定\n```\nconst queuedObservers = new Set();\nconst observe = fn => queuedObservers.add(fn);\nconst observable = obj => new Proxy(obj, {\n\tset(target, key, value, recevier) {\n\t\tconst result = Reflect.set(target, key, value, recevier); \n\t\tqueuedObservers.forEach(observer => observer());\n\t\treturn result;\n\t}\n});\n```","slug":"js-vue-Vue之数据双向绑定浅析","published":1,"date":"2017-04-27T06:49:15.000Z","updated":"2017-04-27T06:49:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cie005bkzy6781qzx8f","content":"<h1 id=\"Vue数据双向绑定浅析\"><a href=\"#Vue数据双向绑定浅析\" class=\"headerlink\" title=\"Vue数据双向绑定浅析\"></a>Vue数据双向绑定浅析</h1><blockquote>\n<p> ES5提供了一个Object.defineProperty()为其监听属性的变化<br>   递归监听属性的变化</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Observer &#123;</div><div class=\"line\"></div><div class=\"line\">\tconstructor(data) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tthis.watch =&#123;&#125; //要定义在前，防止后面访问不到</div><div class=\"line\"></div><div class=\"line\">\t\tthis.data = data</div><div class=\"line\"></div><div class=\"line\">\t\tthis.walk(data)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\twalk(obj) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tlet val</div><div class=\"line\"></div><div class=\"line\">\t\tfor(let key in obj) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif(obj.hasOwnProperty(key)) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tval = obj[key]</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tif(typeof val === &apos;object&apos;) &#123;</div><div class=\"line\">\t\t\t\t\tnew Observer(val) //监控所有属性变化</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tthis.covert(key, val)</div><div class=\"line\"></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tcovert(key, val) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tlet self = this</div><div class=\"line\"></div><div class=\"line\">\t\tObject.defineProperty(this.data, key, &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tenumberable: true,</div><div class=\"line\"></div><div class=\"line\">\t\t\tconfigurable: true,</div><div class=\"line\"></div><div class=\"line\">\t\t\tget() &#123;</div><div class=\"line\">\t\t\t\tconsole.log(`你访问了 $&#123;key&#125;`);</div><div class=\"line\">\t\t\t\tconsole.log(`值是:$&#123;JSON.stringify(val)&#125;`)</div><div class=\"line\">\t\t\t\treturn val</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\"></div><div class=\"line\">\t\t\tset(newVal) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tself.$emit(key, newVal)</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tif (typeof newVal === &apos;object&apos;) &#123;</div><div class=\"line\">\t\t\t\t\tnew Observer(newVal) //如果设置的值是对对象，再次递归，防止监控不到属性的变化</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tif (newVal === val) return;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tval = newVal</div><div class=\"line\">\t\t\t&#125;   </div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t$watch(key, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif(typeof callback !== &apos;function&apos;) throw Error(&apos;second params must a function&apos;)</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t(this.watch[key] || (this.watch[key] = [])).push(callback)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t$emit(key, val) &#123;</div><div class=\"line\">\t\tthis.watch[key] &amp;&amp; this.watch[key].forEach(item =&gt;&#123;</div><div class=\"line\">\t\t\titem(key, val)</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let obj = &#123;</div><div class=\"line\">\tname: &apos;wbcz&apos;,</div><div class=\"line\">\tage: 10,</div><div class=\"line\">\tinfo: &#123;</div><div class=\"line\">\t\tcon: &apos;china&apos;,</div><div class=\"line\">\t\tuniversity: &apos;js&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let app = new Observer(obj)</div><div class=\"line\"></div><div class=\"line\">app.$watch(&apos;age&apos;, function(newVal) &#123;</div><div class=\"line\">\tconsole.log(`你设置了$&#123;key&#125;, 新的值为$&#123;newVal&#125;`);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.data.name // 你访问了name, 值是:&quot;wbcz&quot;</div><div class=\"line\">app.data.age = 20 //你设置了age, 新的值为20</div></pre></td></tr></table></figure>\n<p><a href=\"https://segmentfault.com/a/1190000007443611\" target=\"_blank\" rel=\"external\">友情链接: 使用ES6的新特性Proxy来实现一个数据绑定实例</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Mog &#123;</div><div class=\"line\">  constructor (options) &#123;</div><div class=\"line\">    this.$data = options.data</div><div class=\"line\">    this.$el = options.el</div><div class=\"line\">    this.$tpl = options.template</div><div class=\"line\">    this._render(this.$tpl, this.$data)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  $setData (dataObj, fn) &#123;</div><div class=\"line\">    let self = this</div><div class=\"line\">    let once = false</div><div class=\"line\">    let $d = new Proxy(dataObj, &#123;</div><div class=\"line\">      set (target, property, value) &#123;</div><div class=\"line\">        if (!once) &#123;</div><div class=\"line\">          target[property] = value</div><div class=\"line\">          once = true</div><div class=\"line\">          self._render(self.$tpl, self.$data)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    fn($d)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  _render (tplString, data) &#123;</div><div class=\"line\">    document.querySelector(this.$el).innerHTML = this._replaceFun(tplString, data)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  _replaceFun(str, data) &#123;</div><div class=\"line\">    let self = this</div><div class=\"line\">    return str.replace(/&#123;&#123;([^&#123;&#125;]*)&#125;&#125;/g, (a, b) =&gt; &#123;</div><div class=\"line\">      let r = self._getObjProp(data, b);</div><div class=\"line\">      console.log(a, b, r)</div><div class=\"line\">      if (typeof r === &apos;string&apos; || typeof r === &apos;number&apos;) &#123;</div><div class=\"line\">        return r</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        return self._getObjProp(r, b.split(&apos;.&apos;)[1])</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  _getObjProp (obj, propsName) &#123;</div><div class=\"line\">    let propsArr = propsName.split(&apos;.&apos;)</div><div class=\"line\">    function rec(o, pName) &#123;</div><div class=\"line\">      if (!o[pName] instanceof Array &amp;&amp; o[pName] instanceof Object) &#123;</div><div class=\"line\">        return rec(o[pName], propsArr.shift())</div><div class=\"line\">      &#125;</div><div class=\"line\">      return o[pName]</div><div class=\"line\">    &#125;</div><div class=\"line\">    return rec(obj, propsArr.shift())</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">let template = document.querySelector(&apos;#app&apos;).innerHTML</div><div class=\"line\"></div><div class=\"line\">let mog = new Mog(&#123;</div><div class=\"line\">  template: template,</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    name: &apos;mog&apos;,</div><div class=\"line\">    lang: &apos;javascript&apos;,</div><div class=\"line\">    work: &apos;data binding&apos;,</div><div class=\"line\">    supports: [&apos;String&apos;, &apos;Array&apos;, &apos;Object&apos;],</div><div class=\"line\">    info: &#123;</div><div class=\"line\">      author: &apos;Jrain&apos;,</div><div class=\"line\">      jsVersion: &apos;Ecma2015&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    motto: &apos;Every dog has his day&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">document.querySelector(&apos;#set-motto&apos;).oninput = (e) =&gt; &#123;</div><div class=\"line\">  mog.$setData(mog.$data, ($d) =&gt; &#123;</div><div class=\"line\">    $d.motto = e.target.value</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- javascript --&gt;</div><div class=\"line\"></div><div class=\"line\">let template = document.querySelector(&apos;#app&apos;).innerHTML</div><div class=\"line\"></div><div class=\"line\">let mog = new Mog(&#123;</div><div class=\"line\">  template: template,</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    name: &apos;mog&apos;,</div><div class=\"line\">    lang: &apos;javascript&apos;,</div><div class=\"line\">    work: &apos;data binding&apos;,</div><div class=\"line\">    supports: [&apos;String&apos;, &apos;Array&apos;, &apos;Object&apos;],</div><div class=\"line\">    info: &#123;</div><div class=\"line\">      author: &apos;Jrain&apos;,</div><div class=\"line\">      jsVersion: &apos;Ecma2015&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    motto: &apos;Every dog has his day&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">document.querySelector(&apos;#set-motto&apos;).oninput = (e) =&gt; &#123;</div><div class=\"line\">  mog.$setData(mog.$data, ($d) =&gt; &#123;</div><div class=\"line\">    $d.motto = e.target.value</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简单的实现数据绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">const queuedObservers = new Set();</div><div class=\"line\">const observe = fn =&gt; queuedObservers.add(fn);</div><div class=\"line\">const observable = obj =&gt; new Proxy(obj, &#123;</div><div class=\"line\">\tset(target, key, value, recevier) &#123;</div><div class=\"line\">\t\tconst result = Reflect.set(target, key, value, recevier); </div><div class=\"line\">\t\tqueuedObservers.forEach(observer =&gt; observer());</div><div class=\"line\">\t\treturn result;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue数据双向绑定浅析\"><a href=\"#Vue数据双向绑定浅析\" class=\"headerlink\" title=\"Vue数据双向绑定浅析\"></a>Vue数据双向绑定浅析</h1><blockquote>\n<p> ES5提供了一个Object.defineProperty()为其监听属性的变化<br>   递归监听属性的变化</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Observer &#123;</div><div class=\"line\"></div><div class=\"line\">\tconstructor(data) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tthis.watch =&#123;&#125; //要定义在前，防止后面访问不到</div><div class=\"line\"></div><div class=\"line\">\t\tthis.data = data</div><div class=\"line\"></div><div class=\"line\">\t\tthis.walk(data)</div><div class=\"line\"></div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\twalk(obj) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tlet val</div><div class=\"line\"></div><div class=\"line\">\t\tfor(let key in obj) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif(obj.hasOwnProperty(key)) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tval = obj[key]</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tif(typeof val === &apos;object&apos;) &#123;</div><div class=\"line\">\t\t\t\t\tnew Observer(val) //监控所有属性变化</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tthis.covert(key, val)</div><div class=\"line\"></div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\tcovert(key, val) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tlet self = this</div><div class=\"line\"></div><div class=\"line\">\t\tObject.defineProperty(this.data, key, &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\tenumberable: true,</div><div class=\"line\"></div><div class=\"line\">\t\t\tconfigurable: true,</div><div class=\"line\"></div><div class=\"line\">\t\t\tget() &#123;</div><div class=\"line\">\t\t\t\tconsole.log(`你访问了 $&#123;key&#125;`);</div><div class=\"line\">\t\t\t\tconsole.log(`值是:$&#123;JSON.stringify(val)&#125;`)</div><div class=\"line\">\t\t\t\treturn val</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\"></div><div class=\"line\">\t\t\tset(newVal) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tself.$emit(key, newVal)</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tif (typeof newVal === &apos;object&apos;) &#123;</div><div class=\"line\">\t\t\t\t\tnew Observer(newVal) //如果设置的值是对对象，再次递归，防止监控不到属性的变化</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tif (newVal === val) return;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tval = newVal</div><div class=\"line\">\t\t\t&#125;   </div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t$watch(key, callback) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif(typeof callback !== &apos;function&apos;) throw Error(&apos;second params must a function&apos;)</div><div class=\"line\">\t\t</div><div class=\"line\">\t\t(this.watch[key] || (this.watch[key] = [])).push(callback)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t$emit(key, val) &#123;</div><div class=\"line\">\t\tthis.watch[key] &amp;&amp; this.watch[key].forEach(item =&gt;&#123;</div><div class=\"line\">\t\t\titem(key, val)</div><div class=\"line\">\t\t&#125;)</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let obj = &#123;</div><div class=\"line\">\tname: &apos;wbcz&apos;,</div><div class=\"line\">\tage: 10,</div><div class=\"line\">\tinfo: &#123;</div><div class=\"line\">\t\tcon: &apos;china&apos;,</div><div class=\"line\">\t\tuniversity: &apos;js&apos;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">let app = new Observer(obj)</div><div class=\"line\"></div><div class=\"line\">app.$watch(&apos;age&apos;, function(newVal) &#123;</div><div class=\"line\">\tconsole.log(`你设置了$&#123;key&#125;, 新的值为$&#123;newVal&#125;`);</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">app.data.name // 你访问了name, 值是:&quot;wbcz&quot;</div><div class=\"line\">app.data.age = 20 //你设置了age, 新的值为20</div></pre></td></tr></table></figure>\n<p><a href=\"https://segmentfault.com/a/1190000007443611\" target=\"_blank\" rel=\"external\">友情链接: 使用ES6的新特性Proxy来实现一个数据绑定实例</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Mog &#123;</div><div class=\"line\">  constructor (options) &#123;</div><div class=\"line\">    this.$data = options.data</div><div class=\"line\">    this.$el = options.el</div><div class=\"line\">    this.$tpl = options.template</div><div class=\"line\">    this._render(this.$tpl, this.$data)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  $setData (dataObj, fn) &#123;</div><div class=\"line\">    let self = this</div><div class=\"line\">    let once = false</div><div class=\"line\">    let $d = new Proxy(dataObj, &#123;</div><div class=\"line\">      set (target, property, value) &#123;</div><div class=\"line\">        if (!once) &#123;</div><div class=\"line\">          target[property] = value</div><div class=\"line\">          once = true</div><div class=\"line\">          self._render(self.$tpl, self.$data)</div><div class=\"line\">        &#125;</div><div class=\"line\">        return true</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">    fn($d)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  _render (tplString, data) &#123;</div><div class=\"line\">    document.querySelector(this.$el).innerHTML = this._replaceFun(tplString, data)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  _replaceFun(str, data) &#123;</div><div class=\"line\">    let self = this</div><div class=\"line\">    return str.replace(/&#123;&#123;([^&#123;&#125;]*)&#125;&#125;/g, (a, b) =&gt; &#123;</div><div class=\"line\">      let r = self._getObjProp(data, b);</div><div class=\"line\">      console.log(a, b, r)</div><div class=\"line\">      if (typeof r === &apos;string&apos; || typeof r === &apos;number&apos;) &#123;</div><div class=\"line\">        return r</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        return self._getObjProp(r, b.split(&apos;.&apos;)[1])</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  _getObjProp (obj, propsName) &#123;</div><div class=\"line\">    let propsArr = propsName.split(&apos;.&apos;)</div><div class=\"line\">    function rec(o, pName) &#123;</div><div class=\"line\">      if (!o[pName] instanceof Array &amp;&amp; o[pName] instanceof Object) &#123;</div><div class=\"line\">        return rec(o[pName], propsArr.shift())</div><div class=\"line\">      &#125;</div><div class=\"line\">      return o[pName]</div><div class=\"line\">    &#125;</div><div class=\"line\">    return rec(obj, propsArr.shift())</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">let template = document.querySelector(&apos;#app&apos;).innerHTML</div><div class=\"line\"></div><div class=\"line\">let mog = new Mog(&#123;</div><div class=\"line\">  template: template,</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    name: &apos;mog&apos;,</div><div class=\"line\">    lang: &apos;javascript&apos;,</div><div class=\"line\">    work: &apos;data binding&apos;,</div><div class=\"line\">    supports: [&apos;String&apos;, &apos;Array&apos;, &apos;Object&apos;],</div><div class=\"line\">    info: &#123;</div><div class=\"line\">      author: &apos;Jrain&apos;,</div><div class=\"line\">      jsVersion: &apos;Ecma2015&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    motto: &apos;Every dog has his day&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">document.querySelector(&apos;#set-motto&apos;).oninput = (e) =&gt; &#123;</div><div class=\"line\">  mog.$setData(mog.$data, ($d) =&gt; &#123;</div><div class=\"line\">    $d.motto = e.target.value</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- javascript --&gt;</div><div class=\"line\"></div><div class=\"line\">let template = document.querySelector(&apos;#app&apos;).innerHTML</div><div class=\"line\"></div><div class=\"line\">let mog = new Mog(&#123;</div><div class=\"line\">  template: template,</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  data: &#123;</div><div class=\"line\">    name: &apos;mog&apos;,</div><div class=\"line\">    lang: &apos;javascript&apos;,</div><div class=\"line\">    work: &apos;data binding&apos;,</div><div class=\"line\">    supports: [&apos;String&apos;, &apos;Array&apos;, &apos;Object&apos;],</div><div class=\"line\">    info: &#123;</div><div class=\"line\">      author: &apos;Jrain&apos;,</div><div class=\"line\">      jsVersion: &apos;Ecma2015&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    motto: &apos;Every dog has his day&apos;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\">document.querySelector(&apos;#set-motto&apos;).oninput = (e) =&gt; &#123;</div><div class=\"line\">  mog.$setData(mog.$data, ($d) =&gt; &#123;</div><div class=\"line\">    $d.motto = e.target.value</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>简单的实现数据绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">const queuedObservers = new Set();</div><div class=\"line\">const observe = fn =&gt; queuedObservers.add(fn);</div><div class=\"line\">const observable = obj =&gt; new Proxy(obj, &#123;</div><div class=\"line\">\tset(target, key, value, recevier) &#123;</div><div class=\"line\">\t\tconst result = Reflect.set(target, key, value, recevier); </div><div class=\"line\">\t\tqueuedObservers.forEach(observer =&gt; observer());</div><div class=\"line\">\t\treturn result;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n"},{"title":"JS正则常用方法","type":"categories","_content":"## 背景\n\n1.[]里面的标点符号不需要转义\n```\nbetter: /[?+*]/ // 可读性更好\nbad: [\\?\\+\\*]\n```\n\n贪婪匹配就是在限定符后面加?\n（?=pattern）\n'Windows (?=95|98|NT|2000)' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"\n反之：\n（?!pattern)\n'Windows (?=95|98|NT|2000)' 不能匹配 \"Windows 2000\" 中的 \"Windows\" ，但能匹配 \"Windows 3.1\" 中的 \"Windows\"\n\n(?:pattern) 不获取结果的匹配，一般和（|）连用，\n比如: (countr?:y|ies)\n\n\n\n### RegExp对象的方法\n\n#### test(str) 返回布尔值\n\n#### exec(str) 返回匹配到的数组，如果匹配不到返回null\n```\n\tvar reg = /\\d/\n\tvar str = 'df123'\n\tconsole.log(reg.exec(str)) //[\"1\", index: 2, input: \"df123\"]\n\n\tvar reg = /\\d/g     //加个全局结果还是一样\n\tvar str = 'df123'\n\tconsole.log(reg.exec(str)) //[\"1\", index: 2, input: \"df123\"]\n\n\t//如何取到最后一个索引呢？\n\n\tvar result = []\n\tvar reg = /\\d/g\n\tvar str = 'df123'\n\tvar lastIndex\n\n\twhile((item = reg.exec(str)) !== null) {\n\t\tlastIndex = reg.lastIndex\n\t\tresult = result.concat(item) \n\t}\n\n\tconsole.log(result) //[\"1\", \"2\", \"3\"] \n\tconsole.log(lastIndex)\n\n\n```\n\n### String的方法\n\n#### match(/xxxx/) 返回匹配到的数组，如果匹配不到返回数组，返回null\n\n```\n\tvar reg = /\\d/\n\tvar str = 'df123'\n\tconsole.log(str.match(reg)) //[\"1\", index: 2, input: \"df123\"]\n\n\tvar reg = /\\d/g  看到与exec有什么不同了吧\n\tvar str = 'df123'\n\tconsole.log(str.match(reg)) //[\"1\", \"2\", \"3\"] \n\n\n```\n\n#### replace(/xxxx/)  返回一个新的字符串\n\n```\n\t//replace中$的替换方法\n\n\t'bbb34323WWW'.replace(/([a-z]+)(\\d+)([A-Z]+)/g, '$1'); // \"bbb\"\n\n\t//replace第二个参数为replacement，那么函数的第一个参数是其中一个匹配到的值\n\n\t'aaaa'.replace(/\\w/g, function(value) {\n    \treturn value.toUpperCase();\n\t}); // \"AAAA\"\n\n\n```\n#### search 匹配出索引\n\n```\nvar index = 'abcb'.search(/b/g) //默认会忽略g\nconsole.log(index)  //1 首次匹配成功的位置\n```\n\n### 案例\n#### 匹配html标签\n\n```\nlet re1 = new RegExp(\"<.+?>\",\"g\");//匹配html标签的正则表达式，\"g\"是搜索匹配多个符合的内容,加个？表示懒惰匹配\nlet msg = html.replace(re1,'');//执行替换成空字符\n```\n\n#### 匹配url参数（不含=，&,?)\n```\n// 1.由下可见,我们要匹配name=value\n// 2.先完成name,value的匹配 /[^?&=]/\n// 3.= 的正则就是 = \n// 4.将三部分组成参数对（name=value)的正则，三种情况（param=value、param=、param），正则：/([^?&=]+)(?:=[^?&=]*)*/g\n\nfunction parseQueryString('?foo=123&bar') {\n    var reg = /(([^?&=]+)(?:=([^?&=]*))*)/g;\n    var result = {};\n    var match;\n    var key;\n    var value;\n    while (match = reg.exec(str)) {\n        key = match[2];\n        value = match[3] || '';\n        result[key] = decodeURIComponent(value);\n    }\n    return result;\n}\n\nparseQueryString() //{foo: '123', bar: ''}\n```\n如果只匹配参数名\n```\nvar url = 'http://www.baidu.com?name=sdf&age=12&city';\n\nvar reg = /(?:\\?|&)(\\w+)={0,1}/g;\nvar matched;\nvar matches = [];\nwhile (matched = reg.exec(url)) {\n    matches.push(matched[1]);\n}\n\nconsole.log(matches);//[ 'name', 'age', 'city' ]\n\n```\n\n\n","source":"_posts/js/regExp/JS正则常用方法.md","raw":"---\ntitle: JS正则常用方法\ntype: \"categories\"\ncategories: [前端, JS, regExp]\n---\n## 背景\n\n1.[]里面的标点符号不需要转义\n```\nbetter: /[?+*]/ // 可读性更好\nbad: [\\?\\+\\*]\n```\n\n贪婪匹配就是在限定符后面加?\n（?=pattern）\n'Windows (?=95|98|NT|2000)' 能匹配 \"Windows 2000\" 中的 \"Windows\" ，但不能匹配 \"Windows 3.1\" 中的 \"Windows\"\n反之：\n（?!pattern)\n'Windows (?=95|98|NT|2000)' 不能匹配 \"Windows 2000\" 中的 \"Windows\" ，但能匹配 \"Windows 3.1\" 中的 \"Windows\"\n\n(?:pattern) 不获取结果的匹配，一般和（|）连用，\n比如: (countr?:y|ies)\n\n\n\n### RegExp对象的方法\n\n#### test(str) 返回布尔值\n\n#### exec(str) 返回匹配到的数组，如果匹配不到返回null\n```\n\tvar reg = /\\d/\n\tvar str = 'df123'\n\tconsole.log(reg.exec(str)) //[\"1\", index: 2, input: \"df123\"]\n\n\tvar reg = /\\d/g     //加个全局结果还是一样\n\tvar str = 'df123'\n\tconsole.log(reg.exec(str)) //[\"1\", index: 2, input: \"df123\"]\n\n\t//如何取到最后一个索引呢？\n\n\tvar result = []\n\tvar reg = /\\d/g\n\tvar str = 'df123'\n\tvar lastIndex\n\n\twhile((item = reg.exec(str)) !== null) {\n\t\tlastIndex = reg.lastIndex\n\t\tresult = result.concat(item) \n\t}\n\n\tconsole.log(result) //[\"1\", \"2\", \"3\"] \n\tconsole.log(lastIndex)\n\n\n```\n\n### String的方法\n\n#### match(/xxxx/) 返回匹配到的数组，如果匹配不到返回数组，返回null\n\n```\n\tvar reg = /\\d/\n\tvar str = 'df123'\n\tconsole.log(str.match(reg)) //[\"1\", index: 2, input: \"df123\"]\n\n\tvar reg = /\\d/g  看到与exec有什么不同了吧\n\tvar str = 'df123'\n\tconsole.log(str.match(reg)) //[\"1\", \"2\", \"3\"] \n\n\n```\n\n#### replace(/xxxx/)  返回一个新的字符串\n\n```\n\t//replace中$的替换方法\n\n\t'bbb34323WWW'.replace(/([a-z]+)(\\d+)([A-Z]+)/g, '$1'); // \"bbb\"\n\n\t//replace第二个参数为replacement，那么函数的第一个参数是其中一个匹配到的值\n\n\t'aaaa'.replace(/\\w/g, function(value) {\n    \treturn value.toUpperCase();\n\t}); // \"AAAA\"\n\n\n```\n#### search 匹配出索引\n\n```\nvar index = 'abcb'.search(/b/g) //默认会忽略g\nconsole.log(index)  //1 首次匹配成功的位置\n```\n\n### 案例\n#### 匹配html标签\n\n```\nlet re1 = new RegExp(\"<.+?>\",\"g\");//匹配html标签的正则表达式，\"g\"是搜索匹配多个符合的内容,加个？表示懒惰匹配\nlet msg = html.replace(re1,'');//执行替换成空字符\n```\n\n#### 匹配url参数（不含=，&,?)\n```\n// 1.由下可见,我们要匹配name=value\n// 2.先完成name,value的匹配 /[^?&=]/\n// 3.= 的正则就是 = \n// 4.将三部分组成参数对（name=value)的正则，三种情况（param=value、param=、param），正则：/([^?&=]+)(?:=[^?&=]*)*/g\n\nfunction parseQueryString('?foo=123&bar') {\n    var reg = /(([^?&=]+)(?:=([^?&=]*))*)/g;\n    var result = {};\n    var match;\n    var key;\n    var value;\n    while (match = reg.exec(str)) {\n        key = match[2];\n        value = match[3] || '';\n        result[key] = decodeURIComponent(value);\n    }\n    return result;\n}\n\nparseQueryString() //{foo: '123', bar: ''}\n```\n如果只匹配参数名\n```\nvar url = 'http://www.baidu.com?name=sdf&age=12&city';\n\nvar reg = /(?:\\?|&)(\\w+)={0,1}/g;\nvar matched;\nvar matches = [];\nwhile (matched = reg.exec(url)) {\n    matches.push(matched[1]);\n}\n\nconsole.log(matches);//[ 'name', 'age', 'city' ]\n\n```\n\n\n","slug":"js-regExp-JS正则常用方法","published":1,"date":"2017-04-23T11:01:56.000Z","updated":"2017-04-23T11:01:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cif005ekzy63biikjsh","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>1.[]里面的标点符号不需要转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">better: /[?+*]/ // 可读性更好</div><div class=\"line\">bad: [\\?\\+\\*]</div></pre></td></tr></table></figure></p>\n<p>贪婪匹配就是在限定符后面加?<br>（?=pattern）<br>‘Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”<br>反之：<br>（?!pattern)<br>‘Windows (?=95|98|NT|2000)’ 不能匹配 “Windows 2000” 中的 “Windows” ，但能匹配 “Windows 3.1” 中的 “Windows”</p>\n<p>(?:pattern) 不获取结果的匹配，一般和（|）连用，<br>比如: (countr?:y|ies)</p>\n<h3 id=\"RegExp对象的方法\"><a href=\"#RegExp对象的方法\" class=\"headerlink\" title=\"RegExp对象的方法\"></a>RegExp对象的方法</h3><h4 id=\"test-str-返回布尔值\"><a href=\"#test-str-返回布尔值\" class=\"headerlink\" title=\"test(str) 返回布尔值\"></a>test(str) 返回布尔值</h4><h4 id=\"exec-str-返回匹配到的数组，如果匹配不到返回null\"><a href=\"#exec-str-返回匹配到的数组，如果匹配不到返回null\" class=\"headerlink\" title=\"exec(str) 返回匹配到的数组，如果匹配不到返回null\"></a>exec(str) 返回匹配到的数组，如果匹配不到返回null</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var reg = /\\d/</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(reg.exec(str)) //[&quot;1&quot;, index: 2, input: &quot;df123&quot;]</div><div class=\"line\"></div><div class=\"line\">var reg = /\\d/g     //加个全局结果还是一样</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(reg.exec(str)) //[&quot;1&quot;, index: 2, input: &quot;df123&quot;]</div><div class=\"line\"></div><div class=\"line\">//如何取到最后一个索引呢？</div><div class=\"line\"></div><div class=\"line\">var result = []</div><div class=\"line\">var reg = /\\d/g</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">var lastIndex</div><div class=\"line\"></div><div class=\"line\">while((item = reg.exec(str)) !== null) &#123;</div><div class=\"line\">\tlastIndex = reg.lastIndex</div><div class=\"line\">\tresult = result.concat(item) </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(result) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] </div><div class=\"line\">console.log(lastIndex)</div></pre></td></tr></table></figure>\n<h3 id=\"String的方法\"><a href=\"#String的方法\" class=\"headerlink\" title=\"String的方法\"></a>String的方法</h3><h4 id=\"match-xxxx-返回匹配到的数组，如果匹配不到返回数组，返回null\"><a href=\"#match-xxxx-返回匹配到的数组，如果匹配不到返回数组，返回null\" class=\"headerlink\" title=\"match(/xxxx/) 返回匹配到的数组，如果匹配不到返回数组，返回null\"></a>match(/xxxx/) 返回匹配到的数组，如果匹配不到返回数组，返回null</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var reg = /\\d/</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(str.match(reg)) //[&quot;1&quot;, index: 2, input: &quot;df123&quot;]</div><div class=\"line\"></div><div class=\"line\">var reg = /\\d/g  看到与exec有什么不同了吧</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(str.match(reg)) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div></pre></td></tr></table></figure>\n<h4 id=\"replace-xxxx-返回一个新的字符串\"><a href=\"#replace-xxxx-返回一个新的字符串\" class=\"headerlink\" title=\"replace(/xxxx/)  返回一个新的字符串\"></a>replace(/xxxx/)  返回一个新的字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//replace中$的替换方法</div><div class=\"line\"></div><div class=\"line\">&apos;bbb34323WWW&apos;.replace(/([a-z]+)(\\d+)([A-Z]+)/g, &apos;$1&apos;); // &quot;bbb&quot;</div><div class=\"line\"></div><div class=\"line\">//replace第二个参数为replacement，那么函数的第一个参数是其中一个匹配到的值</div><div class=\"line\"></div><div class=\"line\">&apos;aaaa&apos;.replace(/\\w/g, function(value) &#123;</div><div class=\"line\">   \treturn value.toUpperCase();</div><div class=\"line\">&#125;); // &quot;AAAA&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"search-匹配出索引\"><a href=\"#search-匹配出索引\" class=\"headerlink\" title=\"search 匹配出索引\"></a>search 匹配出索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var index = &apos;abcb&apos;.search(/b/g) //默认会忽略g</div><div class=\"line\">console.log(index)  //1 首次匹配成功的位置</div></pre></td></tr></table></figure>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><h4 id=\"匹配html标签\"><a href=\"#匹配html标签\" class=\"headerlink\" title=\"匹配html标签\"></a>匹配html标签</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let re1 = new RegExp(&quot;&lt;.+?&gt;&quot;,&quot;g&quot;);//匹配html标签的正则表达式，&quot;g&quot;是搜索匹配多个符合的内容,加个？表示懒惰匹配</div><div class=\"line\">let msg = html.replace(re1,&apos;&apos;);//执行替换成空字符</div></pre></td></tr></table></figure>\n<h4 id=\"匹配url参数（不含-，-amp\"><a href=\"#匹配url参数（不含-，-amp\" class=\"headerlink\" title=\"匹配url参数（不含=，&amp;,?)\"></a>匹配url参数（不含=，&amp;,?)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.由下可见,我们要匹配name=value</div><div class=\"line\">// 2.先完成name,value的匹配 /[^?&amp;=]/</div><div class=\"line\">// 3.= 的正则就是 = </div><div class=\"line\">// 4.将三部分组成参数对（name=value)的正则，三种情况（param=value、param=、param），正则：/([^?&amp;=]+)(?:=[^?&amp;=]*)*/g</div><div class=\"line\"></div><div class=\"line\">function parseQueryString(&apos;?foo=123&amp;bar&apos;) &#123;</div><div class=\"line\">    var reg = /(([^?&amp;=]+)(?:=([^?&amp;=]*))*)/g;</div><div class=\"line\">    var result = &#123;&#125;;</div><div class=\"line\">    var match;</div><div class=\"line\">    var key;</div><div class=\"line\">    var value;</div><div class=\"line\">    while (match = reg.exec(str)) &#123;</div><div class=\"line\">        key = match[2];</div><div class=\"line\">        value = match[3] || &apos;&apos;;</div><div class=\"line\">        result[key] = decodeURIComponent(value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">parseQueryString() //&#123;foo: &apos;123&apos;, bar: &apos;&apos;&#125;</div></pre></td></tr></table></figure>\n<p>如果只匹配参数名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var url = &apos;http://www.baidu.com?name=sdf&amp;age=12&amp;city&apos;;</div><div class=\"line\"></div><div class=\"line\">var reg = /(?:\\?|&amp;)(\\w+)=&#123;0,1&#125;/g;</div><div class=\"line\">var matched;</div><div class=\"line\">var matches = [];</div><div class=\"line\">while (matched = reg.exec(url)) &#123;</div><div class=\"line\">    matches.push(matched[1]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(matches);//[ &apos;name&apos;, &apos;age&apos;, &apos;city&apos; ]</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>1.[]里面的标点符号不需要转义<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">better: /[?+*]/ // 可读性更好</div><div class=\"line\">bad: [\\?\\+\\*]</div></pre></td></tr></table></figure></p>\n<p>贪婪匹配就是在限定符后面加?<br>（?=pattern）<br>‘Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”<br>反之：<br>（?!pattern)<br>‘Windows (?=95|98|NT|2000)’ 不能匹配 “Windows 2000” 中的 “Windows” ，但能匹配 “Windows 3.1” 中的 “Windows”</p>\n<p>(?:pattern) 不获取结果的匹配，一般和（|）连用，<br>比如: (countr?:y|ies)</p>\n<h3 id=\"RegExp对象的方法\"><a href=\"#RegExp对象的方法\" class=\"headerlink\" title=\"RegExp对象的方法\"></a>RegExp对象的方法</h3><h4 id=\"test-str-返回布尔值\"><a href=\"#test-str-返回布尔值\" class=\"headerlink\" title=\"test(str) 返回布尔值\"></a>test(str) 返回布尔值</h4><h4 id=\"exec-str-返回匹配到的数组，如果匹配不到返回null\"><a href=\"#exec-str-返回匹配到的数组，如果匹配不到返回null\" class=\"headerlink\" title=\"exec(str) 返回匹配到的数组，如果匹配不到返回null\"></a>exec(str) 返回匹配到的数组，如果匹配不到返回null</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">var reg = /\\d/</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(reg.exec(str)) //[&quot;1&quot;, index: 2, input: &quot;df123&quot;]</div><div class=\"line\"></div><div class=\"line\">var reg = /\\d/g     //加个全局结果还是一样</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(reg.exec(str)) //[&quot;1&quot;, index: 2, input: &quot;df123&quot;]</div><div class=\"line\"></div><div class=\"line\">//如何取到最后一个索引呢？</div><div class=\"line\"></div><div class=\"line\">var result = []</div><div class=\"line\">var reg = /\\d/g</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">var lastIndex</div><div class=\"line\"></div><div class=\"line\">while((item = reg.exec(str)) !== null) &#123;</div><div class=\"line\">\tlastIndex = reg.lastIndex</div><div class=\"line\">\tresult = result.concat(item) </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(result) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] </div><div class=\"line\">console.log(lastIndex)</div></pre></td></tr></table></figure>\n<h3 id=\"String的方法\"><a href=\"#String的方法\" class=\"headerlink\" title=\"String的方法\"></a>String的方法</h3><h4 id=\"match-xxxx-返回匹配到的数组，如果匹配不到返回数组，返回null\"><a href=\"#match-xxxx-返回匹配到的数组，如果匹配不到返回数组，返回null\" class=\"headerlink\" title=\"match(/xxxx/) 返回匹配到的数组，如果匹配不到返回数组，返回null\"></a>match(/xxxx/) 返回匹配到的数组，如果匹配不到返回数组，返回null</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var reg = /\\d/</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(str.match(reg)) //[&quot;1&quot;, index: 2, input: &quot;df123&quot;]</div><div class=\"line\"></div><div class=\"line\">var reg = /\\d/g  看到与exec有什么不同了吧</div><div class=\"line\">var str = &apos;df123&apos;</div><div class=\"line\">console.log(str.match(reg)) //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div></pre></td></tr></table></figure>\n<h4 id=\"replace-xxxx-返回一个新的字符串\"><a href=\"#replace-xxxx-返回一个新的字符串\" class=\"headerlink\" title=\"replace(/xxxx/)  返回一个新的字符串\"></a>replace(/xxxx/)  返回一个新的字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//replace中$的替换方法</div><div class=\"line\"></div><div class=\"line\">&apos;bbb34323WWW&apos;.replace(/([a-z]+)(\\d+)([A-Z]+)/g, &apos;$1&apos;); // &quot;bbb&quot;</div><div class=\"line\"></div><div class=\"line\">//replace第二个参数为replacement，那么函数的第一个参数是其中一个匹配到的值</div><div class=\"line\"></div><div class=\"line\">&apos;aaaa&apos;.replace(/\\w/g, function(value) &#123;</div><div class=\"line\">   \treturn value.toUpperCase();</div><div class=\"line\">&#125;); // &quot;AAAA&quot;</div></pre></td></tr></table></figure>\n<h4 id=\"search-匹配出索引\"><a href=\"#search-匹配出索引\" class=\"headerlink\" title=\"search 匹配出索引\"></a>search 匹配出索引</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">var index = &apos;abcb&apos;.search(/b/g) //默认会忽略g</div><div class=\"line\">console.log(index)  //1 首次匹配成功的位置</div></pre></td></tr></table></figure>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><h4 id=\"匹配html标签\"><a href=\"#匹配html标签\" class=\"headerlink\" title=\"匹配html标签\"></a>匹配html标签</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">let re1 = new RegExp(&quot;&lt;.+?&gt;&quot;,&quot;g&quot;);//匹配html标签的正则表达式，&quot;g&quot;是搜索匹配多个符合的内容,加个？表示懒惰匹配</div><div class=\"line\">let msg = html.replace(re1,&apos;&apos;);//执行替换成空字符</div></pre></td></tr></table></figure>\n<h4 id=\"匹配url参数（不含-，-amp\"><a href=\"#匹配url参数（不含-，-amp\" class=\"headerlink\" title=\"匹配url参数（不含=，&amp;,?)\"></a>匹配url参数（不含=，&amp;,?)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.由下可见,我们要匹配name=value</div><div class=\"line\">// 2.先完成name,value的匹配 /[^?&amp;=]/</div><div class=\"line\">// 3.= 的正则就是 = </div><div class=\"line\">// 4.将三部分组成参数对（name=value)的正则，三种情况（param=value、param=、param），正则：/([^?&amp;=]+)(?:=[^?&amp;=]*)*/g</div><div class=\"line\"></div><div class=\"line\">function parseQueryString(&apos;?foo=123&amp;bar&apos;) &#123;</div><div class=\"line\">    var reg = /(([^?&amp;=]+)(?:=([^?&amp;=]*))*)/g;</div><div class=\"line\">    var result = &#123;&#125;;</div><div class=\"line\">    var match;</div><div class=\"line\">    var key;</div><div class=\"line\">    var value;</div><div class=\"line\">    while (match = reg.exec(str)) &#123;</div><div class=\"line\">        key = match[2];</div><div class=\"line\">        value = match[3] || &apos;&apos;;</div><div class=\"line\">        result[key] = decodeURIComponent(value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">parseQueryString() //&#123;foo: &apos;123&apos;, bar: &apos;&apos;&#125;</div></pre></td></tr></table></figure>\n<p>如果只匹配参数名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var url = &apos;http://www.baidu.com?name=sdf&amp;age=12&amp;city&apos;;</div><div class=\"line\"></div><div class=\"line\">var reg = /(?:\\?|&amp;)(\\w+)=&#123;0,1&#125;/g;</div><div class=\"line\">var matched;</div><div class=\"line\">var matches = [];</div><div class=\"line\">while (matched = reg.exec(url)) &#123;</div><div class=\"line\">    matches.push(matched[1]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">console.log(matches);//[ &apos;name&apos;, &apos;age&apos;, &apos;city&apos; ]</div></pre></td></tr></table></figure></p>\n"},{"title":"vue插件的写法","type":"categories","_content":"## 背景\nvue插件是在什么时候导入的呢？vue插件是一个全局性的东西，比如toast插件来说，vue model在第一次初始化的时候会执行里面的install方法，并且只执行一次，所以刚初始化完成以后，toast插件就已经在DOM元素当中了，只是没有显示出来而已，无论我们调用show或者hide方法，不过是修改这个实例的数据和回调方法，回调函数什么时候执行呢，由watch监听show字段来决定调用时机\n## 闭包导出install方法\n```\n(function () {\n\n  function install (Vue) {\n    Vue.YourPlugin = function (options) {\n\n    }\n  }\n// 这里为了支持CMD,AMD,CommonJs,以及script标签导入的方式\n  if (typeof exports == \"object\") {\n    module.exports = install\n  } else if (typeof define == \"function\" && define.amd) {\n    define([], function(){ return install })\n  } else if (window.Vue) {\n    Vue.use(install)\n  }\n\n})()\n```\n## 为啥导出install方法，vue就能使用了呢\n\n```\nVue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1)\n    args.unshift(this)\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args)\n    } else {\n      plugin.apply(null, args)\n    }\n    plugin.installed = true\n    return this\n  }\n```\n\n## npm publish 发布包\n\n## npm install YourPlugin\n\n[参考](http://www.jianshu.com/p/2b48887c85cc)","source":"_posts/js/vue/vue插件的写法.md","raw":"---\ntitle: vue插件的写法\ntype: \"categories\"\ncategories: [前端, JS, Vue]\n---\n## 背景\nvue插件是在什么时候导入的呢？vue插件是一个全局性的东西，比如toast插件来说，vue model在第一次初始化的时候会执行里面的install方法，并且只执行一次，所以刚初始化完成以后，toast插件就已经在DOM元素当中了，只是没有显示出来而已，无论我们调用show或者hide方法，不过是修改这个实例的数据和回调方法，回调函数什么时候执行呢，由watch监听show字段来决定调用时机\n## 闭包导出install方法\n```\n(function () {\n\n  function install (Vue) {\n    Vue.YourPlugin = function (options) {\n\n    }\n  }\n// 这里为了支持CMD,AMD,CommonJs,以及script标签导入的方式\n  if (typeof exports == \"object\") {\n    module.exports = install\n  } else if (typeof define == \"function\" && define.amd) {\n    define([], function(){ return install })\n  } else if (window.Vue) {\n    Vue.use(install)\n  }\n\n})()\n```\n## 为啥导出install方法，vue就能使用了呢\n\n```\nVue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1)\n    args.unshift(this)\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args)\n    } else {\n      plugin.apply(null, args)\n    }\n    plugin.installed = true\n    return this\n  }\n```\n\n## npm publish 发布包\n\n## npm install YourPlugin\n\n[参考](http://www.jianshu.com/p/2b48887c85cc)","slug":"js-vue-vue插件的写法","published":1,"date":"2017-04-23T11:04:57.000Z","updated":"2017-04-23T11:04:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cif005gkzy6ngl0bglo","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>vue插件是在什么时候导入的呢？vue插件是一个全局性的东西，比如toast插件来说，vue model在第一次初始化的时候会执行里面的install方法，并且只执行一次，所以刚初始化完成以后，toast插件就已经在DOM元素当中了，只是没有显示出来而已，无论我们调用show或者hide方法，不过是修改这个实例的数据和回调方法，回调函数什么时候执行呢，由watch监听show字段来决定调用时机</p>\n<h2 id=\"闭包导出install方法\"><a href=\"#闭包导出install方法\" class=\"headerlink\" title=\"闭包导出install方法\"></a>闭包导出install方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function () &#123;</div><div class=\"line\"></div><div class=\"line\">  function install (Vue) &#123;</div><div class=\"line\">    Vue.YourPlugin = function (options) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">// 这里为了支持CMD,AMD,CommonJs,以及script标签导入的方式</div><div class=\"line\">  if (typeof exports == &quot;object&quot;) &#123;</div><div class=\"line\">    module.exports = install</div><div class=\"line\">  &#125; else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) &#123;</div><div class=\"line\">    define([], function()&#123; return install &#125;)</div><div class=\"line\">  &#125; else if (window.Vue) &#123;</div><div class=\"line\">    Vue.use(install)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;)()</div></pre></td></tr></table></figure>\n<h2 id=\"为啥导出install方法，vue就能使用了呢\"><a href=\"#为啥导出install方法，vue就能使用了呢\" class=\"headerlink\" title=\"为啥导出install方法，vue就能使用了呢\"></a>为啥导出install方法，vue就能使用了呢</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.use = function (plugin) &#123;</div><div class=\"line\">    /* istanbul ignore if */</div><div class=\"line\">    if (plugin.installed) &#123;</div><div class=\"line\">      return</div><div class=\"line\">    &#125;</div><div class=\"line\">    // additional parameters</div><div class=\"line\">    var args = toArray(arguments, 1)</div><div class=\"line\">    args.unshift(this)</div><div class=\"line\">    if (typeof plugin.install === &apos;function&apos;) &#123;</div><div class=\"line\">      plugin.install.apply(plugin, args)</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      plugin.apply(null, args)</div><div class=\"line\">    &#125;</div><div class=\"line\">    plugin.installed = true</div><div class=\"line\">    return this</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"npm-publish-发布包\"><a href=\"#npm-publish-发布包\" class=\"headerlink\" title=\"npm publish 发布包\"></a>npm publish 发布包</h2><h2 id=\"npm-install-YourPlugin\"><a href=\"#npm-install-YourPlugin\" class=\"headerlink\" title=\"npm install YourPlugin\"></a>npm install YourPlugin</h2><p><a href=\"http://www.jianshu.com/p/2b48887c85cc\" target=\"_blank\" rel=\"external\">参考</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>vue插件是在什么时候导入的呢？vue插件是一个全局性的东西，比如toast插件来说，vue model在第一次初始化的时候会执行里面的install方法，并且只执行一次，所以刚初始化完成以后，toast插件就已经在DOM元素当中了，只是没有显示出来而已，无论我们调用show或者hide方法，不过是修改这个实例的数据和回调方法，回调函数什么时候执行呢，由watch监听show字段来决定调用时机</p>\n<h2 id=\"闭包导出install方法\"><a href=\"#闭包导出install方法\" class=\"headerlink\" title=\"闭包导出install方法\"></a>闭包导出install方法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">(function () &#123;</div><div class=\"line\"></div><div class=\"line\">  function install (Vue) &#123;</div><div class=\"line\">    Vue.YourPlugin = function (options) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">// 这里为了支持CMD,AMD,CommonJs,以及script标签导入的方式</div><div class=\"line\">  if (typeof exports == &quot;object&quot;) &#123;</div><div class=\"line\">    module.exports = install</div><div class=\"line\">  &#125; else if (typeof define == &quot;function&quot; &amp;&amp; define.amd) &#123;</div><div class=\"line\">    define([], function()&#123; return install &#125;)</div><div class=\"line\">  &#125; else if (window.Vue) &#123;</div><div class=\"line\">    Vue.use(install)</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;)()</div></pre></td></tr></table></figure>\n<h2 id=\"为啥导出install方法，vue就能使用了呢\"><a href=\"#为啥导出install方法，vue就能使用了呢\" class=\"headerlink\" title=\"为啥导出install方法，vue就能使用了呢\"></a>为啥导出install方法，vue就能使用了呢</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">Vue.use = function (plugin) &#123;</div><div class=\"line\">    /* istanbul ignore if */</div><div class=\"line\">    if (plugin.installed) &#123;</div><div class=\"line\">      return</div><div class=\"line\">    &#125;</div><div class=\"line\">    // additional parameters</div><div class=\"line\">    var args = toArray(arguments, 1)</div><div class=\"line\">    args.unshift(this)</div><div class=\"line\">    if (typeof plugin.install === &apos;function&apos;) &#123;</div><div class=\"line\">      plugin.install.apply(plugin, args)</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      plugin.apply(null, args)</div><div class=\"line\">    &#125;</div><div class=\"line\">    plugin.installed = true</div><div class=\"line\">    return this</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"npm-publish-发布包\"><a href=\"#npm-publish-发布包\" class=\"headerlink\" title=\"npm publish 发布包\"></a>npm publish 发布包</h2><h2 id=\"npm-install-YourPlugin\"><a href=\"#npm-install-YourPlugin\" class=\"headerlink\" title=\"npm install YourPlugin\"></a>npm install YourPlugin</h2><p><a href=\"http://www.jianshu.com/p/2b48887c85cc\" target=\"_blank\" rel=\"external\">参考</a></p>\n"},{"title":"vue组件和router的生命周期注意要点","type":"categories","_content":"\n写了这么久的vue了，发现没啥笔记，今天抽空来写个简单的博客吧\n\n## vue组件的生命周期\n\n### beforeCreate \n完成实例化，未完成数据的监测，指令的绑定等操作\n\n### created\n实例创建完成之后调用（完成数据的观测，属性方法的运算，watch事件的回调），还未开始挂载\n\n### beforeMount\n挂载前的状态，已经被初始化\n\n### mounted \n挂载结束，el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。\n只执行一次\n\n### beforeUpdate\n更新前的状态\n\n### updated\n更新后的状态\n\n### activated\nkeep-alive 组件激活的时候调用，所以如果你想不缓存这个组件，那么数据可以从这里获取，不用从created中获取,还有另外一种方式，在route的配合文件里单独配置meta信息，然后在app.vue进行处理\n\n### deactivated\n组件停用时调用\n\n### beforeDestroy\n实例销毁前调用\n\n### destroyed\n实例销毁后调用,销毁watchers, listeners,child components\n\n\n## vue-router的router的生命周期\n\n### beforeEnter\n可以用来做用户的验证\n\n### beforeRouteEnter\n处于激活状态，这个阶段你可以设置标题啊，但是必须执行一个next的回调，之后的操作才会继续进行\n这里可以开启一个loading\n\n### $route\nwatch监听$route数据，然后再调用 transition.next()进行数据的展示; \n结束loading\n\n### beforeRouteLeave \n登出验证\n\n### beforeDestroy\n当组件被禁用和移除时候调用\n\n### 总结\n生命周期简单的说就是创建前，挂载前，更新前，销毁前\n","source":"_posts/js/vue/vue组件的生命周期.md","raw":"---\ntitle: vue组件和router的生命周期注意要点\ntype: \"categories\"\ncategories: [前端, JS, Vue]\n---\n\n写了这么久的vue了，发现没啥笔记，今天抽空来写个简单的博客吧\n\n## vue组件的生命周期\n\n### beforeCreate \n完成实例化，未完成数据的监测，指令的绑定等操作\n\n### created\n实例创建完成之后调用（完成数据的观测，属性方法的运算，watch事件的回调），还未开始挂载\n\n### beforeMount\n挂载前的状态，已经被初始化\n\n### mounted \n挂载结束，el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。\n只执行一次\n\n### beforeUpdate\n更新前的状态\n\n### updated\n更新后的状态\n\n### activated\nkeep-alive 组件激活的时候调用，所以如果你想不缓存这个组件，那么数据可以从这里获取，不用从created中获取,还有另外一种方式，在route的配合文件里单独配置meta信息，然后在app.vue进行处理\n\n### deactivated\n组件停用时调用\n\n### beforeDestroy\n实例销毁前调用\n\n### destroyed\n实例销毁后调用,销毁watchers, listeners,child components\n\n\n## vue-router的router的生命周期\n\n### beforeEnter\n可以用来做用户的验证\n\n### beforeRouteEnter\n处于激活状态，这个阶段你可以设置标题啊，但是必须执行一个next的回调，之后的操作才会继续进行\n这里可以开启一个loading\n\n### $route\nwatch监听$route数据，然后再调用 transition.next()进行数据的展示; \n结束loading\n\n### beforeRouteLeave \n登出验证\n\n### beforeDestroy\n当组件被禁用和移除时候调用\n\n### 总结\n生命周期简单的说就是创建前，挂载前，更新前，销毁前\n","slug":"js-vue-vue组件的生命周期","published":1,"date":"2017-04-23T11:05:03.000Z","updated":"2017-04-23T11:05:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj8a11cih005jkzy65radeshg","content":"<p>写了这么久的vue了，发现没啥笔记，今天抽空来写个简单的博客吧</p>\n<h2 id=\"vue组件的生命周期\"><a href=\"#vue组件的生命周期\" class=\"headerlink\" title=\"vue组件的生命周期\"></a>vue组件的生命周期</h2><h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><p>完成实例化，未完成数据的监测，指令的绑定等操作</p>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><p>实例创建完成之后调用（完成数据的观测，属性方法的运算，watch事件的回调），还未开始挂载</p>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><p>挂载前的状态，已经被初始化</p>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><p>挂载结束，el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。<br>只执行一次</p>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><p>更新前的状态</p>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><p>更新后的状态</p>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><p>keep-alive 组件激活的时候调用，所以如果你想不缓存这个组件，那么数据可以从这里获取，不用从created中获取,还有另外一种方式，在route的配合文件里单独配置meta信息，然后在app.vue进行处理</p>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><p>组件停用时调用</p>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><p>实例销毁前调用</p>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><p>实例销毁后调用,销毁watchers, listeners,child components</p>\n<h2 id=\"vue-router的router的生命周期\"><a href=\"#vue-router的router的生命周期\" class=\"headerlink\" title=\"vue-router的router的生命周期\"></a>vue-router的router的生命周期</h2><h3 id=\"beforeEnter\"><a href=\"#beforeEnter\" class=\"headerlink\" title=\"beforeEnter\"></a>beforeEnter</h3><p>可以用来做用户的验证</p>\n<h3 id=\"beforeRouteEnter\"><a href=\"#beforeRouteEnter\" class=\"headerlink\" title=\"beforeRouteEnter\"></a>beforeRouteEnter</h3><p>处于激活状态，这个阶段你可以设置标题啊，但是必须执行一个next的回调，之后的操作才会继续进行<br>这里可以开启一个loading</p>\n<h3 id=\"route\"><a href=\"#route\" class=\"headerlink\" title=\"$route\"></a>$route</h3><p>watch监听$route数据，然后再调用 transition.next()进行数据的展示;<br>结束loading</p>\n<h3 id=\"beforeRouteLeave\"><a href=\"#beforeRouteLeave\" class=\"headerlink\" title=\"beforeRouteLeave\"></a>beforeRouteLeave</h3><p>登出验证</p>\n<h3 id=\"beforeDestroy-1\"><a href=\"#beforeDestroy-1\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><p>当组件被禁用和移除时候调用</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>生命周期简单的说就是创建前，挂载前，更新前，销毁前</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写了这么久的vue了，发现没啥笔记，今天抽空来写个简单的博客吧</p>\n<h2 id=\"vue组件的生命周期\"><a href=\"#vue组件的生命周期\" class=\"headerlink\" title=\"vue组件的生命周期\"></a>vue组件的生命周期</h2><h3 id=\"beforeCreate\"><a href=\"#beforeCreate\" class=\"headerlink\" title=\"beforeCreate\"></a>beforeCreate</h3><p>完成实例化，未完成数据的监测，指令的绑定等操作</p>\n<h3 id=\"created\"><a href=\"#created\" class=\"headerlink\" title=\"created\"></a>created</h3><p>实例创建完成之后调用（完成数据的观测，属性方法的运算，watch事件的回调），还未开始挂载</p>\n<h3 id=\"beforeMount\"><a href=\"#beforeMount\" class=\"headerlink\" title=\"beforeMount\"></a>beforeMount</h3><p>挂载前的状态，已经被初始化</p>\n<h3 id=\"mounted\"><a href=\"#mounted\" class=\"headerlink\" title=\"mounted\"></a>mounted</h3><p>挂载结束，el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。<br>只执行一次</p>\n<h3 id=\"beforeUpdate\"><a href=\"#beforeUpdate\" class=\"headerlink\" title=\"beforeUpdate\"></a>beforeUpdate</h3><p>更新前的状态</p>\n<h3 id=\"updated\"><a href=\"#updated\" class=\"headerlink\" title=\"updated\"></a>updated</h3><p>更新后的状态</p>\n<h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><p>keep-alive 组件激活的时候调用，所以如果你想不缓存这个组件，那么数据可以从这里获取，不用从created中获取,还有另外一种方式，在route的配合文件里单独配置meta信息，然后在app.vue进行处理</p>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><p>组件停用时调用</p>\n<h3 id=\"beforeDestroy\"><a href=\"#beforeDestroy\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><p>实例销毁前调用</p>\n<h3 id=\"destroyed\"><a href=\"#destroyed\" class=\"headerlink\" title=\"destroyed\"></a>destroyed</h3><p>实例销毁后调用,销毁watchers, listeners,child components</p>\n<h2 id=\"vue-router的router的生命周期\"><a href=\"#vue-router的router的生命周期\" class=\"headerlink\" title=\"vue-router的router的生命周期\"></a>vue-router的router的生命周期</h2><h3 id=\"beforeEnter\"><a href=\"#beforeEnter\" class=\"headerlink\" title=\"beforeEnter\"></a>beforeEnter</h3><p>可以用来做用户的验证</p>\n<h3 id=\"beforeRouteEnter\"><a href=\"#beforeRouteEnter\" class=\"headerlink\" title=\"beforeRouteEnter\"></a>beforeRouteEnter</h3><p>处于激活状态，这个阶段你可以设置标题啊，但是必须执行一个next的回调，之后的操作才会继续进行<br>这里可以开启一个loading</p>\n<h3 id=\"route\"><a href=\"#route\" class=\"headerlink\" title=\"$route\"></a>$route</h3><p>watch监听$route数据，然后再调用 transition.next()进行数据的展示;<br>结束loading</p>\n<h3 id=\"beforeRouteLeave\"><a href=\"#beforeRouteLeave\" class=\"headerlink\" title=\"beforeRouteLeave\"></a>beforeRouteLeave</h3><p>登出验证</p>\n<h3 id=\"beforeDestroy-1\"><a href=\"#beforeDestroy-1\" class=\"headerlink\" title=\"beforeDestroy\"></a>beforeDestroy</h3><p>当组件被禁用和移除时候调用</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>生命周期简单的说就是创建前，挂载前，更新前，销毁前</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj8a11cbs0005kzy6kb5oqd9h","category_id":"cj8a11cci000dkzy6fgdqosi4","_id":"cj8a11cco000jkzy6hud5wirt"},{"post_id":"cj8a11cbc0001kzy6bxso4rik","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11ccr000nkzy6ugpl7a6k"},{"post_id":"cj8a11cbc0001kzy6bxso4rik","category_id":"cj8a11ccm000gkzy68rumpzaq","_id":"cj8a11ccs000qkzy6n6njw6pa"},{"post_id":"cj8a11cbu0006kzy6jbr0cixo","category_id":"cj8a11cco000kkzy6txzssh9c","_id":"cj8a11cct000skzy6nb60tmpi"},{"post_id":"cj8a11cc80008kzy6mz8kjxow","category_id":"cj8a11cco000kkzy6txzssh9c","_id":"cj8a11ccv000wkzy67ihlyqef"},{"post_id":"cj8a11cbl0002kzy6jd701e45","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11ccz0010kzy64pkompsw"},{"post_id":"cj8a11cbl0002kzy6jd701e45","category_id":"cj8a11ccm000gkzy68rumpzaq","_id":"cj8a11cd10013kzy683m7vvnz"},{"post_id":"cj8a11ccx000zkzy6f72og3m8","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cd20015kzy6knodr4b0"},{"post_id":"cj8a11cce0009kzy6msvshfss","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cd90018kzy69wbdyytb"},{"post_id":"cj8a11ccz0011kzy60b8f91qn","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cda001akzy6cjn016u8"},{"post_id":"cj8a11cd10014kzy6u1s1ysr5","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdb001dkzy6mb2j0meu"},{"post_id":"cj8a11ccg000bkzy6oaegtw7u","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdd001fkzy6bwukrgeq"},{"post_id":"cj8a11cd20016kzy6p6d3jztv","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cde001ikzy6k2tnjv3m"},{"post_id":"cj8a11cd90019kzy6dn79boxr","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdf001kkzy6gqwcemjy"},{"post_id":"cj8a11cbq0004kzy6u0usiuji","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cdg001nkzy6q5cy40mc"},{"post_id":"cj8a11cbq0004kzy6u0usiuji","category_id":"cj8a11ccm000gkzy68rumpzaq","_id":"cj8a11cdk001pkzy6y85gppgo"},{"post_id":"cj8a11cch000ckzy6phur6gax","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdk001skzy6z7bep6zn"},{"post_id":"cj8a11cci000ekzy6ty4lnjew","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdn001ukzy6iktqs46w"},{"post_id":"cj8a11cck000fkzy68ekbz95r","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdo001xkzy61o1rf9hj"},{"post_id":"cj8a11ccm000hkzy6w9rowj69","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdp001zkzy6ihaewajx"},{"post_id":"cj8a11ccn000ikzy6986ld3z1","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdq0021kzy6se19a05o"},{"post_id":"cj8a11cco000lkzy6k63e87s6","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdr0023kzy6ofb0vt8h"},{"post_id":"cj8a11ccp000mkzy6ang8g8yg","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cds0025kzy613kgz1o4"},{"post_id":"cj8a11ccr000pkzy6nu2fh8rc","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cds0027kzy6lmomiqnc"},{"post_id":"cj8a11cct000rkzy67s648bq9","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdt0029kzy6dm2akb9u"},{"post_id":"cj8a11ccu000ukzy6zy3wlnl2","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdu002bkzy6zeihav61"},{"post_id":"cj8a11ccv000vkzy60ejg4ftx","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdv002dkzy6eo1q7pa4"},{"post_id":"cj8a11ccw000ykzy6dnhvud5m","category_id":"cj8a11ccv000xkzy6q8ci30w2","_id":"cj8a11cdw002fkzy68o83cysq"},{"post_id":"cj8a11cda001bkzy6ej9ug8kg","category_id":"cj8a11cdv002ekzy65p165twt","_id":"cj8a11cdw002hkzy638m66zgn"},{"post_id":"cj8a11cdc001ekzy6u2462dcr","category_id":"cj8a11cdv002ekzy65p165twt","_id":"cj8a11cdx002jkzy6y3spn4np"},{"post_id":"cj8a11cde001gkzy6h09xic3i","category_id":"cj8a11cdw002ikzy6j55gkzcr","_id":"cj8a11cdx002lkzy6slgrxrum"},{"post_id":"cj8a11cdf001jkzy6jcxwv61l","category_id":"cj8a11cdx002kkzy6xl8b737c","_id":"cj8a11cdy002nkzy6z6869yea"},{"post_id":"cj8a11cdf001lkzy65i657udq","category_id":"cj8a11cdx002kkzy6xl8b737c","_id":"cj8a11cdz002pkzy6w2vnkzvk"},{"post_id":"cj8a11cdh001okzy6u8zk8yli","category_id":"cj8a11cdx002kkzy6xl8b737c","_id":"cj8a11ce1002rkzy6kvvy71hi"},{"post_id":"cj8a11cdk001qkzy6uqypanag","category_id":"cj8a11cdx002kkzy6xl8b737c","_id":"cj8a11ce3002tkzy64b4w1a89"},{"post_id":"cj8a11cdl001tkzy61a57kawb","category_id":"cj8a11cdx002kkzy6xl8b737c","_id":"cj8a11ce4002vkzy6o485gy0l"},{"post_id":"cj8a11cdn001vkzy6brjczbu9","category_id":"cj8a11cdx002kkzy6xl8b737c","_id":"cj8a11ce5002xkzy6xi0se2h0"},{"post_id":"cj8a11cdp001ykzy6po6puodw","category_id":"cj8a11cdx002kkzy6xl8b737c","_id":"cj8a11ce5002ykzy6eyhtnfyo"},{"post_id":"cj8a11cgt0033kzy6n1fp5p7i","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11ch3003hkzy6tw7umdd5"},{"post_id":"cj8a11cgt0033kzy6n1fp5p7i","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11ch8003kkzy6xf9gzaqb"},{"post_id":"cj8a11cgt0033kzy6n1fp5p7i","category_id":"cj8a11cgz003bkzy6tt5yyhv5","_id":"cj8a11ch9003mkzy6yo194ql4"},{"post_id":"cj8a11cgp002zkzy631leuupx","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11chc003pkzy68nzvkhkj"},{"post_id":"cj8a11cgp002zkzy631leuupx","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11che003rkzy6156gkluj"},{"post_id":"cj8a11cgp002zkzy631leuupx","category_id":"cj8a11cgz003bkzy6tt5yyhv5","_id":"cj8a11chg003ukzy63dik44j3"},{"post_id":"cj8a11cgu0034kzy62a8ykhvb","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11chh003wkzy6gc7a1suy"},{"post_id":"cj8a11cgu0034kzy62a8ykhvb","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11chj003zkzy6qa1602kn"},{"post_id":"cj8a11cgu0034kzy62a8ykhvb","category_id":"cj8a11cgz003bkzy6tt5yyhv5","_id":"cj8a11chk0041kzy6lzkkjs4l"},{"post_id":"cj8a11cgv0036kzy6fysa2lgc","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11chm0044kzy6a8jq06o7"},{"post_id":"cj8a11cgv0036kzy6fysa2lgc","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11chr0046kzy6v1t401kr"},{"post_id":"cj8a11cgv0036kzy6fysa2lgc","category_id":"cj8a11cha003nkzy6k3836k56","_id":"cj8a11cht0049kzy6oduoy5ct"},{"post_id":"cj8a11cgq0030kzy6aqzwlh2e","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11chu004bkzy6jkpevofh"},{"post_id":"cj8a11cgq0030kzy6aqzwlh2e","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11chw004ekzy63yjdu2gg"},{"post_id":"cj8a11cgq0030kzy6aqzwlh2e","category_id":"cj8a11cgz003bkzy6tt5yyhv5","_id":"cj8a11chx004gkzy6fuixd326"},{"post_id":"cj8a11cgw0037kzy6yi12pcul","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11chz004jkzy64jqdoilc"},{"post_id":"cj8a11cgw0037kzy6yi12pcul","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11ci0004lkzy6vlttt3bn"},{"post_id":"cj8a11cgw0037kzy6yi12pcul","category_id":"cj8a11cgz003bkzy6tt5yyhv5","_id":"cj8a11ci1004okzy695v1ew6r"},{"post_id":"cj8a11cgx0039kzy6er8qnksg","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11ci3004qkzy6mq9xlj5p"},{"post_id":"cj8a11cgx0039kzy6er8qnksg","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11ci4004tkzy6k821029z"},{"post_id":"cj8a11cgx0039kzy6er8qnksg","category_id":"cj8a11cgz003bkzy6tt5yyhv5","_id":"cj8a11ci6004vkzy6ei606sfv"},{"post_id":"cj8a11cgs0031kzy6ej272g8s","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11ci8004ykzy6lfi2aekj"},{"post_id":"cj8a11cgs0031kzy6ej272g8s","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11ci90050kzy6g39ywmv4"},{"post_id":"cj8a11cgs0031kzy6ej272g8s","category_id":"cj8a11cgz003bkzy6tt5yyhv5","_id":"cj8a11cia0053kzy65hjawc9f"},{"post_id":"cj8a11cgx003akzy6sen92gv9","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cib0055kzy6nnf1b6zi"},{"post_id":"cj8a11cgx003akzy6sen92gv9","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cic0058kzy6l9ujax5b"},{"post_id":"cj8a11cgx003akzy6sen92gv9","category_id":"cj8a11cha003nkzy6k3836k56","_id":"cj8a11cid005akzy6qki86uet"},{"post_id":"cj8a11cgz003ckzy6tbyb45nb","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cie005dkzy6823mz66u"},{"post_id":"cj8a11cgz003ckzy6tbyb45nb","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cif005fkzy65w0375of"},{"post_id":"cj8a11cgz003ckzy6tbyb45nb","category_id":"cj8a11cha003nkzy6k3836k56","_id":"cj8a11cig005ikzy6jv5ng0vn"},{"post_id":"cj8a11ci0004nkzy66tdd2l6d","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cih005kkzy6cxq94di2"},{"post_id":"cj8a11ci0004nkzy66tdd2l6d","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cii005mkzy6ivjgvfr5"},{"post_id":"cj8a11ci0004nkzy66tdd2l6d","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cii005nkzy6ul82w5p1"},{"post_id":"cj8a11ch0003dkzy6s1pdh7ye","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cij005pkzy6691b5fnf"},{"post_id":"cj8a11ch0003dkzy6s1pdh7ye","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cij005qkzy6gvryqqco"},{"post_id":"cj8a11ch0003dkzy6s1pdh7ye","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cij005skzy6dqp0miuy"},{"post_id":"cj8a11ci1004pkzy6ryhu6ckm","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cij005tkzy64z6mj84a"},{"post_id":"cj8a11ci1004pkzy6ryhu6ckm","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cil005vkzy60g7uc3jm"},{"post_id":"cj8a11ci1004pkzy6ryhu6ckm","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cil005wkzy6x80128ay"},{"post_id":"cj8a11ci3004rkzy6viod4sbo","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cim005ykzy6rekom4dr"},{"post_id":"cj8a11ci3004rkzy6viod4sbo","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cin005zkzy6z0ya1qa5"},{"post_id":"cj8a11ci3004rkzy6viod4sbo","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cin0061kzy6aghr3q7f"},{"post_id":"cj8a11ch1003fkzy61uy1b32c","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cio0062kzy6ozuns9qj"},{"post_id":"cj8a11ch1003fkzy61uy1b32c","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cio0064kzy6milql12h"},{"post_id":"cj8a11ch1003fkzy61uy1b32c","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cio0065kzy6niclm688"},{"post_id":"cj8a11ci5004ukzy6vfn0qo6p","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cip0067kzy6ayv29fx1"},{"post_id":"cj8a11ci5004ukzy6vfn0qo6p","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cip0068kzy6q8hbjf4a"},{"post_id":"cj8a11ci5004ukzy6vfn0qo6p","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cip006akzy6zc2kt49g"},{"post_id":"cj8a11ch3003gkzy6fw5kjs7x","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cip006bkzy6ycp4su3t"},{"post_id":"cj8a11ch3003gkzy6fw5kjs7x","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11ciq006dkzy6hhho93ut"},{"post_id":"cj8a11ch3003gkzy6fw5kjs7x","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cir006ekzy6wb0psr5f"},{"post_id":"cj8a11ch5003jkzy621e6zjze","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cir006gkzy6s5r3q8o0"},{"post_id":"cj8a11ch5003jkzy621e6zjze","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cis006hkzy6eepmx6j3"},{"post_id":"cj8a11ch5003jkzy621e6zjze","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cit006jkzy6b7nqo1a7"},{"post_id":"cj8a11ch9003lkzy6uukrytat","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cix006kkzy69x7it47z"},{"post_id":"cj8a11ch9003lkzy6uukrytat","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11ciy006mkzy6kv4gjznp"},{"post_id":"cj8a11ch9003lkzy6uukrytat","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11ciz006nkzy62d0yg3s8"},{"post_id":"cj8a11cha003okzy6s3191tfq","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj0006pkzy6upxmi2p2"},{"post_id":"cj8a11cha003okzy6s3191tfq","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj1006qkzy6kvndgh70"},{"post_id":"cj8a11cha003okzy6s3191tfq","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj1006skzy62umpy7yq"},{"post_id":"cj8a11chd003qkzy658loq289","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj2006tkzy6oui9unql"},{"post_id":"cj8a11chd003qkzy658loq289","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj2006vkzy6yha4sbae"},{"post_id":"cj8a11chd003qkzy658loq289","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj3006wkzy6sn07xky5"},{"post_id":"cj8a11che003tkzy61w26laj3","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj3006ykzy6f421qo98"},{"post_id":"cj8a11che003tkzy61w26laj3","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj3006zkzy6prw96cls"},{"post_id":"cj8a11che003tkzy61w26laj3","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj40071kzy6dsjov1ve"},{"post_id":"cj8a11chg003vkzy68xw5ikei","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj40072kzy6hiyk2r0z"},{"post_id":"cj8a11chg003vkzy68xw5ikei","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj40073kzy6usw67svv"},{"post_id":"cj8a11chg003vkzy68xw5ikei","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj40075kzy6utztj3c8"},{"post_id":"cj8a11chi003ykzy6fwuuh18i","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj40076kzy6nqna295g"},{"post_id":"cj8a11chi003ykzy6fwuuh18i","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj50078kzy63vkq2r9t"},{"post_id":"cj8a11chi003ykzy6fwuuh18i","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj50079kzy6j0brq2tw"},{"post_id":"cj8a11chj0040kzy6pfbzfaep","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj5007bkzy6r0huerai"},{"post_id":"cj8a11chj0040kzy6pfbzfaep","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj6007ckzy6nblp9p0x"},{"post_id":"cj8a11chj0040kzy6pfbzfaep","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj6007dkzy698szosyq"},{"post_id":"cj8a11chk0043kzy6gfuadjsw","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj6007ekzy6ng3i6j0n"},{"post_id":"cj8a11chk0043kzy6gfuadjsw","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj6007fkzy6kk7gfp9m"},{"post_id":"cj8a11chk0043kzy6gfuadjsw","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj6007gkzy6o7iujaz1"},{"post_id":"cj8a11chm0045kzy6y7ouldzy","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj6007hkzy6opvjpbn2"},{"post_id":"cj8a11chm0045kzy6y7ouldzy","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj6007ikzy6blnhf817"},{"post_id":"cj8a11chm0045kzy6y7ouldzy","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj6007jkzy699vn66f4"},{"post_id":"cj8a11chs0048kzy6bb8z8vmx","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj6007kkzy619rrtuse"},{"post_id":"cj8a11chs0048kzy6bb8z8vmx","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj6007lkzy62ht53iv6"},{"post_id":"cj8a11chs0048kzy6bb8z8vmx","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj6007mkzy6zgkbkj25"},{"post_id":"cj8a11chu004akzy6uieeo1ai","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj6007nkzy6ionxxtsr"},{"post_id":"cj8a11chu004akzy6uieeo1ai","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj6007okzy6aqnue8q7"},{"post_id":"cj8a11chu004akzy6uieeo1ai","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj6007pkzy6g09wel9b"},{"post_id":"cj8a11chv004dkzy6l2wtjrak","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj6007qkzy6aqx52hi0"},{"post_id":"cj8a11chv004dkzy6l2wtjrak","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj6007rkzy6688jrrg2"},{"post_id":"cj8a11chv004dkzy6l2wtjrak","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj6007skzy6yu4e4z2b"},{"post_id":"cj8a11chw004fkzy6fxuw8r0v","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj6007tkzy6ct0r66at"},{"post_id":"cj8a11chw004fkzy6fxuw8r0v","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj6007ukzy6h91p13p9"},{"post_id":"cj8a11chw004fkzy6fxuw8r0v","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj6007vkzy6v7pl025b"},{"post_id":"cj8a11chy004ikzy6txgbc06l","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj7007wkzy66426a5im"},{"post_id":"cj8a11chy004ikzy6txgbc06l","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj7007xkzy619zzjbg1"},{"post_id":"cj8a11chy004ikzy6txgbc06l","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj7007ykzy6pdmybycc"},{"post_id":"cj8a11chz004kkzy69vawud9w","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj7007zkzy6d0ywegdz"},{"post_id":"cj8a11chz004kkzy69vawud9w","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj70080kzy69gotkdgg"},{"post_id":"cj8a11chz004kkzy69vawud9w","category_id":"cj8a11ci0004mkzy6ftz84wnk","_id":"cj8a11cj70081kzy6xzdp2d4m"},{"post_id":"cj8a11ci7004wkzy6emly8qsh","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj70082kzy656qsb6xc"},{"post_id":"cj8a11ci7004wkzy6emly8qsh","category_id":"cj8a11ciy006lkzy6q92ynr3e","_id":"cj8a11cj70083kzy6tn1vwh35"},{"post_id":"cj8a11ci8004zkzy6ag9rdim5","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj70084kzy61vbawv25"},{"post_id":"cj8a11ci8004zkzy6ag9rdim5","category_id":"cj8a11ciy006lkzy6q92ynr3e","_id":"cj8a11cj70085kzy68f7axqat"},{"post_id":"cj8a11ci90051kzy68hgsn8nx","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj70086kzy6xnqg26ke"},{"post_id":"cj8a11ci90051kzy68hgsn8nx","category_id":"cj8a11ciy006lkzy6q92ynr3e","_id":"cj8a11cj70087kzy6xgnohjww"},{"post_id":"cj8a11cia0054kzy6uhppyqck","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj70088kzy657yds9xi"},{"post_id":"cj8a11cia0054kzy6uhppyqck","category_id":"cj8a11ciy006lkzy6q92ynr3e","_id":"cj8a11cj70089kzy6q39apro8"},{"post_id":"cj8a11cib0056kzy6bh1ws5t0","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj7008akzy6tgtuflts"},{"post_id":"cj8a11cib0056kzy6bh1ws5t0","category_id":"cj8a11ciy006lkzy6q92ynr3e","_id":"cj8a11cj7008bkzy6ztbirfpt"},{"post_id":"cj8a11cie005bkzy6781qzx8f","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj7008ckzy6zkc13g5g"},{"post_id":"cj8a11cie005bkzy6781qzx8f","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj7008dkzy6bfpabex5"},{"post_id":"cj8a11cie005bkzy6781qzx8f","category_id":"cj8a11cj30070kzy6mju0ia4s","_id":"cj8a11cj7008ekzy6wmnh07x6"},{"post_id":"cj8a11cif005ekzy63biikjsh","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj7008fkzy6g29xjtri"},{"post_id":"cj8a11cif005ekzy63biikjsh","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj7008gkzy6u7vwdo7g"},{"post_id":"cj8a11cif005ekzy63biikjsh","category_id":"cj8a11cj40074kzy6xk26v4nb","_id":"cj8a11cj7008hkzy6431eodqf"},{"post_id":"cj8a11cif005gkzy6ngl0bglo","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj7008ikzy6o1vy56vt"},{"post_id":"cj8a11cif005gkzy6ngl0bglo","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj7008jkzy6gmn32hvs"},{"post_id":"cj8a11cif005gkzy6ngl0bglo","category_id":"cj8a11cj30070kzy6mju0ia4s","_id":"cj8a11cj7008kkzy6qmlt6133"},{"post_id":"cj8a11cih005jkzy65radeshg","category_id":"cj8a11cbo0003kzy6s44adscv","_id":"cj8a11cj8008lkzy6o7yycajm"},{"post_id":"cj8a11cih005jkzy65radeshg","category_id":"cj8a11cgs0032kzy6djrqjyd1","_id":"cj8a11cj8008mkzy6m5lgyn3l"},{"post_id":"cj8a11cih005jkzy65radeshg","category_id":"cj8a11cj30070kzy6mju0ia4s","_id":"cj8a11cj8008nkzy6bp3tl1y3"}],"PostTag":[],"Tag":[]}}