---
title: 内存泄漏
type: "categories"
categories: 后端
---

# 内存泄漏
Node对内存泄漏很敏感，一旦线上有成千上万的流量，哪怕是一个字节的内存泄漏也会造成堆积，垃圾回收过程中将会耗费更多的时间进行扫描，应用响应缓慢，直到进程内内存溢出，应用崩溃。
在V8的垃圾回收机制下，通常的代码编写中，很少出现内存泄漏的情况。但是内存泄漏产生于无意间，难排查，内存泄漏的情况不尽相同，但是实质上只有一个，就是应该回收的对象没有被回收，变成了常驻在老生代中的对象。

内存泄漏造成的原因：
- 缓存
- 队列消费不及时
- 作用域没释放

## 慎将内存当缓存
缓存在应用中很重要，可以十分节省资源，因为他的访问效率要比I/O的高，一旦命中，就可以节省一次I/O的时间。
但是在Node中，一旦对象被缓存下来，就意味着他会常驻老生代中，缓存中存储的键越多，长期存活的对象也就多，这导致垃圾回收在进行扫描整理的时候，对这些对象做无用功。
另一个问题在于js开发者喜欢用对象的键值对来缓存东西，但是没有缓存的过期策略，不能称为缓存。所以尽量少用，如果要用加上过期策略以防止内存无限增长。

### 缓存限制策略
使用limitableMap，实现对键值数量的限制

```
var limitableMap = function(limit) {
	this.limit = limit || 10
	this.map = {}
	this.keys = []
}
var hasOwnProperty = Object.prototype.hasOwnProperty
limitableMap.prototype.set = function(key, value) {
	var map = this.map
	var keys = this.keys
	if(!hasOwnProperty.call(map, key)) {
		if(keys.length == this.limit) {
			var firstKey = keys.shift()
			delete map[firstKey]
		}
		keys.push(key)
	}
	map[key] = value
}
limitableMap.prototype.get = function(key) {
	return this.map[key]
}
modules.exports = limitableMap
//采用先进先出的方式进行淘汰
```
### 缓存的解决方案
内存作为缓存除了限制缓存的大小外，另外要考虑的事情就是进程间无法共享内存，如果在进程内使用缓存，这些缓存不可避免的要重复，对物理内存是种浪费。
如果大量使用内存，比较好的方案就是进程外的缓存，进程自身不存储状态。
外部的缓存有较好的缓存过期淘汰策略，以及自有的内存管理，不影响Node的进程的性能，解决了以下问题
- 减少常驻内存对象的数量，让垃圾回收更高效
- 进程之间可以共享缓存
常见的缓存有 Redis 和 Memcached
