---
title: 高效利用内存
type: "categories"
categories: 后端
---

# 高效利用内存
前面已经介绍了内存限制和垃圾回收机制，了解了高效的使用内存的重要性，那么在V8中，开发者如何让垃圾回收机制更高效的工作

## 作用域
首先，如何触发垃圾回收呢，我们先来介绍作用域，在js中能形成作用域的有函数调用，with以及全局作用域

```
var foo = function() {
	var local = {}
}
```
foo()函数在每次被调用时会创建对应的作用域，函数执行结束后，该作用域被销毁，同时作用域中声明的局部变量分配在该作用域上，随着作用域的销毁而销毁。只是被局部变量引用的对象存活周期短。在上面的例子中，由于对象非常小，将会被分配到新生代的From空间中。在作用域释放后，局部变量local失效，其引用的对象将会在下次垃圾回收时被释放，以上就是最基本的垃圾回收过程

## 标识符查找
**与作用域相关的就是标识符的查找，所谓标识符，可以把它看做变量名，**在下面的代码中，执行bar()函数时，将会遇到local变量
```
var bar = function() {
	console.log(local)
}
```
javascript执行的时候会去查找该变量定义在哪里，最先查找的是当前作用域，若无，则往上层作用域找

## 作用域链
由于标识符的查找方向是向上的，所以变量只能向外访问

## 变量的主动释放
由于全局变量驻扎在全局作用域中，需要退出进程才能释放，此时会导致常驻在内存（老生代）中，如果需要删除，通过delete删除引用关系，或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理过程中，会被回收释放。但是最好通过赋值方式解除最好，delete删除对象的属性会干扰V8的优化

## 闭包
在javascript中，**实现外部作用域访问内部作用域中变量的方法叫做闭包**
```
var foo = function() {
	var bar = function() {
		var local = '局部变量'
		return function() {
			return local
		}
	}
	var baz = bar()
	return baz
}
```
- 一般来说bar函数执行完毕local会随着作用域的销毁而销毁，但是这里返回值是一个匿名函数，且这个函数具备了访问local的条件。这得益于高阶函数的特性，函数可以作为参数和返回值
- 外部作用域可以通过这个中间函数稍作周转就可以访问到内部作用域的变量
- 一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放，除非不在有引用才会释放。

# 总结
在正常的javascript中，无法立即回收的内存有闭包和全局变量引用这两种情况。由于V8的内存的限制，要十分小心此类变量是否无限制增加，因为会导致老生代中的对象增多

